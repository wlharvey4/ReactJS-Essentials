# -*- mode: org; fill-column: 79; -*-

#+TITLE: React.js Essentials
#+SUBTITLE: A fast-paced guide to designing and building scalable and maintainable web apps with React.js
#+AUTHOR: Artemij Fedosejev
#+DATE: <2019-03-09 Sat 20:54>

#+TEXINFO: @insertcopying

* Preface
:PROPERTIES:
:UNNUMBERED: t
:END:

#+CINDEX:imperative code
#+CINDEX:declarative code
#+CINDEX:jQuery
#+CINDEX:modular
#+CINDEX:scalable
The Web is different.  The way we build for the Web is different.  Faced by the
challenges of dealing with unmaintainable /imperative code/ produced by jQuery
we had to look for new ways of managing the complexity of modern user
interfaces.  We needed a new user interface library that would help us build
/declarative/, /modular/, fast and /scalable/ frontend applications.

{{{subheading(React.js --- User Interface Library)}}}

#+CINDEX:user interface library
#+CINDEX:Facebook
#+CINDEX:DOM
#+CINDEX:data flow, organize
Meet React.js --- a JavaScript user interface library developed by Facebook.
It brings profound ideas on how to work with the DOM, organize your
application's data flow, and think about user interface elements as individual
components.  And yet, it's only a user interface library that makes no
assumptions about the rest of your technology stack.

{{{subheading(With Flux)}}}

#+CINDEX:Flux
#+CINDEX:frontend architecture
Combined with Flux, we get a powerful frontend architecture that makes sense
not only to experienced developers, but also those who are just starting their
frontend journey.

** From the Author

  #+CINDEX:Fedosejev, Artemij
- [[https://github.com/fedosejev][Artemij Fedosejev]]


  #+CINDEX:React Essentials Github
- [[https://github.com/fedosejev/react-essentials][Author's React Essentials Github Page]]

  #+CINDEX:tutorials, React
- [[https://react.tips][React Tutorials]]

- [[https://react.tips/from-react-to-flux-to-redux/][From React.js To Flux To Redux]]

  If you want to really understand what's the difference between building web
  apps with React only, or with React and Flux, or with React and Redux, then
  check the four examples that I've prepared for you.

  #+CINDEX:shopping list app examples
  #+CINDEX:examples, shopping list app
  They all implement exactly the same Shopping List app, but most importantly -
  they highlight the difference in how you approach building web apps using
  different tools.

    #+CINDEX:ES5 JavaScript
    #+CINDEX:JavaScript ES5
  - Built with React.js and JavaScript ES5

    In this [[https://github.com/fedosejev/shopping-list-react][example]], I am using only React.js without Flux or Redux to build
    the entire app. And I am using the good old JavaScript that all know and
    love (or hate?): version ECMAScript 5.

    This example is the best place for you to start if you're not familiar with
    Flux or Redux at all. It helps you to understand why we need Flux or
    Redux. You will feel strange when storing application state (the shopping
    list itself) in React components, knowing that React should only be
    responsible for knowing how to render the user interface.

    #+CINDEX:ES2015, JavaScript
    #+CINDEX:JavaScript ES2015
  - Built with React.js and JavaScript ES2015

    The industry uses a newer version of JavaScript today: ECMAScript 2015. It
    brings new syntax and React takes advantage of that syntax.

    If you want to see how to transition from tradition ES5 syntax to newer
    ES2015 syntax in the context of React app, then this [[https://github.com/fedosejev/shopping-list-react-es2015][example]] is perfect for
    you. Feel free to compare it with the the previous one (ES5 version).

    #+CINDEX:Flux with ES5
    #+CINDEX:ES5 and Flux
  - Built with React.js and Flux and JavaScript ES5

    If React feels familiar to you and you can build simple apps with it then
    you most likely faced a problem of accessing application state from
    different React components. It's not a straight forward task! And it feels
    awkward, because we know that React is a UI library, and if we follow the
    separation of concerns principle, then it's clear to us that we shouldn't
    store application state in React components!

    Where do we store it then? That's why you might need to introduce Flux
    architecture to your React application.

    This [[https://github.com/fedosejev/shopping-list-react-flux][example]] is a perfect introduction to the Flux architecture, because
    you're building exactly the same app, but now you're clearly separating
    your UI logic from your application state logic.

    #+CINDEX:Redux with ES2015
    #+CINDEX:ES2015 and Redux
  - Built with React.js and Redux and JavaScript ES2015

    Flux is a great start for understanding how data flows in your React
    application. Redux takes it to the next level by building on top of ideas
    from Flux and introducing new important concepts that allow you to build
    really scalable and robust React apps.  See [[https://github.com/fedosejev/shopping-list-react-redux][example]].

** What this Book Covers

*** Chapter 1 Installing Powerful Tools

- Goals
- Tools
- Structure for project

*** Chapter 2 Create Your First React Element

- Install React
- Virtual DOM
- React Element
- Create and render a React element
- with native JavaScript
- JSX syntax
- Create React Elements using JSX

*** Chapter 3 Create Your First React Component

- React components
- Difference between stateless and stateful React components
- Creates both kinds

*** Chapter 4 Make Your React Components Reactive

- How to solve problems with React
- Plan a React application
- Create a React component that encapsulates entire app
- Relationship between parent and child React components

*** Chapter 5 Use Your React Components with Another Library

- How to use third party JavaScript libraries
- React component's lifecycle
- How to use mounting methods
- Create new components for project

*** Chapter 6 Update Your React Components

- React component lifecycle's updating mnethods
- CSS styles in JavaScript
- Validate and set default component properties

*** Chapter 7 Build Complex React Components

- Building more complex React components
- Implement different React components
- Put them together into one coherent and functional app

*** Chapter 8 Test Your React Application with Jest

- Unit testing
- Write and run unit tests with Jest
- Test React components
- Test suites, specs, expectations, and matchers

*** Chapter 9 Supercharge Your React Architecture with Flux

- Improve the architecture of React application
- Flux architecture
- Role of dispatcher, stores, and and action creators

*** Chapter 10 Prepare Your React Application for Painless Maintenance with Flux

- Decouple concerns in a React app with Flux
- Refactor React app to allow painless maintainability

** What You Need for this Book

1. Latest version of a modern web browser, e.g.,
   - [[https://www.google.com/chrome/browser][Google Chrome]]
   - [[https://www.mozilla.org/en-US/firefox/new/][Mozilla Firefox]]

2. Git

3. Node.js

4. npm

5. Code editor, e.g.
   - [[http://www.sublimetext.com][Sublime Text]]
   - [[https://atom.io][Atom]]
   - [[http://brackets.io][Brackets]]
   - [[https://code.visualstudio.com][Visual Studio Code]]
   - Your choice

** Who this Book is For

This book is intended for frontend developers who want to build scalable and
maintainable user interfaces for the Web.  Some core knowledge of JavaScript,
HTML, and CSS is the only thing you need to know to start benefiting.  If you
have previous experience with jQuery or Angular.js, then you will benefit from
understanding how React.js is different and how to take advantage of
integrating different libraries with it.

** Conventions

** Reader Feedback

** Downloading the Example Code

https://github.com/fedosejev/react-essentials

** Errata

https://wwwpacktpub.com/books/content/support

enter the name of the book in the search field.

** ES6 Version

A refactoring of the project described in "React.js Essentials" using ES6
rather than just ES5.  This is merely a refactoring of the project described in
"React.js Essentials" (by Artemij Fedosejev) that uses ES6 features (e.g.,
class, import, etc.) rather than just ES5. (It also leaves out the console.log
spam.)

- From [[https://github.com/jmrog/react-essentials-es6-version][Jason Roger]]

* 1. Installing Powerful Tools for your Project

#+CINDEX:Kettering, Charles
#+BEGIN_QUOTE
My interest is in the future because I am going to spend the rest of my life
there.
{{{tiauthor(Charles F. Kettering)}}}
#+END_QUOTE

#+CINDEX:spaghetti code
#+CINDEX:mental model, spaghetti
This brilliant inventor has left software engineers with the single most
important piece of advice way before we even started thinking about how to
write software.  Yet, half a century later, we're still figuring out why we end
up with spaghetti code or the ``spaghetti mental model.''

{{{heading(Writing Softward for the Future)}}}

#+CINDEX:mental model
#+CINDEX:complexity remains the same
What does it mean to ``write software for the future, today''?  It boils down
to creating a simple mental model that doesn't change, no matter how big your
project becomes over time.  When the size of your project grows, the complexity
always stays the same.  This mental model is your blueprint, and once you
understand it you will understand how your whole piece of software works.

{{{heading(Facebook Releases React in 2013)}}}

#+CINDEX:Facebook
#+CINDEX:Occhino, Tom
In 2013, Facebook released React---an open source JavaScript library for
building user interfaces.  You can read more about it at
http://facebook.github.io/react/.  In early 2015, Tom Occhino from Facebook
summarized what makes React so powerful:

{{{heading(Declarative vs Imperative Programming)}}}

#+BEGIN_QUOTE
React wraps an imperative API with a declarative one.  React's real power lies
in how it makes you to write code.
{{{tiauthor(Tom Occhino)}}}
#+END_QUOTE

#+CINDEX:declarative style
#+CINDEX:imperative style
#+CINDEX:DOM API
#+CINDEX:jQuery
A declarative style of programming results in less code.  It tells a computer
what to do without specifying how, while an imperative style of programming
describes how to do it.  JavaScript's call to the DOM API is an example of
imperative programming.  jQuery is another such example.

{{{heading(React is Good for Small Projects)}}}

#+CINDEX:small React project
#+CINDEX:shopping list
It works for small projects too; here is an example of a [[http://fedosejev.github.io/shopping-list-react][shopping list]] build
with React.  React is one of the best JavaScript libraries used for building
user interfaces that is available for developers today.

{{{heading(The Goal of this Book)}}}

#+CINDEX:goal
#+CINDEX:fundamental principles of React
#+CINDEX:React's fundamental principles
#+CINDEX:principles, fundamental
#+CINDEX:project, real-time web application
Goal is for you to understand the fundamental principles of React.  To achieve
this, you will be introduced to one React component at a time, explained it,
and shown how you can apply it.  Step by step, you'll build a real-time web
application, raise important questions along the way, and discuss solutions
that React provides us with.

{{{heading(Flux)}}}

#+CINDEX:Flux
#+CINDEX:mental model
You will learn about [[*Flux][Flux]], which implements a unidirectional flow of data.
Together with Flux and React, you'll create a predictable and manageable code
base that you will be able to expand by adding new features, without scaling
its complexity.  The mental model of how your web application works will stay
the same, no matter how many new features you add later.

** Approaching our Project

The best motivation for learning new technology is a project that excites you
and that you can't wait to build.  In this book the author wants you to build a
project that feels like a breath of fresh air.  A project which you most likely
wouldn't build in your day-to-day work.  It has to be a fun endeavor, which not
only educates you but also satisfies your curiosity and stretches your
imagination.  This project shouldn't be a time consuming long-term commitment
for you either.

#+CINDEX:Snapterest
#+CINDEX:project Snapterest
#+CINDEX:Twitter
#+CINDEX:Pinterest
#+CINDEX:website functionality
Enter *Snapterest*---a web application that allows you to discover and collect
public photos posted on Twitter.  Think of it as Pinterest with the only source
of pictures being Twitter.  We will implement a fully functional website with
the following core functionalities:

- Receiving and displaying tweets in real time

- Adding and removing tweets to / from a collection

- Reviewing collected tweets

- Exporting a collection of tweets as an HTML snippet that you can share


#+CINDEX:tools
When you start working on a new project, the very first thing that you do is
get your tools ready.  For this project, we will be using a number of tools.

** DONE Installing Node.js and npm
:todo:
:task: Check for Jest and Node.js compatibility currently
:end:

  #+CINDEX:Node.js, installation
- [[https://nodejs.org][Node.js]] ::

     #+CINDEX:JavaScript
     #+CINDEX:Node.js benefits
     #+CINDEX:event-driven
     #+CINDEX:non-blocking
     #+CINDEX:real-time
     is a platform that allows us to write server-side applications with a
     client-side language: JavaScript.  The real benefit of Node.js is that it
     uses an /event-driven/, /non-blocking I-O/ model, which is perfect for
     building /data-intensive/, /real-time/ applications.  It means that, with
     Node.js, we should be able to handle an incoming stream of tweets and
     process them as soon as they arrive.


- [[https://nodejs.org/en/][Node.js Home]]

<<install-node.js>>{{{heading(Install Node.js)}}}

#+CINDEX:install Node.js
#+CINDEX:Jest
Install Node.js.  We'll be using version =v0.10.40= because, at the time
of writing this book, that's the latest version of Node.js that Jest
supports.[fn::The current versions of Node.js as of the publication of
this document ({{{date}}}) are =10.15.2 LTS= and =11.10.1 Current=.  The
current version of Jest is =24.1=, which appears to work with the current
version of Node.js and React.]

#+CINDEX:distribution, Node.js
#+CINDEX:installation package, Node.js
- Go to http://nodejs.org/dist/v0.10.40/ and download the installation package
  for your OS:

    #+CINDEX:OS X
  - [[http://nodejs.org/dist/v0.10.40/node-v0.10.40-darwin-x64.tar.gz][OS X]]:[fn::Created 09-Jul-2015 21:30] ::

      Run it and follow the installation steps that Node.js will prompt you with.
      Test for successful installation:
      : $ node -v
      : v0.10.40


{{{subheading(npm Should Be Installed with Node.js)}}}
  #+CINDEX:npm, installation
- [[http://www.npmjs.com][npm]][fn::Current npm version is =6.8.0= as of {{{date}}}] ::

  #+CINDEX:package manager, npm
  is a package manager that manages Node.js modules.  It is shipped with
     Node.js, so it was installed by the previous step.  To test:
     : $ npm -v
     : 1.4.28

** Installing Git

#+CINDEX:Git
#+CINDEX:install Git
#+CINDEX:getting started with Git
<<install-git>>We'll be using Git to install Node.js modules.  Visit:
- [[https://git-scm.com/book/en/v2/Getting-Started-Installing-Git][{{{cite(1.5 Getting Started - Installing Git)}}}]]

{{{noindent}}}and follow the installation instructions for your OS.

** Getting Data from the Twitter Streaming API

#+CINDEX:Twitter Streaming API
#+CINDEX:Streaming API, Twitter
#+CINDEX:tweets, receive public
#+CINDEX:JSON format, tweets
<<twitter-streaming>>The data for our React application will come from Twitter.
Twitter has the *Streaming API* that anyone can plug into to start receiving an
endless flow of public tweets in the JSON format.

To start using the Twitter Streaming API, you'll need to perform the following
steps:

{{{subheading(Create a Twitter Account and App)}}}

   #+CINDEX:Twitter account, create
1. <<create-twitter-account>>Create a Twitter account.  For this, go to
   https://twitter.com and sign up; or sign in if you already have an account.

   #+CINDEX:Twitter app, create
2. <<create-twitter-app>>Create a new Twitter App by navigating to
   https://developer.twitter.com/en/apps[fn::https://apps.twitter.com has been
   sunsetted] and click on {{{key(Create New App)}}}.  You will need to fill in
   the *Application Details* form, agree with the *Developer Agreement*, and
   click on *Create your Twitter application*.  Now you should see your
   application's page.


{{{subheading(Get Twitter Keys)}}}

<<twitter-keys>>Switch to the *Keys and Access Tokens* tab.  In the
*Applications Settings* section of this page, you'll find two vital pieces of
information:

   #+CINDEX:Twitter API keys
   #+CINDEX:keys, Twiter API
1. Consumer Key (API Key)

2. Consumer Secret (API Secret)


Take a note of them.

{{{subheading(Create a Twitter Access Token)}}}

#+CINDEX:access token, Twiter API
<<twitter-token>>Now generate an /access token/.  On the same page, you'll see
*Your Access Token* section that is empty.  Click on {{{key(Create my access
token)}}}.  It creates two pieces of information:

1. Access Token

2. Access Token Secret


Take a note of them too.  An access token is unique to you and you should not
share it with anyone.  Keep it private.

** Filtering Data with Snapkite Engine
:PROPERTIES:
:CUSTOM_ID: Snapkite Engine
:END:

#+CINDEX:filter
We need to filter the stream of data from the Twitter Streaming API into a
meaningful set of tweets that we can display and interact with.

#+CINDEX:Twitter Streaming API documentation
You should first take a quick look at the [[https://dev.twitter.com/streaming][Twitter Streaming API documentation]].
In particular take a look at the page that describes how to [[https://dev.twitter.com/streaming/reference/post/statuses/filter][filter]] an incoming
stream.  Twitter provides very few filters that we can apply, so we need to
find a way to filter that stream of data even further.

{{{heading(Snapkite Engine)}}}

#+CINDEX:Snapkite Engine Node.js application
#+CINDEX:Twitter Streaming API, filter engine for
#+CINDEX:tweets, filtered
#+CINDEX:web socket connection for filtered tweets
There is a Node.js application just for this.  It's called [[https://github.com/snapkite/snapkite-engine][Snapkite Engine]].
It connects to the Twitter Streaming API, filters it using the available
filters and according to the rules that you define, and outputs the filtered
tweets to a web socket connection.  Our React app can listen to the events on
that socket connection and process tweets as they arrive.

*** Install the Snapkite Engine
:PROPERTIES:
:CUSTOM_ID: install Snapkite Engine
:END:

   #+CINDEX:Snapkite Engine, install
1. Clone the Snapkite Engine repository into a directory of your choice:
   : cd <dir>
   : git clone https://github.com/snapkite/snapkite-engine.git
   This should create the ~<dir>/snapkite-engine~ folder.

   #+CINDEX:Node-Gyp module
2. <<install-node-gyp>>Now install the other node modules that
   ~snapkite-engine~ depends on.  One of them is the ~node-gyp~ module.  Also
   install other tools that are listed on [[https://github.com/TooTallNate/node-gyp#installation][node-gyp installation]].

3. Once you install them, you're ready to install the ~node-gyp~ command:
   : npm install --global node-gyp

4. Navigate to the ~<dir>/snapkite-engine~ directory to install the Node.js
   modules that Snapkite Engine depends on:
   : cd <dir>/snapkite-engine/
   : npm install

   #+CINDEX:Snapkite Engine, configure
   #+CINDEX:configure Snapkite Engine
5. <<configure-Snapkite>>Configure Snapkite Engine.  Assuming you are in the
   ~<dir>/snapkite-engine/~ directory, copy the ~./example.config.json~ file to
   ~./config.json~ by the following command:
   : cp example.config.json config.json

   #+CINDEX:@file{config.json}
6. <<config.json>>Open ~config.json~ in your editor to edit the configuration
   properties.

      #+CINDEX:@code{trackKeywords}
   - <<trackKeywords>>~trackKeywords~ ::
        This is where we will tell what keywords we want to track.  If we want
        to track the keyword =my=, then set it as follows:
        : "trackKeywords": "my"

   #+CINDEX:Twitter Streaming API keys, access token
   #+CINDEX:keys, Twitter Streaming API
   #+CINDEX:access token, Twitter Streaming API
7. <<Twitter-keys-and-token>>Set our Twitter Streaming API keys.  Set:
   - ~consumerKey~
   - ~consumerSecret~
   - ~accessTokenKey~
   - ~accessTokenSecret~
     #+CINDEX:Snapkite Engine documentation
     #+CINDEX:documentation, Snapkite Engine
   - other properties can be set to their defaults[fn::check out the Snapkite
     Engine [[https://github.com/snapkite/snapkite-engine][documentation]]]

   #+CINDEX:Snapkite Filter module
   #+CINDEX:Snapkite Filters, list
8. <<install-Snapkite-filters>>Install Snapkite Filters.  =Snapkite Filter= is
   a Node.js module that validates tweets according to a set of rules.  There
   are a number of Snapkite Filters out there, and we can use any combination
   of them to filter our stream of tweets as we like.  You can find a list of
   all available Snapkite Filters at
   https://github.com/snapkite/snapkite-filters.

   #+CINDEX:Snapkite Filters, used in project
   In our application, we'll use the following Snapkite Filters:

     #+CINDEX:@code{is-possibly-sensitive} Snapkite filter
   - <<is-possibly-sensitive-filter>>Is Possibly Sensitive ::
        https://github.com/snapkite/snapkite-filter-is-possibly-sensitive

     #+CINDEX:@code{has-mobile-photo} Snapkite filter
   - <<has-mobile-photo-filter>>Has Mobile Photo ::
        https://github.com/snapkite/snapkite-filter-has-mobile-photo

     #+CINDEX:@code{is-retweet} Snapkite filter
   - <<is-retweet-filter>>Is Retweet ::
        https://github.com/snapkite/snapkite-filter-is-retweet

     #+CINDEX:@code{has-text} Snapkite filter
   - <<has-text-filter>>Has Text ::
        https://github.com/snapkite/snapkite-filter-has-text


   #+CINDEX:install Snapkite filters
   #+CINDEX:Snapkite filters, install
   Install them.  Navigate to the ~<dir>/snapkite-engine/filters/~ directory:
   : cd <dir>/snapkite-engine/filters/
   Clone all Snapkite Filters by running these commands:
   : git clone https://github.com/snapkite/snapkite-filter-is-possibly-sensitive
   : git clone https://github.com/snapkite/snapkite-filter-has-mobile-photo
   : git clone https://github.com/snapkite/snapkite-filter-is-retweet
   : git clone https://github.com/snapkite/snapkite-filter-has-text

   #+CINDEX:Snapkite filters, configure
   #+CINDEX:configure Snapkite filters
9. <<configure-Snapkite-filters>>Configure them.  In order to do so, you need
   to create a configuration file for each Snapkite Filter in JSON format and
   define some properties in it.  Each Snapkite Filter comes with an example
   configuration file that we can duplicate and edit as needed.

   While in the ~<dir>/snapkite-engine/filters/~ directory, run the following
   commands:

   : cp snapkite-filter-is-possibly-sensitive/example.config.json
   : snapkite-filter-is-possibly-sensitive/config.json

   : cp snapkite-filter-has-mobile-photo/example.config.json
   : snapkite/snapkite-filter-has-mobile-photo/config.json

   : cp snapkite-filter-is-retweet/example.config.json
   : snapkite-filter-is-retweet/config.json

   : cp snapkite-filter-has-text/example.config.json
   : snapkite-filter-has-text/config.json

   We don't need to change any of the default settings in these ~config.json~
   files, as they are already configured to fit our purposes.

10. <<Snapkite-config.json>>Tell Snapkite Engine which Snapkite Filters it
    should use.  Open the ~<dir>/snapkite-engine/config.json~ file in a text
    editor and look for this:
    : "filters" : []

    Now replace that with the following:

    #+NAME:config.json
    #+CAPTION:Snapkite Engine ~config.json~
    #+BEGIN_SRC js
    "filters": [
        "snapkite-filter-is-possibly-sensitive",
        "snapkite-filter-has-mobile-photo",
        "snapkite-filter-is-retweet",
        "snapkite-filter-has-text"
    ]
    #+END_SRC


#+CINDEX:Snapkite Engine, test run
<<test-Snapkite-Engine>>With that you have successfully installed Snapkite
Engine with a number of Snapkite Filters.  Now let's check if we can run it.
Navigate to ~<dir>/snapkite-engine~ and run:
: $ npm start
: [Snapkite][Socket] Listening on port 3000

You should see no error messages.  If you do and you are not sure how to fix
them, go to https://github.com/fedosejev/react-essentials/issues, create a new
issue and copy/paste the error message that you get.

** Creating the Project Structure

#+CINDEX:project structure, create
#+CINDEX:structure organization
#+CINDEX:organization of project
#+CINDEX:architecture of project
Now create our project structure.  Organizing source files is not a simple
task.  A well-thought-out project structure organization helps us understand
the underlying architecture of our application.

{{{subheading(Root Project Directory)}}}

#+CINDEX:root project directory
#+CINDEX:@file{snapterest} directory
<<create-root-project-directory>>Start by creating a /root project directory/
named {{{file(snapterest/)}}} inside a directory of your choice:
{{{file(<dir>/snapterest/)}}}.  Inside it create two other directories:

  #+CINDEX:@file{source} directory
  #+CINDEX:@file{components} directory
  #+CINDEX:directories, @file{source}, @file{components}
- <<source-directory>>{{{file(<dir>/snapterest/source/)}}} ::
     store our source JavaScript files
     - {{{file(components/)}}} ::
       create this directory inside the {{{file(source/)}}} directory

  #+CINDEX:@file{build} directory
  #+CINDEX:directory, @file{build}
- <<build-directory>>{{{file(<dir>/snapterest/build/)}}} ::
     store compiled JavaScript files and an HTML file


{{{subheading(Populate the project structure with an application file)}}}

   #+CINDEX:@file{app.js}
   #+CINDEX:application file, @file{app.js}
- <<application-file>>{{{file(app.js)}}} ::

     place the main application file in the ~source/~ directory.  This file
     will be the entry point to our application.  Leave it empty for now.

** Building the Project

   #+CINDEX:DRY
   #+CINDEX:code reuse
- *DRY*: *Don't Repeat Yourself* ::

     One of the core principles in software development --- code reuse: The
     best code is the one that you don't need to write.  One of the goals in
     this project is to write as little code as possible.  React helps us
     achieve this goal.

#+CINDEX:declarative programming style
#+CINDEX:programming style, declarative
#+CINDEX:code reuse
When it comes to not writing code, we can apply the following strategies:

- Writing our code in a /declarative/ programming style
- Reusing the code written by someone else


#+CINDEX:jQuery
We'll be using both these techniques.  The first one is covered by React
itself.  React leaves us no choice but to write our JavaScript code in a
/declarative/ style.  This means that instead of telling our web browser how to
do what we want (like we do in jQuery), we just tell it what we want it to do
and the how part is explained by React.

#+CINDEX:npm
Node.js and npm cover the second technique.  There are over a hundred thousand
different Node.js applications available for us to use.  This means that most
likely someone has already implemented the functionality that our application
depends on.

#+CINDEX:@command{npm install}
#+CINDEX:@file{package.json}
#+CINDEX:metadata, project
#+CINDEX:project metadata
The question is how do we know from where to get all these Node.js applications
that we want to reuse.  We can install them via the ~npm install
<package-name>~ command.  In the npm context, a Node.js application is called a
*package*, and each *npm package* has a ~package.json~ file that describes the
metadata associated with that package.[fn::[[https://docs.npmjs.com/files/package.json][package.json docs]]]

*** Create ~package.json~
:PROPERTIES:
:CUSTOM_ID: create package.json
:END:

#+CINDEX:package initialization
#+CINDEX:initialize a package
#+CINDEX:metadata file
#+CINDEX:@file{package.json}
#+CINDEX:@command{npm install}
Before we install our /dependency packages/, we will /initialize/ a *package*
for our own project.  Normally, ~package.json~ is only required when you want
to submit your package to the npm registry so that others can reuse your
Node.js application.  We're not going to build a Node.js application, and we're
not going to submit our project to npm.  ~package.json~ is technically only a
metadata file that the ~npm~ command understands, and as such, we can use it to
store a list of dependencies that our application requires.  Once we store a
list of dependencies in ~package.json~, we can easily install them anytime with
the ~npm install~ command; npm will figure out from where to get them
automatically.

#+CINDEX:@file{package.json} create
#+CINDEX:create @file{package.json}
How do we create the ~package.json~ file for our own application?  npm comes
with an interactive tool that asks us a bunch of questions and then, based on
our answers, creates ~package.json~ for our project.

#+CINDEX:@command{npm init}
#+CINDEX:initialize @file{package.json}
<<run-npm-init>>From the ~<dir>/snapterest/~ directory, run:
: npm init
Accept all the defaults.

#+CINDEX:modular application
#+CINDEX:modules
#+CINDEX:Node.js modules
Now we are ready to install other Node.js applications that we are going to
reuse.  An application that is built of multiple individual applications is
called /modular/ whereas individual applications are called /modules/.  This is
what we will call our Node.js dependencies from now on: *Node.js modules*

*** About Reusing Node.js Modules

#+CINDEX:build development process
#+CINDEX:build script
#+CINDEX:packaging
<<building>>There will be a step in our development process called /building/.
During this step, our build script will take our source files and all our
Node.js dependency packages, and transform them into a single file that web
browsers can successfully execute.  The most important part of this building
process is called /packaging/.  But what do we need to package and why?  We're
not creating a Node.js application, but yet we're talking about reusing Node.js
modules.  Does this mean that we'll be reusing Node.js modules in a non-Node.js
application?  Is that even possible?  Yes, there is a way of doing that.

**** Installing Browserify

#+CINDEX:Browserify
#+CINDEX:bundling, Browserify
<<Browserify>>*Browserify* is a tool used for bundling all your dependency
files together in such a way that you can reuse Node.js modules in client-side
JavaScript applications.  You can learn more about it at [[http://browserify.org][Browserify]].

#+CINDEX:install Browserify
To install Browserify, run the following command from inside the
~<dir>/snapterest/~ directory:
: npm install --save-dev browserify

Browserify will allow us to use Node.js modules in our client-side JavaScript
applications.  It will be a part of our build process.

*** Building with Gulp.js

#+CINDEX:Gulp.js
<<Gulp.js>>Today, any modern client-side application represents a mix of many
concerns that are addressed individually by various technologies.  Addressing
each concern individually simplifies the overall process of managing the
project's complexity.  The downside of this approach is that at some point in
your project, you need to put together all the individual parts into one
coherent application.  Developers have something called build-tools that
assemble their projects from individual modules.  This process is called the
/build/ process and, depending on the size and complexity of your project, it
can take anywhere from milliseconds to hours to build.

{{{subheading(Installing Gulp.js and ~gulpfile.js~)}}}

The Node.js ecosystem has a great tool for automating our build process,
*Gulp.js*.  You can learn more about it at [[http://gulpjs.com][Gulp]].

#+CINDEX:install Gulp.js
#+CINDEX:Gulp.js installation
Let's install it.
: npm install --save-dev gulp
: npm install --global gulp-cli

{{{subheading(An Example ~gulpfile.js~)}}}

#+CINDEX:gulpfile
#+CINDEX:@file{gulpfile.js}
<<example-gulpfile.js>>What is a /gulpfile/?  It's a file where we describe our
build process.  Create ~gulpfile.js~ in your ~<dir>/snapterest/~ directory and
add the following content to it[fn::from
https://gulpjs.com/docs/en/getting-started/quick-start#create-a-gulpfile]:

#+NAME:example-gulpfile.js
#+CAPTION:Example of a ~gulpfile.js~
#+BEGIN_SRC js
function defaultTask(cb) {
  console.log("I am about to learn the essentials of React.js");
  cb();
}

exports.default = defaultTask;
#+END_SRC

#+CINDEX:@command{gulp} command
<<gulp-command>>Now if you run the ~gulp~ command, you will see output that
looks like this:

#+BEGIN_EXAMPLE
Using gulpfile ~/<dir>/snapterest/gulpfile.js
Starting 'default'...
I am about to learn the essentials of React.js
Finished 'default' after 62 us
#+END_EXAMPLE

*** Creating a Default Gulp Task

#+CINDEX:@samp{default} task
#+CINDEX:Gulp.js build system
#+CINDEX:Browserify
<<default-gulp-task>>By default, when you run ~gulp~, it executes a task called
=default=.  You now have a working Gulp.js build system.  Let's create a task
tht will package our source and dependency modules using Browserify.

#+CINDEX:@file{gulpfile.js}
<<default-gulpfile.js>>Replace the contents of your ~gulpfile.js~ with the
following code:

#+NAME:default-task-gulpfile.js
#+CAPTION:A default ~gulpfile.js~ that will package source and dependency modules using Browserify
#+BEGIN_SRC js
var gulp = require('gulp');
var browserify = require('browserify');
var babelify = require('babelify');
var source = require('vinyl-source-stream');

gulp.task('default', function(cb) {
    return browserify('./source/app.js')
        .transform(babelify)
        .bundle()
        .pipe(source('snapterest.js'))
        .pipe(gulp.dest('./build/'));
        cb();
});
#+END_SRC

**** Install Babelify

#+CINDEX:Babelify
#+CINDEX:install @file{babelify} module
<<install-Browserify>>We have already installed the ~browserify~ module, so now
let's install ([[*Install Babelify][install Babelify]]) the [[https://www.npmjs.com/package/babelify][~babelify~ module]][fn::See [[https://github.com/fedosejev/react-essentials/blob/master/updates.md#chapter-1-page-14][errata]]; The book uses babelify
version 6.  Version 7 introduced some [[https://github.com/fedosejev/react-essentials#i-get-syntaxerror-appjs-unexpected-token-when-i-run-gulp-command-what-should-i-do][breaking changes]];  to use Version 7, see
[[https://github.com/fedosejev/react-essentials/issues/21#issuecomment-160316774][this comment]].][[fn::The current version is now =10.0.0=.]:

: npm install --save-dev babelify@^6.2.0

#+CINDEX:JSX
The ~babelify~ module allows us to write the JSX syntax that we'll introduce in
the next chapter.

**** Install Vinyl-Source-Stream Module

#+CINDEX:Vinyl Source Stream module
#+CINDEX:Browserify and Gulp
<<install-Vinyl-Source-Stream>>Why do we need the [[https://www.npmjs.com/package/vinyl-source-stream][~vinyl-source-stream~ module]]?
It allows us to use Browserify and Gulp together.  For more details on why this
works, go to [[https://www.npmjs.com/package/vinyl-source-stream][Vinyl-Source-Stream]].  Let's install the ~vinyl-source-stream~
dependency module:

: npm install --save-dev vinyl-source-stream

**** Test Default Gulp Task

#+CINDEX:gulp default task
<<test-gulp-default-task>>Now we're ready to test our ~default~ task.  Run:

#+BEGIN_EXAMPLE
$ gulp
[19:06:03] Using gulpfile ~/Dev/Programming/WebDev/React/ReactJS-Essentials/snapterest/gulpfile.js
[19:06:03] Starting 'default'...
[19:06:03] Finished 'default' after 40 ms
#+END_EXAMPLE

#+CINDEX:@file{build} directory
#+CINDEX:@file{snapterest.js} file
The project's ~<dir>/snapterest/build/~ directory now has the ~snapterest.js~
file with some code already inside it---that's our (empty) JavaScript
application with some Node.js modules that are ready to run in a web browser.

*** Creating a Web Page
:PROPERTIES:
:CUSTOM_ID: create web page
:END:

#+CINDEX:@file{index.html} file
#+CINDEX:@file{snapterest.js} file
#+CINDEX:@file{snapterest/build} directory
<<create-index.html>>All that is left to do is to create the ~index.html~ file
with a link to our ~snapterest.js~ script.  Create the ~index.html~ file in the
~<dir>/snapterest/build/~ directory.  Add the following HTML markup to it:

#+NAME:index.html
#+CAPTION:Project Snapterest ~index.html~
#+BEGIN_SRC html :tangle snapterest/build/index.html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="x-ua-compatible" content="ie-edge, chrome=1" />
    <title>Snapterest</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
  </head>
  <body>
    <div id="react-application">
      I am about to learn the essentials of React.js.
    </div>
    <script src="./snapterest.js"></script>
  </body>
</html>
#+END_SRC

<<open-index.html>>Open ~<dir>/snapterest/build/index.html~ in a web browser.
You should see the following text: ``I am about to learn the essentials of
React.js.''

** Summary

- We learned why we should use React to build user interfaces for modern web
  applications.

- We discussed the project that we'll be building in this book.

- We installed all the right tools

- We created the project's structure.

*** Installation and Configuration Steps

- [[install-node.js][Node.js and npm]]
- [[install-git][Git]]
- [[twitter-streaming][Twitter Streaming API]]
  + [[create-twitter-account][Create a Twitter Account]]
  + [[create-twitter-app][Twitter App]]
    - [[twitter-keys][Keys]]
    - [[twitter-token][Token]]
- [[#Snapkite Engine][Snapkite Engine]]
  + [[#install Snapkite Engine][Install Snapkite Engine]]
  + [[install-node-gyp][Install =node-gyp= module and command]]
  + [[configure-Snapkite][Configure Snapkite Engine]]
    - [[config.json][~config.json~]]
    - [[trackKeywords][~trackKeywords~]]
    - [[Twitter-keys-and-token%0A][configure Twitter keys and access token]]
  + [[install-Snapkite-filters][Install Snapkite Filters]]
    - [[is-possibly-sensitive-filter][is possibly sensitive]]
    - [[has-mobile-photo-filter][has mobile photo]]
    - [[is-retweet-filter][is retweet]]
    - [[has-text-filter][has text]]
  + [[configure-Snapkite-filters][Configure Snapkite Filters]]
    - [[Snapkite-config.json][~config.json~]]
  + [[test-Snapkite-Engine][Test Snapkite Engine]]
- [[*Creating the Project Structure][Create Snapterest Project Structure]]
  - [[create-root-project-directory][create root project directory]]
    + [[source-directory][~source~ directory]]
    + [[build-directory][~build~ directory]]
    + [[application-file][~app.js~ file]]
    + [[#create package.json][~package.json~ file]]
      - [[run-npm-init][{{{command(npm init)}}}]]
- [[building][The Building Process]]
  + [[Browserify][Install Browserify]]
  + [[Gulp.js][Install Gulp.js]]
    - [[example-gulpfile.js][example ~gulpfile.js~]]
  + [[gulp-command][Run ~gulp~ command]]
    - [[default-gulp-task][default gulp task]]
    - [[default-gulpfile.js][default ~gulpfile.js~]]
  + [[install-Browserify][Install Browserify]]
  + [[install-Vinyl-Source-Stream][Install Vinyl-Source-Stream]]
  + [[test-gulp-default-task][Test Gulp Default Task]]
- [[#create web page][Create a Web Page]]
  + [[create-index.html][Create ~index.html~]]
  + [[open-index.html][Open ~index.html~]]

* 2. Create Your First React Element

Creating a simple web application today involves writing the HTML, CSS, and
JavaScript code.  The reason we use three different technologies is because we
want to separate three different concerns:

- Content (HTML)
- Styling (CSS)
- Logic (JavaScript)


#+CINDEX:Single Page Application (SPA)
#+CINDEX:SPA, Single Page Application
We don't think of a website as a collection of web pages anymore.  Instead, we
build web applications that might have only one web page, and that web page
does not represent the layout for out content---it represents a /container/ for
our web application.  Such a web application with a single web page is called a
{{{dfn(Single Page Application (SPA))}}}.

How do we represent the rest of the content in a SPA?  Surely, we need to
create an additional layout using HTML tags.  Otherwise, how does a web browser
know what to render?

These are valid questions.  Let's take a look at how it works.

  #+CINDEX:Document Object Model (DOM)
  #+CINDEX:DOM, Document Object Model
- Once you load your web page in a web browser, it creates a {{{dfn(Document
  Object Model (DOM))}}} of that web page.  A DOM represents your web page in a
  tree structure, and at this point, it reflects the structure of the layout
  that you created with only HTML tags.  This is what happens regardless of
  whether you're building a traditional web page or an SPA.  The difference
  between the two is what happens next.

- If you are building a traditional web page then you would finish creating
  your web page's layout.

  #+CINDEX:JavaScript DOM API
  #+CINDEX:DOM API, JavaScript
- On the other hand, if you are building a SPA, then you would need to start
  creating additional elements by manipulating the DOM with JavaScript.  A web
  browser provides you with the {{{dfn(JavaScript DOM API)}}} to do this.  You
  can learn more about it at:
  - [[https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model][Document Object Model]]

- However, manipulating (or mutating) the DOM with JavaScript has two issues:

     #+CINDEX:imperative programming style
     #+CINDEX:programming style, imperative
     #+CINDEX:style, imperative programming
  1. Your programming style will be /imperative/ if you decide to use the
     JavaScript DOM API directly.  This programming style leads to a code base
     that is harder to maintain.

     #+CINDEX:DOM mutations
  2. DOM mutations are slow because they cannot be optimized for speed, unlike
     other JavaScript code.

  React solves both these problems for us.

** Understanding the Virtual DOM

Why do we need to manipulate the DOM in the first place?  Because our web
applications are not static.  They have /state/ represented by the {{{dfn(user
interface (UI))}}} that a web browser renders, and that state can be changed
when an event occurs.  What kind of events are we talking about?  There are two
types of events that we're interested in:

#+ATTR_TEXINFO: :indic b
- User events :: When a user types, clicks, scrolls, resizes, and so on
- Server events :: When an application receives data or an error from the
                   server


#+CINDEX:syncing states
What happens while handling these events?  Usually, we update the data that our
application depends on, and that data represents a state of our data model.  In
turn, when a state of our data model changes, we might want to reflect this
change by updating a state of our UI.  Looks like what we want is a way of
syncing the two states: the UI state and the data model state.  We want one to
react to the changes in the other and vice versa.

#+CINDEX:two-way data binding
#+CINDEX:key-value observing (KVO)
#+CINDEX:KVO, key-value observing
#+CINDEX:Ember.js
#+CINDEX:Knockout
#+CINDEX:Backbone
#+CINDEX:iOS
#+CINDEX:Angular
#+CINDEX:dirty checking
One of the ways to sync your application's UI state with an underlying data
model's state is {{{dfn(two-way data binding)}}}.  There are different types of
two-way data binding.  One of them is {{{dfn(key-value observing (KVO))}}},
which is used in *Ember.js*, *Knockout*, *Backbone*, and *iOS*, among others.
Another one is dirty checking, which is used in *Angular*.

#+CINDEX:virtual DOM
#+CINDEX:reactive
Instead of two-way data binding, React offers a different solution called the
{{{dfn(virtual DOM)}}}.  The virtual DOM is a fast, in-memory representation of
the real DOM, and it's an abstraction that allows us to treat JavaScript and
DOM as if they were reactive.

Here is how it works:

1. Whenever the state of your data model changes, the virtual DOM and React
   will rerender your UI to a virtual DOM representation.

2. React then calculates the difference between the two virtual DOM
   representations: the previous virtual DOM representation that was computed
   before the data was changed and the current virtual DOM representation that
   was computed after the data was changed.  This difference between the two
   virtual DOM representations is what actually needs to be changed in the real
   DOM.

3. React updates only what needs to be updated in the real DOM.


The process of finding a difference between the two representations of the
virtual DOM and rerendering only the updated patches in a real DOM is fast.
Aslo, the best part is, as a React developer, that you don't need to worry
about what actually needs to be rerendered.,  React allows you to write your
code as if you were rerendering the entire DOM every time your application's
state changes.

You would like to learn more about the virtual DOM, the rationale behind it,
and how it can be compared to data binding, then watch this talk by Pete Hunt
from Facebook at https://www.youtube.com/watch?v=-DX3vJiqxm4.  See also [[https://www.youtube.com/watch?v=d7pyEDqBDeE][Tech
Talk: What is the Virtual DOM?]]

** Installing React

To start using the React library, we need to first install it.  I am going to
show you two ways of doing this: the simplest one and the one using the
{{{command(npm install)}}} command.

{{{heading(Using a <Script> Tag)}}}

The simplest way is to add the ~<script>~ tag to your
~/snapterest/build/index.html~ file.

- For the development version of React, add the following command:

  : <script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.0-beta3/react.js"></script>

- For the production version of React, add the following command:

  : script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.0-beta3/react.min.js"></script>


There is a difference between the two that we'll learn about in the later
chapters of this book.  For our project, we'll be using the development of
React.

At the time of this writing, the latest version of React library is
0.14.0-beta3.  Over time, React gets updated, so make sure you use the latest
version that is available to you, unless it introduces breaking changes that
are incompatible with the code samples provided in this book.  Visit
https://github.com/fedosejev/react-essentials to learn about any compatibility
issues between the codce samples and the latest version of React.

{{{heading(Importing React from npm)}}}

You learned about *Browserify* that allows us to import all the dependency
modules for our application using the ~require()~ function.  We'll be using
~require()~ to import the React library as well, which means that, instead of
adding a ~<script>~ tag to our ~index.html~, we'll be using the {{{command(npm
install)}}} to install React:

1. Navigate to the ~<dir>/snapterest/~ directory and run this command:

   : npm install --save react@0.14.8 react-dom@0.14.8

2. Then, open the ~<dir>/snapterest/source/app.js~ file in your text editor and
   import the React and ReactDOM libraries to the ~React~ and ~ReactDOM~
   variables, respectively:

   : var React = require('react');
   : var ReactDOM = require('react-dom');


The ~react~ package contains methods that are concerned with the key idea
behind React, that is, describing what you want to render in a declarative way.
On the other hand, the ~react-dom~ package offers methods that are responsible
for rendering to the DOM.  You can read more about why developers at Facebook,
think it's a good idea to separate the React library into two packages at
https://facebook.github.io/react/blog/2015/07/03/react-v0.14-beta-1.html#two-packages.

Now we're ready to start using the React library in our project.  Next, let's
create our first React Element.

** Creating React Elements with JavaScript

We'll start by familiarizing ourselves with a fundamental React terminology.
It will help us build a clear picture of what the React library is made of.
This terminology will most likely update over time, so keep an eye on the
official documentation at https://reactjs.org/docs/glossary.html.

Just like the DOM is a tree of nodes, React's virtual DOM is a tree of React
nodes.  One of the core types in React is called =ReactNode=.  It's a building
block for a virtual DOM, and it can be any one of these core types:

- =ReactElement=: ::

     This is the primary type in React.  It's a light, stateless, immutable,
     virtual representation of a DOM =Element=.

- =ReactText=: ::
                  This is a string or a number.  It represents textual content
                  and it's a virtual representation of a Text Node in the DOM.


=ReactElement='s and =ReactText='s are =ReactNode='s.  An array of
=ReactNode='s is called a =ReactFragment=.  You will see examples of all these
in this chapter.

** Example =ReactElement=

Let's start with an example of a =ReactElement=:

1. Add the following code to your ~<dir>/snapterest/source/app.js~ file:

   #+BEGIN_SRC js
   var reactElement = React.createElement('h1');
   ReactDOM.render(reactElement, document.getElementById('react-application'));
   #+END_SRC

2. Now your ~app.js~ file should look exactly like this:

   #+BEGIN_SRC js
   var React = require('react');
   var ReactDOM = require('react-dom');

   var reactElement = React.createElement('h1');
   ReactDOM.render(reactElement, document.getElementById('react-application'));
   #+END_SRC

3. Navigate to the ~<dir>/snapterest/~ directory and run Gulp's =default= task:

   #+BEGIN_EXAMPLE
   $ gulp
   [20:28:44] Using gulpfile <dir>/snapterest/gulpfile.js
   [20:28:44] Starting 'default'...
   [20:28:45] Finished 'default' after 988 ms
   #+END_EXAMPLE

4. Navigate to the ~<dir>/build/~ directory, and open ~index.html~ in a web
   browser.  You will see a blank web page.  Open *Developer Tools* in your web
   browser and inspect the HTML markup for your blank web page.  You should see
   this line among others:
   : <h1 data-reactid=".0"></h1>

   #+BEGIN_SRC html
   <html lang="en">
     <head>
       <meta charset="utf-8">
       <meta http-equiv="x-ua-compatible" content="ie-edge, chrome=1">
       <title>Snapterest</title>
       <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
     </head>
     <body>
        <div id="react-application">
          <h1 data-reactid=".0"></h1>
        </div>
        <script src="./snapterest.js"></script>
      </body>
    </html>
    #+END_SRC


We've just created your first React element.

** The Three Parameters of ~React.createElement()~

#+CINDEX:React object
#+CINDEX:@code{React.createElement()} method
#+CINDEX:parameters to @code{React.createElement()}
#+CINDEX:@code{type} parameter
#+CINDEX:@code{props} parameter
#+CINDEX:@code{children} parameter
The entry point to the React library is the =React= object.  This object has a
method called ~createElement()~ that takes three parameters:

1. =type=
2. =props=
3. =children=
: React.createElement(type, props, children);

Let's take a look at each parameter in more detail.

#+CINDEX:type parameter
*** The =type= Parameter
:PROPERTIES:
:CUSTOM_ID: createElement type parameter
:END:

The =type= parameter can be either a string or a ~ReactClass~:

- A string could be an HTML tag name such as `div', `p', `h1', and so on.
  React supports all the common HTML tags and attributes.  For a complete list
  of HTML tags and attributes supported by React, refer to:
  - [[https://reactjs.org/docs/dom-elements.html][DOM Elements]]

- A ~ReactClass~ is created via the ~React.createClass()~ method.  This will be
  introduced in more detail in [[#Chapter 3][Chapter 3]].


The =type= parameter describes how an HTML tag or a ~ReactClass~ is going to be
rendered.  In our example, we're rendering the ~h1~ HTML tag.

#+CINDEX:@code{props} parameter
*** The =props= Parameter
:PROPERTIES:
:CUSTOM_ID: props parameter
:END:

The =props= parameter is a JavaScript object passed from a parent element to a
child element (and not the other way around) with some properties that are
considered immutable, that is, those that should not be changed.

#+CINDEX:HTML attributes as @code{props}
While creating DOM elements with React, we can pass the =props= object with
properties that represent HTML attributes such as =class=, =style=, and so on.
For example, run the following commands:

#+BEGIN_SRC js
var React = require ('react');
var ReactDOM = require('react-dom');
var reactElement = React.createElement('h1', { className: 'header' });
ReactDOM.render(reactElement, document.getElementById('react-application');
#+END_SRC

The preceding code will create an ~h1~ HTML element with a =class= attribute
set to =header=:
: <h1 class="header" data-reactid=".0"></h1>

#+CINDEX:@code{className} attribute
Notice that we name our property =className= rather than =class=.  The reason
is that the =class= keyword is reserved in JavaScript.  If you use =class= as a
property name, it will be ignored by React, and a helpful warning message will
be printed on the web browser's console.:
: Warning: Unknown DOM property class.  Did you mean className?
: Use className instead.

#+CINDEX:@code{data-reactid=".0"} attribute
What is this =data-reactid=".0" attribute doing in the ~h1~ tag?  It is added
and used by React to track the DOM nodes; it might be removed in a future
version of React.[fn::It has been.]

#+CINDEX:@code{children} parameter
*** The =children= Parameter

#+CINDEX:child elements
#+CINDEX:@code{ReactNode}
The =children= parameter describes what child elements this element should
have, if any.  A child element can be any type of ~ReactNode~: a virtual DOM
element represented by a ~ReactElement~, a string or a number represented by
~ReactText~, or an array of other ~ReactNode~'s which is also called a
~ReactFragment~.

Here is an example:

#+BEGIN_SRC js :tangle snapterest/source/app.js
var React = require('react');
var ReactDOM = require('react-dom');
var reactElement = React.createElement('h1', { className: 'header' }, 'This is React.');
ReactDOM.render(reactElement, document.getElementById('react-application'));
#+END_SRC

#+NAME:ch2-ReactElement-children-param
#+CAPTION:Example of ~children~ Parameter with a ~ReactText~ Element
[[file:img/ch2-ReactElement-children-param-50.png]]

This code will create an ~h1~ HTML element with a =class= attribute and a text
node, {{{samp(This is React.)}}}:
: <h1 class="header" data-reactid=".0">This is React.</h1>

The ~h1~ tag is represented by a ~ReactElement~, while the {{{samp(This is
React.)}}} string is represented by a ~ReactText~.

*** The =children= Parameter with Multiple React Elements as Children

Next, create a React element with a number of other React elements as it's
children:

#+BEGIN_SRC js :tangle snapterest/source/app.js
var React = require('react');
var ReactDOM = require('react-dom');

var h1 = React.createElement('h1', { className: 'header', key: 'header' }, 'This is React.');
var p = React.createElement('p', { className: 'content', key: 'content' }, "And that's how it works.");
var reactFragment = [h1, p];
var section = React.createElement('section', { className: 'container' }, reactFragment);

ReactDOM.render(section, document.getElementById('react-application'));
#+END_SRC

#+NAME:ch2-ReactElement-children-param-section
#+CAPTION:The ~children~ Parameter with an Array of ReactElements
[[file:img/ch2-ReactElement-children-param-section-50.png]]

We've created three React elements: ~h1~, ~p~, and ~section~.  ~h1~ and ~p~
both have child text nodes, {{{samp(This is React.)}}} and {{{samp(And that's
how it works.)}}}, respectively.  The ~section~ has a child that is an array of
two ~ReactElement~'s, ~h1~ and ~p~, called ~reactFragment~.  This is also an
array of ~ReactNode~'s.  Each ~ReactElement~ in the ~reactFragment~ array must
have a =key= property that helps React to identify that ~ReactElement~.  As a
result, we get the following HTML markup:

#+BEGIN_SRC html
<section class="container" data-reactid=".0">
  <h1 class="header" data-reactid=".0.$header">This is React.</h1>
  <p class="content" data-reactid=".0.$content">And that's how it works.</p>
</section>
#+END_SRC

*** React's Factory Function ~React.CreateFactory()~

#+CINDEX:factory function
#+CINDEX:@code{React.createFactory()} method
Now we understand how to create React elements.  What if we wanted to create a
number of React elements of the same type?  Does it mean that we need to call
~React.createElement('type') over and over again for each element of the same
type?  We can, but we don't need to because React provides us with a factory
function called ~React.createFactory()~.  A {{{dfn(factory function)}}} is a
function that creates other functions.  This is exactly what
~React.createFactory('type')~ does: it creates a function that produces a
~ReactElement~ of a given type.

Consider the following example:

#+BEGIN_SRC js :tangle snapterest/source/app.js
var React = require('react');
var ReactDOM = require('react-dom');

var listItemElement1 = React.createElement('li', { className: 'item-1', key: 'item-1' }, 'Item 1');
var listItemElement2 = React.createElement('li', { className: 'item-2', key: 'item-2' }, 'Item 2');
var listItemElement3 = React.createElement('li', { className: 'item-3', key: 'item-3' }, 'Item 3');

var reactFragment = [ listItemElement1, listItemElement2, listItemElement3 ];
var listOfItems = React.createElement('u1', { className: 'list-of-items' }, reactFragment);

ReactDOM.render(listOfItems, document.getElementById('react-application'));
#+END_SRC

The preceeding example produces this HTML:

#+BEGIN_SRC html
<ul class="list-of-items" data-reactid=".0">
  <li class="item-1" data-reactid=".0.$item-1">Item 1</li>
  <li class="item-2" data-reactid=".0.$item-2">Item 1</li>
  <li class="item-3" data-reactid=".0.$item-3">Item 1</li>
</ul>
#+END_SRC

#+CINDEX:factory function
We can simplify it by first creating a factory function:

#+BEGIN_SRC js :tangle snapterest/source/app.js
var React = require('react');
var ReactDOM = require('react-dom');

var createListItemElement = React.createFactory('li');

var listItemElement1 = createListItemElement({ className: 'item-1', key: 'item-1' }, 'Item 1');
var listItemElement2 = createListItemElement({ className: 'item-2', key: 'item-2' }, 'Item 2');
var listItemElement3 = createListItemElement({ className: 'item-3', key: 'item-3' }, 'Item 3');

var reactFragment = [ listItemElement1, listItemElement2, listItemElement3 ];
var listOfItems = React.createElement('ul', { className: 'list-of-items' }, reactFragment);

ReactDOM.render(listOfItems, document.getElementById('react-application'));
#+END_SRC

#+NAME:ch2-ReactElement-children-factory-function
#+CAPTION:Creating Children with a Factory Function
[[file:img/ch2-ReactElement-children-factory-function-50.png]]

#+CINDEX:@code{React.createFactory()} method
In the preceding example, we're first called the ~React.createFactory()~
function and passing a ~li~ tag name as a =type= parameter.  Then, the
~React.createFactory()~ function returns a new function that we can use as a
convenient shorthand to create elements of type ~li~.  We store a reference to
this function in a variable called ~createListItemElement~.  Then we call this
function three times, and each time we only pass the =props= and =childre=
parameters, which are unique for each element.  Notice that
~React.createElement()~ and ~React.createFactory()~ both expect the HTML tag
name string (such as ~li~) or the ~ReactClass~ object as a type parameter.

*** React's Built-in Factory Functions

#+CINDEX:factory functions, built-in to React
#+CINDEX:@code{React.DOM.#} methods
React provides a number of built-in factory functions to create the common HTML
tags.  You can call them from the ~React.DOM~ object; for example:
- ~React.DOM.ul()~
- ~React.DOM.li()~
- ~React.DOM.div()~


and so on.  Using them, we can simplify our previous example even further:

#+NAME:built-in-factory-function-app.js
#+CAPTION:Creating a DOM Structure Using Built-in Factory Functions
#+BEGIN_SRC js :tangle snapterest/source/app.js
var React = require('react');
var ReactDOM = require('react-dom');

var listItemElement1 = React.DOM.li({ className: 'itemDOM-1', key: 'item-1' }, 'Item 1');
var listItemElement2 = React.DOM.li({ className: 'itemDOM-2', key: 'item-2' }, 'Item 2');
var listItemElement3 = React.DOM.li({ className: 'itemDOM-3', key: 'item-3' }, 'Item 3');

var reactFragment = [ listItemElement1, listItemElement2, listItemElement3 ];
var listOfItems = React.DOM.ul({ className: 'list-of-items' }, reactFragment);

ReactDOM.render(listOfItems, document.getElementById('react-application'));
#+END_SRC

#+CINDEX:tree of @code{ReactNode}s
Now we know how to create a tree of ~ReactNode~'s.  However, there is one
important line of code that we need to discuss before we can progress further:

: ReactDOM.render(listOfItems, document.getElementById('react-application'));

It renders our ~ReactNode~ tree to the DOM.  Let's take a closer look at how it
works.

** Rendering React Elements

{{{subheading(Parameters to ~ReactDOM.render()~)}}}

#+CINDEX:@code{ReactDOM.render()} method, parameters
The ~ReactDOM.render()~ method takes three parameters:

   #+CINDEX:@code{ReactElement}
1. ~ReactElement : A root element in the tree of ~ReactNodes~ that you have
   created
   #+CINDEX:@code{DOMElement}
2. ~DOMElement~ : A container DOM node for that tree.
   #+CINDEX:callback function
3. callback function : A function executed after the tree is rendered or
   updated.


: ReactDOM.render(ReactElement, DOMElement, callback);

#+CINDEX:@code{ReactElement}
It is important to note that if this ~ReactElement~ was previously rendered to
a parent DOM ~Element~, then ~ReactDOM.render()~ will perform an /update/ on
the already rendered DOM tree and only /mutate/ the DOM as it is necessary to
reflect the latest version of the ~ReactElement~.  This is why a virtual DOM
requires fewer DOM mutations.

{{{heading(Creating Static Web Content on a Server)}}}

#+CINDEX:initial page load
Can you think of a case when rendering a user interface on a client would be
slow?  The initial page load.  The problem with the initial page load is the
one mentioned at the beginning of this chapter---we're not creating static web
pages anymore.  Instead, when a web browser loads our web application, it
receives only the bare minimum HTML markup that is usually used as a container
or a parent element for our web application.  Then, our JavaScript code creates
the rest of the DOM, but in order for it to do so it often needs to request
extra data from the server.  However, getting this data takes time.  Once this
data is received, our JavaScript code starts to mutate the DOM.  We know that
DOM mutations are slow.  How can we solve this problem?

#+CINDEX:static web pages
#+CINDEX:mutate DOM in a server
The solution is instead of mutating the DOM in a web browser, we mutate it on a
server, just like we would with our static web pages.  A web browser will then
receive an HTML that fully represents a user interface of our web application
at the time of the initial page load.  But we can't mutate the DOM on a server
because it doesn't exist outside a web browser.

#+CINDEX:virtual DOM on a server
#+CINDEX:@code{ReactNode} tree
We have a virtual DOM that is just a JavaScript, and as you know using Node.js,
we can run JavaScript on a server.  So technically, we can use the React
library on a server, and we can create our ~ReactNode~ tree on a server.  The
question is how can we render it to a string that we can send to a client?

{{{subheading(ReactDOMServer.renderToString())}}} Method

#+CINDEX:@code{ReactDOMServer.renderToString()} method
React has a method called ~ReactDOMServer.renderToString()~ for just this
purpose.

: var ReactDOMServer = require('react-dom/server');
: ReactDOMServer.renderToString(ReactElement);

It takes a ~ReactElement~ as a parameter and renders it to its initial HTML.
Not only is this faster than mutating a DOM on a client, but it also improves
the *Search Engine Optimization (SEO)* of your web application.

{{{subheading(ReactDOMServer.renderToStaticMarkup())}}} Method
<<renderToStaticMarkup>>

#+CINDEX:@code{ReactDOMServer.renderToStaticMarkup()} method
React can also generate static web pages:

: var ReactDOMServer = require('react-dom/server');
: ReactDOMServer.renderToStaticMarkup(ReactElement);

Similar to ~ReactDOMServer.renderToString()~, this method also takes a
~ReactElement~ as a parameter and outputs an HTML string.  However, it doesn't
create the extra DOM attributes that React uses internally; rather, it produces
shorter HTML strings that we can transfer to the wire quickly.

Now you know not only how to create a virtual DOM tree using React Elements,
but you also know how to render it to a client and server.  Our next question
is whether we can do it quickly and in a more visual manner.

** Creating React Elements With JSX

When we build our virtual DOM by constantly calling the ~React.createElement()~
method, it becomes quite hard to visually translate these multiple function
calls into a hierarchy of HTML tags.  Don't forget that, even though we're
working with a virtual DOM, we're still creating a structure layout for our
content and user interface.  Wouldn't it be great to be able to visualize that
layout easily by simply looking at our React code?

#+CINDEX:JSX
{{{dfn(JSX)}}} is an optional HTML-like syntax that allows us to create a
virtual DOM tree without using the ~React.creatElement()~ method.

Let's [[built-in-factory-function-app.js]], which was created without using JSX.

Translate this to one using JSX:

#+NAME:jsx-app.js
#+CAPTION:Coding With JSX
#+BEGIN_SRC js :tangle snapterest/source/app.js
var React = require('react');
var ReactDOM = require('react-dom');

var listOfItems =
<ul className="list-of-items">
    <li className="jsx-item-1">Item 1</li>
    <li className="jsx-item-2">Item 2</li>
    <li className="jsx-item-3">Item 3</li>
</ul>;

ReactDOM.render(listOfItems, document.getElementById('react-application'));
#+END_SRC

JSX allows us to write HTML-like syntax in our JavaScript code.  More
importantly, we can now clearly see what our HTML layout will look like once
its rendered.  JSX is a convenience tool and it comes with a price in the form
of an additional transformation step.  Transformation of the JSX syntax into
valid JavaScript syntax must happen before our ``invalid'' JavaScript code is
interpreted.

#+CINDEX:@file{babelify} module
#+CINDEX:gulp default task
#+CINDEX:@file{gulpfile.js}
#+CINDEX:@command{.transform(babelify)} function call
In the previous chapter, we installed the ~babelify~ module that transforms our
JSX syntax into a JavaScript one.  This transformation happens every time we
run our =default= task from the {{{file(gulpfile.js)}}}
([[default-task-gulpfile.js]]).  The ~.transform(babelify)~ function call
transforms JSX into JavaScript before bundling it with the other JavaScript
code.

To test our transformation, run this command:
: $ gulp

Then navigate to the ~<dir>/snapterest/build/~ directory, and open ~index.html~
in a web browser.  You will see a list of three items.

#+NAME:children-using-jsx
#+CAPTION:Creating a List of Items Using JSX
[[file:img/ch2-ReactElement-children-jsx-50.png]]

{{{heading(Online JSX Compiler)}}}

The React team has built an online JSX Compiler that you can use to test your
understanding of how JSX works.[fn::This tool has been removed as
JSXTransformer has been deprecated.]

** Summary

We started this chapter by discussing the issues with single web page
applications and how they can be addressed.  Then, we learned what a virtual
DOM is and how React allows us to build it.  We also installed React and
created our first React element using only JavaScript.  Then we also learned
how to render React elements in a web browser and on a server.  Finally, we
looked at a simpler way of creating React elements with JSX.

In the next chapter we'll dive deeper into the world of React components.

* 3. Create Your First React Component
:PROPERTIES:
:CUSTOM_ID: Chapter 3
:END:


In the previous chapter, we learned how to create /React elements/ and how to
use them to render HTML markup.  We learned how easy it is to produce React
elements using /JSX/.  At this point, you know enough about React in order to
create the static web pages that we discussed in Chapter 2.  You want to build
interactive user interfaces that react to user and server events.  What does it
mean to react to an event?  How can a static HTML element /react/?   How can a
React element react?  In this chapter we'll answer these questions and many
other questions while introducing ourselves to /React components/.

** Stateless Versus Stateful

#+CINDEX:react
#+CINDEX:state, switch
#+CINDEX:virtual DOM elements
#+CINDEX:benefit of React library, easy to reason about
To {{{dfn(react)}}} means to switch from one state to another.  This means that
you need to have a state in the first place and the ability to change state.
Have we mentioned a state or the ability to change that state in React
elements?  No.  They are stateless.  Their sole purpose is to construct and
render virtual DOM elements.  In fact, we want them to render in the exact same
way, given that we provide them the exact same set of parameters.  We want them
to be consistent because it makes it easy for us to reason about them.  That's
one of the key benefits of using the React library---the ease of reasoning how
our web application works.

#+CINDEX:React Component
#+CINDEX:Component
#+CINDEX:state machine, component
How can we add a state to our stateless React elements?  If we can't
encapsulate a state in React elementsm, then *we should encapsulate React
elements in something that already has a state.*  Think of a simple state
machine that represents a user interface.  Every user action triggers a change
of a state in that state machine.  Every state is represented by a different
React element.  In the React library, this state machine is called a
{{{dfn(React Component)}}}.

** Creating Your First Stateless React Component

#+CINDEX:component, create
#+CINDEX:@code{React.createClass()} method
Let's take a look at the following example of how to create a React
/component/ (using the ~React.createClass()~ method):

#+NAME:stateless-component
#+CAPTION:A First Stateless React Component
#+BEGIN_SRC js
var React = require('react');
var ReactDOM = require('react-dom');

var ReactClass = React.createClass({			(ref:1 class)
    render: function () {
        return React.createElement('h1',
                                   { className: 'header' },
                                   'React Component');
    }
});

var reactComponentElement = React.createElement(ReactClass); (ref:2 element)
var reactComponent = ReactDOM.render(reactComponentElement,	 (ref:3 component)
                                     document.getElementById('react-application'));
#+END_SRC

The new portions of this code can be broken down into three steps:

1. Creating a React class. [[(1 class)]]
2. Creating a React component element (using the class). [[(2 element)]]
3. Creating a React component (using the element). [[(3 component)]]

{{{heading(How to Create a React Component)}}}

#+CINDEX:React component, create
Let's take a closer look at how to create a React component.

   #+CINDEX:@code{React.createClass()} function
   #+CINDEX:@code{ReactClass}
   #+CINDEX:specification object
1. Create a ~ReactClass~ by calling the ~React.createClass()~ method and
   providing a /specification object/ as its parameter.  In this chapter we'll
   focus on learning about the specification objects in more detail.

   #+CINDEX:@code{ReactComponentElement}
   #+CINDEX:@code{React.createElement()} method
   #+CINDEX:~ReactClass~ as @samp{type} parameterx
2. Create a ~ReactComponentElement~ by calling the ~React.createElement()~
   method and providing our ~ReactClass~ as its =type= parameter.  In Chapter
   2, we learned that the =type= parameter can be either a string or a
   ~ReactClass~ ([[#createElement type parameter][The ~type~ Parameter]]).  In this chapter, you'll learn more
   about the latter.

   #+CINDEX:@code{ReactComponent}
   #+CINDEX:@code{ReactDOM.render()} method
3. Create a ~ReactComponent~ by calling the ~ReactDOM.render()~ method and
   providing our ~ReactComponentElement~ as its =element= parameter.

*** The Specification Object

#+CINDEX:specification object
#+CINDEX:look and feel
The {{{dfn(specification object)}}} that you pass as a parameter to
~React.createClass()~ is where your component's ``look and feel'' is defined.
*Specification* is the definition of your React component.  From now on, in
this chapter, we'll refer to a /specification object/ as a React component, and
in the rest of the chapter we will learn about this very important concept.

#+CINDEX:state, specification object
#+CINDEX:rendered, component by specification object
#+CINDEX:@code{render()} method
The /specification object/:

1) encapsulates a component's /state/ and
2) describes how a component is /rendered/.

At the very minimum, the React component needs to have a ~render()~ method that
returns at least =null= or =false=.

Here is an example of a specification object in its simplest form:

#+NAME:simplest-specification-object
#+CAPTIONS:An Example of the Simplest Specification Object
#+BEGIN_SRC js
{
    render: function () {
        return null;
    }
}
#+END_SRC

    #+CINDEX:@code{render()} method
The ~render()~ method is responsible for telling React how to render your
React component.  It can return =null=, and nothing will be rendered.  Or it
can return a ~ReactElement~ that we learned how to create in Chapter 2.

#+NAME:simple-specification-object
#+CAPTION:A Simple Specification Object Returning a ~ReactElement~
#+BEGIN_SRC js
{
    render: function () {
        return React.createElement('h1',
                                   { className: 'header' },
                                   'React Component');
    }
}
#+END_SRC

This example shows how we can encapsulate our React element inside our React
component.  We create a ~ReactElement~ of type =h1= with a =properties= object
and a ~ReactText~ as its only child.  Then, we return it when the ~render()~
method of our React component is called.  The fact that we encapsulated our
React element inside a React component doesn't affect how it will be rendered.

: <h1 class="header" data-reactid=".0">React Component</h1>

The produced HTML markup is identical to the one we created in Chapter 2
without using the React component.  In this case, you might be wondering what's
the benefit of having a ~render()~ method if we can render the exact same
markup without it?  The advantage of having a ~render()~ method is that, as
with any other function, before it returns a value, it can choose what value to
return.

*** Adding State and Conditional to a Component

So far, you've seen two examples of the ~render()~ method: one that returns
=null= and one that returns a React element.  We can merge the two and add a
condition that decides what to render:

#+NAME:simple-component-with-state
#+CAPTION:A Simple Specification Object with State and a Conditional
#+BEGIN_SRC js
{
    render: function () {
        var elementState = {
            isHidden: true
        };
        if (elementState.isHidden) {
            return null;
        }
        return React.createElement('h1',
                                   { className: 'header' },
                                   'React Component');
    }
}
#+END_SRC

#+CINDEX:state object
In this example, we created  the ~elementState~ variable that references an
object with a single ~isHidden~ property.  This object acts as a state for our
React element.  If we want to hide our React element, then we need to set the
value of ~elementState.isHidden~ to =true=, and our ~render()~ method will
return =null=.  In this case, React will render nothing.  Logically, by setting
~elementState.isHidden~ to =false=, will return our React element and the
expected HTML markup will be rendered.  The question you might ask is: how do
we set the value of ~elementState.isHidden~ to =false=?  Of to =true=?  Or how
do we change it in general?

Let's think of scenarios in which we might want to change that state.  One of
them is when a user interacts with our user interface.  Another one is when a
server sends data.  Or when a certain amount of time passes and then we want to
render something else.  Our ~render()~ method is not aware of all these events
and it shouldn't be because its sole purpose is to return a React element based
on the data that we pass to it.  How do we pass data to it?

*** Passing Data to a Component

    #+CINDEX:data, passing to a component
There are two ways to pass data to a ~render()~ method using the React API:

       #+CINDEX:@code{this.props}
1. Using the =properties= object: ~this.props~
       #+CINDEX:@code{this.state}
2. Using the =state= object: ~this.state~

{{{subheading(The ~props~ Parameter)}}}

#+CINDEX:@samp{props} parameter
#+CINDEX:attributes to HTML elements
We learned that the ~React.createElement()~ method accepts the =props=
parameter ([[#props parameter][The =props= Parameter]]).  We used it to pass attributes to our HTML
elements, but we didn't discuss what happens behind the scenes and why
attributes passed to the =props= object get rendered.

#+CINDEX:@code{this.props}
#+CINDEX:data with @samp{props} parameter
    #+CINDEX:accessing data in a component, @code{this.props}
Any data that you put in the =props= object and pass to the
~React.createElement()~ method can be accessed inside the ~render()~ method of
~ReactComponent~ via the ~this.props~ reference.  Once you have accessed data
from ~this.props~, you can render it:

#+NAME:component-using-props
#+CAPTION:Passing Props to a Component
#+BEGIN_SRC js
{
    render: function () {
        var elementState = {
            isHidden: true
        };
        if (elementState.isHidden) {
            return null;
        }
        return React.createElement('h1',
                                   { className: 'header' },
                                   this.props.header);		(ref:props)
    }
}
#+END_SRC

In this example, we're using ~this.props~ insider our ~render()~ method
([[(props)]]) to access the =header= property.  We're then passing
~this.props.header~ directly to the ~React.createElement()~ method as a child
string element.

In the preceding example, we can pass the value of ~isHidden~ as another
property of the ~this.props~ object (see [[(props-isHidden)]] (instead of
hard-coding ~isHidden~):

#+NAME:passing-props-to-component
#+CAPTION:Example of Passing ~props~ to the ~render()~ Method
#+BEGIN_SRC js
{
    render: function () {
        if (this.props.isHidden) {			(ref:props-isHidden)
            return null;
        }
        return React.createElement('h1',
                                   { className: 'header' },
                                   this.props.header);
    }
}
#+END_SRC

We can also use ~this.props~ to compute data that needs to be rendered (see
[[(props-to-render)]]):

#+NAME:use-props-to-compute
#+CAPTION:Example of Using ~props~ to Compute a Value
#+BEGIN_SRC js
{
    render: function () {
        if (this.props.isHidden) {
            return null;
        }
        var header = this.props.tweets.length + ' Latest Tweets'; (ref:props-to-render)
        return React.createElement('h1',
                                   { className: 'header' },
                                   this.props.header);
    }
}
#+END_SRC

We are accessing an array of tweets via ~this.props.tweets~ and getting its
~length~ property.  Then, we're concatenating a string ' Latest Tweets' to it.
The resulting string is stored in a ~header~ variable, and this is our computed
child string element that we're passing to the ~React.createElement()~ method.

{{{subheading(Pure Functions)}}}

#+CINDEX:pure function
Notice that in our previous example, instead of storing ~isHidden~ in a
~render()~ method, we're passing it via ~this.props~.  We removed our
~elementState~ object from it because we don't need to worry about the state in
our ~render()~ method.  It's a {{{dfn(pure function)}}}, which means that it
shouldn't mutate the state or access the real DOM, or otherwise interact with a
web browser.  Remember that we might want to use React on a server, where we
have no web browser, and we should expect the ~render()~ method to produce the
same result regardless of the environment.

*** Managing State

    #+CINDEX:manage state
    #+CINDEX:state management
If our ~render()~ method doesn't manage the state, then how do we manage it?
How do we set the state, and how do we update it while handling user or browser
events in React?

#+CINDEX:types of React components
#+CINDEX:components, types
Earlier in this chapter, we learned that in React we can represent a user
interface with React components.  There are two types of React components:

1. With state
2. Without state


#+CINDEX:stateless React components
Hold on, didn't we say that React components are state machines?  Surely, every
state machine needs to have a state.  You're correct; however, it's a good
practice to keep as many React components stateless as possible.

{{{subheading(Composable Elements and Separation of Concerns)}}}

React components are /composable/.  As a result, we can have a hierarchy of
React components.  Imagine that we have a parent React component that has two
child components, and each of them in turn has another two child components.
All the components are stateful and they can manage their own state.

#+CINDEX:separation of concerns
#+CINDEX:user interface
#+CINDEX:render data
How easy will it be to figure out what the last child component in the
hierarchy will render if the top component in the hierarchy updates its state?
Not easy.  There is a design pattern that removes this unnecessary complexity.
The idea is to separate your components into two concerns:

- how to handle the user interface interaction logic and
- how to render data.


- The minority of your React components are stateful.  They should be at the
  top of your component's hierarchy.  They encapsulate all of the interaction
  logic, manage the user interface state, and pass that state down the
  hierarchy to stateless components, using ~props~.

- The majority of your React components are stateless.  They receive data via
  ~this.props~ and then render that data.  The component is stateless.


In our previous example, we received ~isHidden~ state data vie ~this.props~ and
then we rendered that data.  Our component was stateless.

Next, let's create our first stateful component.

** Creating Your First Stateful Component

#+CINDEX:stateful components
#+CINDEX:interaction logic
#+CINDEX:manage state
Stateful components arre the most appropriate place for you application to
handle the interaction logic and manage the state.  They make it easier for you
to reason out how your application works.  This reasoning plays a key role in
buidling maintainable web applications.

{{{subheading(Setting Initial State with ~getInitialState()~)}}}

#+CINDEX:@code{this.state} property
#+CINDEX:@code{getInitialState()} method
React stores the component's state in ~this.state~, and it sets the initial
value of ~this.state~ to the value returned by the ~getInitialState()~ method.
However, it's up to us to tell React what the ~getInitialState()~ method will
return.  Let's add this method to our React component:

#+NAME:component-getInitialState
#+CAPTION:Simple Component Using ~getInitialState()~ Method
#+BEGIN_SRC js
{
    getInitialState: function () {
        return {
            isHidden: false
        }
    },

    render: function () {
        if (this.state.isHidden) {
            return null;
        }
        return React.createElement('h1',
                                   { className: 'header' },
                                   'React Component');
    }
}
#+END_SRC

In this example, our ~getInitialState()~ method returns an object with a single
~isHidden~ property that is set to false.  This is the initial state of our
React component and our user interface.  Notice that in our ~render()~ method
we're now referring to ~this.state.isHidden~ instead of ~this.props.isHidden~.

{{{subheading(Difference Between ~this.props~ and ~this.state~)}}}

#+CINDEX:props vs. state, difference
#+CINDEX:state vs. props, difference
Earlier in this chapter, you learned that we can pass data to the component's
~render()~ method via ~this.props~.  So, what's the difference between the two?

- ~this.props~ stores /read-only/ data that is passed from the parent.  It
  belongs to the parent and cannot be changed by its children.  This data
  should be considered /immutable/.

- ~this.state~ stores data that is private to the component.  It can be changed
  by the component.  The component will rerender itself when the state is
  updated.


{{{subheading(Setting State with ~setState()~)}}}

#+CINDEX:@code{setState()} method
How do we update a component's state?  There is a common way of informing React
of a state change using ~setState(DATA, CALLBACK)~.  This method takes two
parameters:

  #+CINDEX:@code{data} object to @code{setState()}
- The ~data~ object that represents the next state

  #+CINDEX:@code{callback} function to @code{setState()}
- The ~callback~ function, which you will rarely need to use because React
  keeps your user interface up-to-date for you.


*** Keeping the Interface Up-To-Date

How does React keep your user interface up-to-date?  It calls the component's
~render()~ method every time you update the component's state, including any
child components which are rendered as well.  In fact, it rerenders the entire
virtual DOM every time our ~render()~ method is called.

#+CINDEX:merge state
When you call the ~this.setState()~ method and pass it a data object that
represents the next state, React will merge that next state with the current
state.  During the merge, React will overwrite the current state with the next
state.  The current state that is not overwritten by the next state will become
part of the next state.

Image that this is our current state:

#+BEGIN_SRC js
{
    isHidden: true,
    title: 'Stateful React Component'
}
#+END_SRC

We call ~this.setState(nextState)~, where ~nextState~ is as follows:

#+BEGIN_SRC js
{
    isHidden: false
}
#+END_SRC

React will merge the two states into a new one:

#+BEGIN_SRC js
{
    isHidden: false,
    title: 'Stateful React Component'
}
#+END_SRC

The ~isHidden~ property is updated and the ~title~ property is not deleted or
updated in any way.

*** Creating a Component That Reacts to User Events

#+CINDEX:stateful component
#+CINDEX:react to user event
#+CINDEX:user event, reacting to
Now that we know how to update our component's state, let's create a stateful
component that reacts to a user event:

#+NAME:component-reacts-to-user-event
#+CAPTION:A stateful component that reacts to a user event
#+BEGIN_SRC js
{
    getInitialState: function () {
        return {
            isHeaderHidden: false,
            title: 'Stateful React Component'
        }
    },

    handleClick: function () {
        this.setState({
            isHeaderHidden: !this.state.isHeaderHidden		(ref:setState)
        });
    },

    render: function () {
        var headerElement = React.createElement('h1',
                                                { className: 'header', key: 'header' },
                                                this.state.title);
        var buttonElement = React.createElement('button',	(ref:createElement)
                                                { className: 'btn btn-default',
                                                  onClick: this.handleClick,		(ref:onClick)
                                                  key: 'button'},
                                                'Toggle header');
        if (this.state.isHeaderHidden) {
            return React.createElement('div', null, [ buttonElement ]);
        }
        return React.createElement('div', null, [ buttonElement, headerElement ]);
    }
}
#+END_SRC

In this example, we're creating a toggle button that shows and hides a header.
The first thing we do is set our initial state object by returning it from the
~getInitialState()~ method.  Our initial state has two properties:
~isHeaderHidden~ that is set to =false= and ~title~ that is set to =Stateful
React Component=.  Now we can access this state object in our ~render()~ method
via ~this.state~.  Inside our ~render()~ method, we create three React
elements: =hi=, =button=, and =div=.  Our =div= element acts as a parent
element for our =h1= and =button= elements.  However, in one case we create our
=div= element with two children, ~headerElement~ and ~buttonElement~, and in
another case we create it with only one child, ~buttonElement~.  The case we
choose depends on the value of ~this.state.isHeaderHidden~.  The current state
of our component directly affects what the ~render()~ method will render.
While this should look familiar to you, there is something new in this example
that we haven't seen before.

{{{subheading(Handling Events with Custom Component Properties)}}}

#+CINDEX:@code{handleClick()} method
#+CINDEX:@code{onClick} events
#+CINDEX:properties on component
Notice that we introduced a new property on our ~ReactComponent~ object, called
~handleClick()~, which is a method that has no special meaning to React.  It's
part of our application logic, and we use it to handle the ~onClick~ events.
You can add your own properties to the ~ReactComponent~ object.  All of these
will be available via a ~this~ reference, which you can access from any other
method that itself is a property of the component object.  For example, we
are accessing a state object via ~this.state~ in both the ~render()~ and
~handleClick()~ methods.

What does our ~handleClick()~ method do?  It updates our component's state by
setting the new value of this ~isHeaderHidden~ property to the opposite of the
existing one that it accesses via ~this.state.isHeaderHidden~ (see [[(setState)]]).

{{{subheading(Event Handlers in the =props= Parameter)}}}

#+CINDEX:event handler
#+CINDEX:attach event handler
Our ~handleClick()~ method reacts to a user interaction with our user
interface.  Our user interface is a =button= element that a user can click on,
and we can attach an event handler to.  In React, you can attach event handlers
to a React element by passing them to the ~props~ parameter in the
~createElement()~ method (see [[(onClick)]]).

#+CINDEX:CamelCase
#+CINDEX:events, list of supported
React uses the *CamelCase* naming convention for event handlers; for example,
~onClick~.  You can find a list of all the supported events at
https://reactjs.org/docs/events.html#supported-events.

#+CINDEX:bubble phase
#+CINDEX:capture phase
#+CINDEX:trigger event handlers
By default, React triggers the event handlers in the /bubble phase/, but you
can tell React to trigger them in the /capture phase/ by appending =Capture= to
the event name, for example, ~onClickCapture~.

#+CINDEX:@code{SyntheticEvent} object
React wraps a browser's native events into the ~SyntheticEvent~ object to
ensure that all the supported events behave identically in Internet Exploror 8
and above.

#+CINDEX:@code{nativeEvent} property
#+CINDEX:@code{initializeTouchEvents()} method
<<SyntheticEvent>>The ~SyntheticEvent~ object provides the same API as the
native browser's event, which means that you can use the ~stopPropogation()~
and ~preventDefault()~ methods as usual.  If for some reason, you need to
access the native browser's event, then you can do this via the ~nativeEvent~
property.  To enable touch-event handling, simply call
~React.initializeTouchEvents(TRUE)~.

#+CINDEX:inline event handler, none
Notice that passing the ~onClick~ property to our ~createElement()~ method in
the previous example does not create an inline event handler in the rendered
HTML markup.

: button class="btn btn-default" data-reactid=".0.$button">
:    Toggle header
: </button<>

#+CINDEX:listen for events, at top level
This is because React doesn't actually attach event handlers to the DOM nodes
themselves.  Instead, React listens for all the events at the top level using a
single event listener, and delegates them to their appropriate event handlers.

*** Keeping State Lean

In the previous example, you learned how to create a stateful React component
that a user can interact with and change its state.  We created and attached an
event handler to the ~onClick~ event that updates the value of the
~isHeaderHidden~ property.  But have you noticed that the user interaction does
not update the value of another property that we store in our state, ~title~?
Does thst seem odd to you?  We have data in our state that doesn't ever get
changed.  This observation raises an important question: what should we /not/
put in our state?

Ask yourself a question: what data can I remove from a component's state and
still keep its user interface always up to data?  Keep asking and keep removing
that data until you're absolutely certain that there is nothing left to remove
without breaking your user interface.

In our example, we have the ~title~ property in our state object that we can
move to our ~render()~ method without breaking the interactivity of our toggle
button.  The component will still work as expected:

#+NAME:stateful-component-no-title
#+CAPTION:A stateful component that reacts with minimal state
#+BEGIN_SRC js
{
    getInitialState: function () {
        return {
            isHeaderHidden: false
        }
    },

    handleClick: function () {
        this.setState({
            isHeaderHidden: !this.state.isHeaderHidden
        });
    },

    render: function () {
        var title = 'Stateful React Component';

        var headerElement = React.createElement('h1',
                                                { className: 'header', key: 'header' },
                                                title);
        var buttonElement = React.createElement('button',	(ref:createElement)
                                                { className: 'btn btn-default',
                                                  onClick: this.handleClick,
                                                  key: 'button' },
                                                'Toggle header');
        if (this.state.isHeaderHidden) {
            return React.createElement('div', null, [ buttonElement ]);
        }
        return React.createElement('div', null, [ buttonElement, headerElement ]);
    }
}
#+END_SRC

On the other hand, if we move the ~isHeaderHidden~ property out of a state
object, then we'll break the interactivity of our component because our
~render()~ method will not be triggered automatically by React every time a
user clicks on our button.  This is an example of broken interactivity.

This is an anti-pattern.  Remember this rule of thumb:

#+BEGIN_cartouche
A component's state should store data that a component's event handlers may
change over time in order to rerender a component's user interface and keep it
up to date.  Keep the minimal possible representation of a component's state in
a ~state~ object, and compute the rest of the data based on what's in ~state~
and ~props~ inside a component's ~render()~ method.  Anything you put in
~state~, you'll need to update yourself.  Anything you put in ~render()~ will
automatically get updated by React.  Take advantage of React.
#+END_cartouche

** Summary

In this chapter we reached an important milestone: we learned how to
encapsulate a state and create interactive user interfaces by creating React
components.  We discussed stateless and stateful React components, and the
difference between them.  We talked about the browser events and how to handle
them in React.

In the next chapter, we'll be planning our Snapterest web application.  You'll
learn how to solve a problem with React and how to create composable React
components.

** Stateful React Component

#+NAME:stateful-component
#+CAPTION:An Example of a Lean Stateful Component
#+BEGIN_SRC js -n :tangle snapterest/source/app.js
var React = require('react');
var ReactDOM = require('react-dom');

var ReactClass = React.createClass({
    getInitialState: function () {
        return ({
            isHeaderHidden: false
        })
    },

    handleClick: function () {
        this.setState({
            isHeaderHidden: !this.state.isHeaderHidden
        });
    },

    render: function () {
        var title = 'Stateful React Component';
        var headerElement = React.createElement('h1',
                                                { className: 'header',
                                                  key: 'header' },
                                                title);
        var buttonElement = React.createElement('button',
                                                { className: 'btn btn-default',
                                                  key: 'button',
                                                  onClick: this.handleClick },
                                                'Toggle header');

        if (this.state.isHeaderHidden) {
            return (React.createElement('div', null, [ buttonElement ]));
        }
        return (React.createElement('div', null, [ buttonElement, headerElement ]));
    }
});

var reactComponentElement = React.createElement(ReactClass);

var ReactComponent = ReactDOM.render(
    reactComponentElement,
    document.getElementById('react-application'));

#+END_SRC

* 4. Make Your React Components Reactive

Now that you know how to create React components with and without state, we can
start composing React components together and build more complex user
interfaces.  In fact, its time for us to start building our web application,
called *Snapterest*, that we discussed in Chapter 1.  While doing this, we'll
learn how to plan your React application and create composable React
components.

** Solving a Problem Using React

#+CINDEX:define the problem
Before you start writing code for your web application, you need to think about
the problems that your web application is going to solve.  It's very important
to understand that defining the problem as clearly and as early as possible is
the most important step toward a successful solution---a useful web
application.  If you fail to define your problem early in your development
process, or you define it inaccurately, then later on you'll have to stop,
rethink about what you're doing, throw away a piece of the code that you have
already written, and write a new one.  This is a wasteful approach, and as a
professional software developer your time is very valuable, not only to you,
but also to your organization, so it's in your best interests to invest it
wisely.  Earlier in this book, I stressed on the fact that one of the benefits
of using Reacgt is code reuse, which means that you'll be able to do more in
less time.  However, before we take a look at the React code, let's first
discuss the problem, keeping React in mind.

{{{heading(Snapterest Description)}}}

#+CINDEX:Snapterest description
#+CINDEX:Snapkite Engine server
We'll be building Snapterest---a web application that receives tweets from a
Snapkite Engine server in a real-time manner and displays them one at a time to
a user.  We don't actually know when Snapterest will receive a new tweet, but
when it does, it will display that new tweet for at least 1.5 seconds so that
the user has enought time to look at it and click on it.  Clicking on a tweet
will add it to an existing collection of tweets or create a new one.  Finally,
users will be able to export their collection to an HTML markup code.

{{{subheading(List of Smaller Tasks)}}}

#+CINDEX:task
This is a very high-level description of what we're going to build.  Let's
break it down into a list of smaller tasks:

#+BEGIN_EXAMPLE
Snapkite Engine
|
|
V
Receive Tweet               Remove Tweet from Collection
|                           ^
|                           |
V                           |
Display Tweet               Export Collection
|                           ^
|                           |
V                           |
Add Tweet to Collection --> Display Collection
#+END_EXAMPLE

1. Receive tweets from the Snapkite Engine server in real time
2. Display one tweet at a time for at least 1.5 seconds
3. Add tweets to a collection on a user click event
4. Display a list of tweets in a collection
5. Create an HTML markup code for a collection and export it
6. Remove tweetsw from a collection on a user event


{{{subheading(Using React to Solve Problems)}}}

#+CINDEX:solving tasks using React
Can you identify which tasks can be solved using React?  Remember that React is
a user interface library, so anything that describes the user interface and
interactions with that user interface can be addressed with React.  In the
preceding list, React can take care of all the tasks excdept for the first one
because it describes data fetching and not the user interface in any way.

Task 1 will be solved with another library that we'll discuss in the next
chapter.

#+CINDEX:display data
Tasks 2 and 4 describe something that needs to be displayed.  They are perfect
condidates for React components.

#+CINDEX:user events
Tasks 3 and 6 describe the user events, and as we've seen in Chapter 3, user
eventws handling can be encapsulated in React components as well.

#+CINDEX:@code{ReactDOMServer.renderToStaticMarkup()} method
#+CINDEX:static HTML markup
Can you think of how task 5 can be solved with React?  Remember in Chapter 2 we
discussed the ~ReactDomServer.renderToStaticMarkup()~ method that renders the
React element to a static HTML markup string.  That's exactly what we need in
order to solve task 5.

{{{subheading(Putting It All Together)}}}

Now that we've identified a potential solution for each individual task, let's
think about how we are going to put them together and create a fully functional
web application.

#+CINDEX:composable React application, building
There are two ways to build composable React applications:

1. You can start by building individual React components and then compose them
   together into higher-level React components, moving up the component hierarchy.

2. You can start from the topmost React element and then implement its child
   components, moving down the component hierarchy.


The second strategy has the advantage of seeing and understanding the big
picture of your application's architecture.  I think it's important to
understand how everthing fits together before we can think of how individual
pieces of functionality are implemented.

** Planning Your React Application

There are two simple guidelines we need to follow when planning your React
application:

1. Each React component should represent a single user interface element in
   your web application.  It should encapsulate the smallest element possible
   that can potentially be reused.

2. Multiple React components should be composed into a single React component.
   Ultimately, your entire user interface should be encapsulated in one React
   component.


#+BEGIN_EXAMPLE
Application --> Stream
                --> Header  --> StreamTweet
                                --> Header --> Tweet
--> Collection
    --> TweetList  --> Header --> CollectionControls
        --> Tweet                      --> Header  --> Button
                                  --> CollectionRenameForm  --> CollectionExportForm
                                      --> Header  --> Button
#+END_EXAMPLE

{{{heading(Application)}}}

#+CINDEX:@code{Application} component
#+CINDEX:@code{Stream} component
#+CINDEX:@code{Collection} component
We'll begin with our topmost React component, ~Application~.  It will
encapsulate our entire React application, and it will have two child
components: the ~Stream~ and ~Collection~ components.

{{{subheading(Stream)}}}

#+CINDEX:@code{Stream} component
The ~Stream~ component will be responsible for connecting to a stream of
tweets, and receiving  and displaying the latest tweet.  The ~Stream~ component
will have two child components: ~StreamTweet~ and ~Header~.

#+CINDEX:@code{StreamTweet} component
#+CINDEX:@code{Header} component
#+CINDEX:@code{Tweet} component
The ~StreamTweet~ component will be responsible for displaying the latest
tweet.  It will be composed of the ~Header~ and ~Tweet~ components.

#+CINDEX:@code{Header} component
#+CINDEX:@code{Tweet} component
A ~Header~ component will render a header.  It will have no child components.
A ~Tweet~ component will render an image from a tweet.

Notice how we're planning to reuse the ~Header~ component twice already.

{{{subheading(Collection)}}}

#+CINDEX:@code{Collection} component
#+CINDEX:@code{CollectionControls} component
#+CINDEX:@code{TweetList} component
The ~Collection~ component will be responsible for displaying the collection
controls and a list of tweets.  It will have two child components:
~CollectionControls~ and ~TweetList~.

#+CINDEX:codepen
#+CINDEX:@code{CollectionControls} component
#+CINDEX:@code{CollectionRenameForm} component
#+CINDEX:@code{CollectionExportForm} component
The ~CollectionControls~ will have two child components: the
~CollectionRenameForm~ component that will render a form to rename a
collection, and the ~CollectionExportForm~ component that will render a form to
export a collection tto a service called *CodePen*, which is an HTML, CSS, and
JavaScript playground website.  You can learn more about CodePen at
https://codepen.io.

#+CINDEX:@code{Header} component
#+CINDEX:@code{Button} component
#+CINDEX:@code{CollectionRenameForm} component
#+CINDEX:@code{CollectionControls} component
#+CINDEX:@code{TweetList} component
#+CINDEX:@code{Tweet} component
#+CINDEX:@code{Collection} component
As you might have noticed, we'll reuse the ~Header~ and ~Button~ components in
the ~CollectionRenameForm~ and ~CollectionControls~ components.  Our
~TweetList~ component will render a list of Tweets.  Each tweet will be
rendered by a ~Tweet~ component.  We'll be reusing the ~Header~ component once
again in our ~Collection~ component.  In fact, we'll be reusing the ~Header~
component five times.  That's a win for us.

{{{heading(State)}}}

#+CINDEX:stateless components
#+CINDEX:stateful components
As we discussed in the previous chapter, we should keep as many React
components stateless as possible.  So, only 5 out of 11 components will store
the state, which are:

- ~Application~
- ~CollectionControls~
- ~CollectionRenameForm~
- ~Stream~
- ~StreamTweet~


Now that we have a plan, we can start implementing.

** Creating a Container React Component

{{{heading(Root Application File)}}}

#+CINDEX:main application file, @file{app.js}
#+CINDEX:@file{app.js}
Let's start by editing our application's main JavaScript file.  Replace the
contents of the ~<dir>/snapterest/source/app.js~ file with the following code
snippet:

#+NAME:react-application-container
#+CAPTION:The React Application Root Container File
#+BEGIN_SRC js snapterest/source/app.js
var React = require('react');
var ReactDOM = require('react-dom');
var Application = require('./components/Application.react');

ReactDOM.render(<Application />, document.getDocumentById('react-application');
#+END_SRC

There are only four lines of code in this face, and as you can guess, they
provide ~document.getElementById('react-application') as a deployment target
for the ~<Application />~ component and render ~<Application />~ to the DOM.
The whole user interface for our web application will be encapsulated in one
React component, ~Application~.

** Creating the React Application Component

#+CINDEX:@file{Application.react.js} file
#+CINDEX:React Application component
Next, navigate to ~<dir>/snapterest/source/components/~ and create the
~Application.react.js~ file inside this directory.  All of our React components
will have their filenames ending with ~react.js~.  This convention allows us to
easily distinguish between React and non-React source JavaScript files.

Let's take a look at the contents of the ~Application.react.js~ file:

#+NAME:react-application
#+CAPTION:The React Application File
#+BEGIN_SRC js snapterest/source/components/application.react.js
var React      = require('react');
var Stream     = require('./Stream.react');
var Collection = require('./Collection.react');

var Application = React.createClass({
    getInitialState: function () {
        return {
            collectionTweets: {}
        }
    },

    addTweetToCollection: function (tweet) {
        var collectionTweets = this.state.collectionTweets;
        collectionTweets[tweet.id] = tweet;
        this.setState({
            collectionTweets: collectionTweets
        });
    },

    removeTweetFromCollection: function (tweet) {
        var collectionTweets = this.state.collectionTweets;
        delete collectionTweets[tweet.id];
        this.setState({
            collectionTweets: collectionTweets
        });
    },

    removeAllTweetsFromCollection: function () {
        this.setState ({
            collectionTweets: {}
        });
    },

    render: function () {
        return (
            <div className="container-fluid">
                <div className="row">
                    <div className="col-md-4 text-center">
                        <Stream onAddTweetToCollection={this.addTweetToCollection} />
                    </div>
                    <div className="col-md-8">
                        <Collection
                            tweets={this.state.collectionTweets}
                            onRemoveTweetFromCollection={this.removeTweetFromCollection}
                            onRemoveAllTweetsFromCollection={this.removeAllTweetsFromCollection}
                        />
                    </div>
                </div>
            </div>
        );
    }
});

module.exports = Application;
#+END_SRC

This code has significantly more code than our ~app.js~ file, but this code can
be easily divided into three logical parts:

1. Importing dependency modules
2. Defining React components
3. Exporting a React component as a module


#+CINDEX:CommonJS
You will see this logical separation in most of our React components because
they are wrapped into the *CommonJS* module pattern that allows us to easily
require them with Browserify.  In fact, the first and the third parts of this
source file are related to how CommonJS works and have nothing to do with how
React works.  The purpose of using this module pattern is to break our
application into modules that can be easily reused.  Because the React
component and CommonJS module pattern both encapsulate the code and mnake it
portable, they naturally work great together.  So, we end up encapsulating our
user interface logic in a React component and then encapsulate that React
component in the CommonJS module.  It then can be used in any other module that
wants to reuse this encapsulated React component.

*** Importing Dependency Modules

#+CINDEX:import dependencies
In our first logical part of the ~Application.react.js~ file, we're importing
the dependency modules using the ~require()~ function.

<<two child components>>Our ~Application~ component will have two child
components that we need to import:

1. The ~Stream~ component will render a stream section of our user interface
2. The ~Collection~ component will render a collection section of our user
   interface


We also need to import the ~React~ library as another module.  Notice that this
code is still part of the CommonJS module pattern, not React.

*** Creating React Components

#+CINDEX:create components
The second logical part of the ~Application.react.js~ file creates the React
~Application~ component with the following methods:

- ~getInitialState()~
- ~addTweetToCollection()~
- ~removeTweetFromCollection()~
- ~removeAllTweetsFromCollection()~
- ~render()~


#+CINDEX:@code{getInitialState()} React method
#+CINDEX:@code{render()} React method
#+CINDEX:application logic
Only the ~getInitialState()~ and ~render()~ methods are part of the React API.
All the other methods are part of our application logic that this component
encapsulates.  We'll take a closer look at each of them right after we discuss
what this component renders inside its ~render()~ method.

#+CINDEX:Bootstrap
It defines the layout of our web page using the <<Bootstrap>>Bootstrap
framework.  If you're not familiar with Boostrap, I strongly recommend that you
visit https://getbootstrap.com/ and read the documentation.  Learning this
framework will empower you to prototype user interfaces in a fast and easy way.

Even if you don't know Bootstrap, it's quite easy to understand what's going
on.  We're dividing our web page into two columns: a smaller one and a larger
one.  The smaller one contains our ~Stream~ React component and the larger one
contains our ~Collection~ component.  You can imagine that our web page is
divided into two unequal parts and both of them contain the React components.

**** The Stream Component

#+CINDEX:@code{Stream} component
This is how we're using our ~Stream~ component:

: <Stream onAddTweetToCollection={this.addTweetToCollection} />

#+CINDEX:@code{onAddTweetToCollection} property
#+CINDEX:@code{addTweetToCollection()} method
The ~Stream~ component has an ~onAddTweetToCollection~ property, and our
~Application~ component passes its own ~addTweetToCollection()~ method as a
value for this property.  ~addTweetToCollection()~ adds a tweet to a
collection.  It's one of the custom methods that we define in our ~Application~
component, and we can refer to it using ~this~ keyword.

#+CINDEX:@code{CollectionTweets}
Let's take a look at what the ~addTweetToCollection()~ method does.  This
method references ~CollectionTweets~ that are stored in the current state, adds
a new tweet to a ~collectionTweets~ object, and updates the state by calling
the ~setState()~ method.  A new tweet is passed as an argument when the
~addTweetToCollection()~ method is called inside a ~Stream~ component.  This is
an example of how a child component can update its parent component's state.

This is an important mechanism in React and it works as follows:

1. A parent component passes a callback function as a property to its child
   component.  A child component can access this callback function via the
   ~this.props~ variable.

2. Whenever a child component wants to update the parent component's state, it
   calls that callback function and passes all the necessary data to a new
   parent component's state.

3. A parent component updates its state, and as you already know, this state
   updates and triggers the ~render()~ function that re-renders all the child
   components as necessary.


This is how a child component interacts with a parent component.  This
interaction allows a child component to delegate the application's state
management to its parent component, and it is only concerned with how to render
itself.  Now, when you've learned this pattern, you will be using it again and
again because most of your React components should stay stateless.  This best
practice allows us to logically group React components by the two different
concerns they address:

- Manage the application's state and render

- Only render and delegate the application's state management to a parent
  component

**** The Collection Component

#+CINDEX:@code{Collection} component
Our ~Application~ component has a second child component, ~Collection~.  This
component has a number of properties:

  #+CINDEX:@code{tweets}
- ~tweets~ : This refers to our current collection of tweets

  #+CINDEX:@code{onRemoveTweetFromCollection}
- ~onRemoveTweetFromCollection~ : <<removeTweet>>This refers to a function that
  removes a particular tweet from our collection

  #+CINDEX:@code{onRemoveAllTweetsFromCollection}
- ~onRemoveAllTweetsFromCollection~ : <<removeAllTweets>>This refers to a
  function that removes all the tweets from our collection


You can see that the ~Collection~ component's properties are only concerned
about how to:

- Access the application's state
- Mutate the application's state


The ~onRemoveTweetFromCollection~ and ~onRemoveAllTweetsFromCollection~
functions allow the ~Collection~ component to mutate the ~Application~
component's state.  On the other hand, the ~tweets~ property propogates the
~Application~ component's state to the ~Collection~ component so that it can
gain a read-only access to the state.

*** Data Flow

#+CINDEX:data flow
Can you recognize the single direction of data flow between the ~Application~
and ~Collection~ components?  Here's how it works:

1. The ~collectionTweets~ data is initialized in the ~Application~ component's
   ~getInitialState()~ method

2. The ~collectionTweets~ data is passed to the ~Collection~ component as the
   ~tweets~ property.

3. The ~Collection~ component calls the ~removeTweetFromCollection~ and
   ~removeAllTweetsFromCollection~ functions that update the ~collectionTweets~
   data in the ~Application~ component, and the cycle starts again.


Notice that the ~Collection~ component cannott directly mutate the
~Application~ component's state.  The ~Collection~ component has read-only
access to that state via ~this.props~ object, and the only way to update the
parent component's state is to call the callback functions that are passed by
the parent component.  In the ~Collection~ component, these callback functions
are ~this.props.onRemoveTweetFromCollection~ and
~this.props.onRemoveAllTweetsFromCollection~.

This simple mental model of how data flows in our React component hierarchy
will help us increase the number of components we use, without increasing the
complexity of how our user interface works.  For example, it can have 10 levels
of nested React components, as follows:

#+BEGIN_EXAMPLE
Component A -->
  Component B -->
    Component C -->
      Component D -->
        Component E -->
          Component F -->
            Component G
#+END_EXAMPLE

If ~Component G~ wants to mutate the state of root ~Component A~, it would do
it in the exact same way that ~Component B~, or ~Component F~, or any other
component in this hierarchy would.  However, in React, you shouldn't pass data
from ~Component A~ directly to ~Component G~.  Instead, you should pass it to
~Component B~, then to ~Component C~, then to ~Component D~, and so on until
you finally reach ~Component G~.  ~Component B~ to ~Component F~ will have to
carry some ``transit'' properties that are actually meant for ~Component G~.
This might look like a waste of time, but this design makes it easy for us to
debug our application and be able to reason out how it works.  There are always
stragegies to optimize your application's architecture.  One of them is to use
*Flux*, which we'll discuss later in this book.

*** Mutating Data

#+CINDEX:mutate data
Before we finish discussing our Application component, let's take a look at the
two methods that mutate its state:

- ~removeTweetFromCollection()~
- ~removeAllTweetsFromCollection()~


The first removes a tweet from a collection of tweets that we store in the
~Application~ component's state.  It takes the current ~collectionTweets~
object from the component's state, deletes a tweet with a given ID from that
objectm and updates the component's state with an updated ~collectionTweets~
object.

On the other hand, the second method removes all the tweets from the
component's state.

Both of these methods are called from a child's ~Collection~ component because
that component has no other way to mutate the ~Application~ component's state.

** Summary

In this chapter we learned how to solve a problem with React.  We started by
breaking down the problem into smaller individual problems and then discussed
how we can address them using React.  Then, we created a list of React
components that we needed to implement.  Finally, we created our first
composable React component and learned how a parent component interacts with
its child components.

In the next chapter, we'll implement our child components and learn about
React's lifecycle methods.

* 5. Use Your React Components With Another Library

#+CINDEX:integrate 3rd party library
#+CINDEX:receive data, 3rd part library
React is a great library for building user interfaces.  What if we want to
integrate it with another library that is responsible for receiving data?  In
the previous chapter, we outlined five tasks that our Snapterest web
application should be able to perform.  We decided that four of them were
related to the user interface, but one of them was all about receiving data;
receive tweets from the Snapkite Engine server in real time.

In this chapter we'll learn how to integrate React with the external JavaScript
library and what React component lifecycle methods are, all while solving the
very important task of receiving data.

** Using Another Library in Your React Component

#+CINDEX:Snapkite Engine library
#+CINDEX:Twitter Streaming API
#+CINDEX:stream of tweets
Our Snapterest web application will consume a live stream of tweets.  In
Chapter 1, you installed the *Snapkite Engine* library that connects to the
Twitter Streaming API, filters the incoming tweets, and sends them to our
client application.  In turn, our client application needs a way of connecting
to that live stream and listening for the new tweets.

#+CINDEX:@code{snapkite-stream-client} module
We don't need to implement this functionality outselves because we can reuse
another Snapkite module called ~snapkite-stream-client~.  Let's install this
module.

*** Installing ~snapkite-stream-client~ Module

#+CINDEX:@code{snapkite-stream-client} module, install
Navigate to the ~<dir>/snapterest/~ directory and run the following command:

: npm install --save snapkite-stream-client

It will install the ~snapkite-stream-client~ module, and add it to
~package.json~ as a dependency.

#+NAME:snapkite-stream-client
#+CAPTION[snapkite-stream-client]:After Installing the ~snapkite-stream-client~ Module
#+BEGIN_src sh
$ yarn add snapkite-stream-client
yarn add v1.13.0
[1/4] 🔍  Resolving packages...
[2/4] 🚚  Fetching packages...
[3/4] 🔗  Linking dependencies...
[4/4] 🔨  Building fresh packages...
success Saved lockfile.
success Saved 25 new dependencies.
info Direct dependencies
└─ snapkite-stream-client@1.0.3
info All dependencies
├─ after@0.8.2
├─ arraybuffer.slice@0.0.6
├─ backo2@1.0.2
├─ base64-arraybuffer@0.1.5
├─ blob@0.0.4
├─ callsite@1.0.0
├─ component-bind@1.0.0
├─ component-inherit@0.0.3
├─ engine.io-client@1.8.5
├─ engine.io-parser@1.3.2
├─ has-cors@1.1.0
├─ json3@3.3.2
├─ object-component@0.0.3
├─ options@0.0.6
├─ parsejson@0.0.3
├─ parseqs@0.0.5
├─ snapkite-stream-client@1.0.3
├─ socket.io-client@1.7.4
├─ socket.io-parser@2.3.1
├─ to-array@0.1.4
├─ ultron@1.0.2
├─ ws@1.1.5
├─ wtf-8@1.0.0
├─ xmlhttprequest-ssl@1.5.3
└─ yeast@0.1.2
   Done in 2.23s.

$ cat package.json
{
  "name": "snapterest",
  "version": "1.0.0",
  "main": "index.js",
  "license": "MIT",
  "devDependencies": {
    "babelify": "^6.2.0",
    "browserify": "^16.2.3",
    "gulp": "^4.0.0",
    "vinyl-source-stream": "^2.0.0"
  },
  "dependencies": {
    "react": "0.14.8",
    "react-dom": "0.14.8",
    "snapkite-stream-client": "^1.0.3"
  }
}
#+END_SRC

Now we're ready to reuse the ~snapkite-stream-client~ module in one of our
React components.

*** Creating the ~Stream~ Component with the ~snapkite-stream-client~ Module

#+CINDEX:@code{Stream} component
In the previous chapter, we created the ~Application~ component with two child
components: ~Stream~ and ~Collection~.  In this chapter, we'll create our
~Stream~ component.

Start by creating the ~<dir>/snapterest/source/components/Stream.react.js~
file:

#+CINDEX:@file{Stream.react.js} file
#+NAME:Stream-component
#+CAPTION:The ~Stream.react.js~ File
#+BEGIN_SRC js :tangle snapterest/source/components/Stream.react.js :mkdirp yes
var React = require('react');
var SnapkiteStreamClient = require('snapkite-stream-clinet');
var StreamTweet = require('./StreamTweet.react');
var Header = require('./Header.react');

var Stream = React.createClass({
    getInitialState: function () {
        return { tweet: null }
    },

    componentDidMount: function () {
        SnapkiteStreamClient.initializeStream(this.handleNewTweet);
    },

    componentWillUnmount: function () {
        SnapkiteStreamClient.destroyStream();
    },

    handleNewTweet: function (tweet) {
        this.setState({ tweet: tweet });
    },

    render: function () {
        var tweet = this.state.tweet;

        if (tweet) {
            return (
                <StreamTweet
                 tweet={tweet}
                 onAddTweetToCollection={this.props.onAddTweetToCollection}
                />
            );
        }

        return (
            <Header text="Waiting for public photos from Twitter..." />
        );
    }
});

module.exports = Stream;
#+END_SRC

#+CINDEX:@file{StreamTweet} module
#+CINDEX:@file{Header} module
#+CINDEX:@file{snapkite-stream-client} module
We first import the modules that our ~Stream~ component depends on:

- ~React~: React library
- ~StreamTweet~ and ~Header~: React components
- ~snapkite-stream-client~: a utility library


#+CINDEX:@code{getInitialState()}
#+CINDEX:@code{componentDidMount()}
#+CINDEX:@code{componentWillUnmount()}
#+CINDEX:@code{handleNewTweet()}
#+CINDEX:@code{render()}
Then we define our React component.  Here are the methods that our ~Stream~
component implements:

- ~getInitialState()~
- ~componentDidMount()~
- ~componentWillUnmount()~
- ~handleNewTweet()~
- ~render()~

**** ~Stream~'s ~render()~ Method

#+CINDEX:@code{render()} method, in @file{Stream}
We are already familiar with the ~getInitialState()~ and ~render()~ mnethods;
they are part of React's API.  You already know that any React component must
implement at least the ~render()~ method.  Let's take a look at the ~render()~
method of our ~Stream~ component.

We created a new ~tweet~ variable that references the ~tweet~ property, which
is party of the component's state object.  We then check whether that variable
has a reference to an actual ~tweet~ object, and if it does, our ~render()~
method returns the ~StreamTweet~ component, or else, it returns the ~Header~
component.

The ~StreamTweet~ component renders a header and the latest tweet from a
stream, whereas the ~Header~ component renders only a header.

Have you noticed that our Stream component doesn't render anything itself, but
rather returns one of the two other components that do the actual rendering?
The purpose of the ~Stream~ component is to encapsulate our application's logic
and delegate rendering to the other React components.  In React, you should
have at least one component that encapsulates your application's logic, stores,
and manages your application's state.  This is usually a root component or one
of the high-level components in your component hierarchy.  All the other child
React components should have no state if possible.  If you think of all the
React components as ~Views~, then our ~Stream~ component is a ~ControllerView~.

**** ~Stream~'s Other Methods

Now that we know what a ~Stream~ component renders, let's discuss it in the
other methods.

#+CINDEX:@code{getInitialState()} in @file{Stream} component
The ~getInitialState()~ method returns the initial state object with a ~tweet~
property, which is set to =null=.  Our ~Stream~ component will receive an
endless stream of new tweets, and it needs to re-render its child components
every time a new tweet is received.  In order to achieve this, we need to store
the current tweet in the component's state.  Once we update its state, React
will call its ~render()~ method and re-render all of its child components.  For
this purpose, we will implement the ~handleNewTweet()~ method.

#+CINDEX:@code{handleNewTweet()} in @file{Stream} component
The ~handleNewTweet()~ method takes a ~tweet~ object, and sets it as a new
value for the component state's ~tweet~ property.

#+CINDEX:@code{componentDidMount()} in @file{Stream} component
Where does the new tweet come from and when does it come?  Let's take a look at
our ~componentDidMount()~ method.

#+CINDEX:@code{initializeStream()} method in @file{Stream} component
#+CINDEX:@file{SnapkiteStreamClient} object in @file{Stream} component
#+CINDEX:@code{handleNewTweet} callback
This function calls the ~initialzeStream()~ method of the
~SnapkiteStreamClient~ object, and passes a ~this.handleNewTweet~ callback
function as its argument.  ~SnapkiteStreamClient~ is an external library with
an API that we're using to initialize a stream of tweets.  The
~this.handlNewTweet~ function will be called for every tweet that
~SnapkiteStreamClient~ receives.

Why did we name this method ~componentDidMount()~?  We didn't.  React did.  In
fact, the ~componentDidMount()~ method is part of React's API.  It's one of the
React component's lifecycle methods.  It's called only once, immediately after
React has finished the initial rendering of our component.  At this point,
React has created a DOM tree, which is represented by our component, and now we
can access that DOM with another JavaScript library.

~componentDidMount()~ is a perfect place for integrating React with another
JavaScript library.  This is where we connect to a stream of tweets using the
external ~SnapkiteStreamClient~ library.

**** Cleaning Up

#+CINDEX:uninitialize
#+CINDEX:@code{componentWillUnmount()} method
#+CINDEX:component, unmount
#+CINDEX:unmount component
Now we know when to initialize the external JavaScript libraries in our React
components, but what about the reverse process---when should we uninitialize
and clean up everything that we've done in the ~componentDidMount()~ method?
It's a good idea to clean up everything before we unmount our components.  For
this purpose, React API offers us another component lifecycle
method---~componentWillUnmount()~.

#+CINDEX:@code{destroyStream()} method
#+CINDEX:@file{Stream} component, unmount
The ~componentWillUnmount()~ method is called by React just before React
unmounts the component.  As you can see in the ~componentWillUnmount()~ method,
you're calling the ~destroyStream()~ method in the ~SnapkiteStreamClient~
object.  ~destroyStream()~ cleans up our connection to ~SnapkiteStreamClient~,
and we can safekly unmount our ~Stream~ component.

** Understanding React Component's Lifecycle Methods

#+CINDEX:lifecycles of React components
Think about what a React component does.  It describes what to render.  We know
that it uses the ~render()~ method for this.  However, sometimes, having only
the ~render()~ method is not enough because what if we want to do something
before or after the component has rendered?  What if we want to be able to
decide whether a component's ~render()~ method should be called at all?

#+CINDEX:component lifecycles, methods
Looks like what we're describing is a process during which the React component
is rendered.  This process has various stages, for example, before render,
render, after render, and so on.  In React, this process is called the
{{{dfn(component's lifecycle)}}}.  Each React component goes through this
process.  What we want is a way to hook into that process,and call our own
functions at different stages of that process in order to have a greater
control over it.  For this purpose, React provides a number of methods that we
cna use to get notified when a certain stage in a component's lifecycle process
occurs.  These methods are called the {{{dfn(component's lifecycle
methods)}}}.  They are called in a predictable order.

All the React component's lifecycle methods can be grouped into three phases:

#+CINDEX:mounting phase
#+CINDEX:updating phase
#+CINDEX:unmounting phase
#+CINDEX:lifecycle phases
#+CINDEX:phases, React component's lifecycle methods
#+ATTR_TEXINFO: :indic b
- Mounting ::

              This phase occurs when a component is being inserted into the DOM

- Updating ::

              This phase occurs when a component is being re-rendered into a
              virtual DOM to figure out if the actual DOM needs to be updated

- Unmounting ::

                This phase occurs when a component is being removed from the
                DOM


#+CINDEX:mounting a component
#+CINDEX:unmounting a component
In React's terminology, inserting a component into the DOM is called
{{{dfn(mounting)}}}, whereas removing a component from the DOM is called
{{{dfn(unnounting)}}}.

*** Creating the ~StreamTweet~ Component

The best way to learn about the React component's lifecycle methods is to see
them in action.  Let's create our ~StreamTweet~ component that we discussed
earlier in this chapter.  This component will implement most of React's
lifecycle methods.

Navigate to ~<dir>/snapterest/source/components/~ and create the
~StreamTweet.react.js~ file:

#+NAME:StreamTweet
#+CAPTION:Creating the ~StreamTweet.react.js~ File
#+BEGIN_SRC js :tangle snapterest/source/components/StreamTweet.react.js :noweb tangle :mkdirp yes
var React = require('react');
var ReactDOM = require('react-dom');
var Header = require('./Header.react');
var Tweet = require('./Tweet.react');

var StreamTweet = React.createClass({
    // define other component lifecycle methods here

    <<getInitialState>>
    <<componentWillMount>>
    <<componentDidMount>>
    <<componentWillReceiveProps>>
    <<shouldComponentUpdate>>
    <<componentWillUpdate>>
    <<componentDidUpdate>>
    <<componentWillUnmount>>

    render: function () {
        console.log('[Snapterest] StreamTweet: Running render()');

        return (
            <section>
                <Header text={this.state.headerText} />
                <Tweet
                 tweet={this.props.tweet}
                 onImageClick={this.props.onAddTweetToCollection}
                />
            </section>
        );
    }
});

module.exports = StreamTweet;
#+END_SRC

The ~StreamTweet~ component has no lifecycle methods yet, other than
~render()~.  We'll create and discuss them one by one as we move ahead.

#+CINDEX:mounting phase, methods called during
The four methods are called during a component's /mounting/ phase, as shown in
the following:

#+CINDEX:@code{getInitialState()}
#+CINDEX:@code{componentWillMount()}
#+CINDEX:@code{render()}
#+CINDEX:@code{componentDidMount()}
#+BEGIN_EXAMPLE
getInitialState()
|
V
componentWillMount()
|
V
render()
|
V
componentDidMount()
#+END_EXAMPLE

In this chapter, we'll discuss three of these four methods (except
~render()~).  They are called once when the component is inserted into the
DOM.  Let's take a closer look at each of them.

*** Mounting Methods

#+CINDEX:mounting methods of a component
Now let's check out some of the useful mounting methods.

**** The ~getInitialState()~ Method

#+CINDEX:@code{getInitialState()} mounting method
The ~getInitialState()~ method is invoked first.  It is invoked /before/ React
inserts a component into the DOM.  If you want your component to have a state,
then use this method to return the initial component's state.  In your
~StreamTweet~ component, add the following code:

#+NAME:getInitialState
#+CAPTION:StreamTweet's ~getInitialState()~ Method
#+BEGIN_SRC js
// getInitialState() method
getInitialState: function () {
    console.log('[Snapterest] StreamTweet: 1. Running getInitialState()');

    return ({
        numberOfCharactersIsIncreasing: null,
        headerText: null
    });
},

#+END_SRC

In our ~StreamTweet~ component's ~getInitialState()~ method, we will perform
the following steps:

1. Log the following message in a web browser's console:
   : [Snapterest] StreamTweet: 1. Running getInitialState().

   #+CINDEX:@code{numberOfCharactersIsIncrease()} property
   #+CINDEX:@code{headerText()} property
2. Return an object with the ~numberOfCharactersIsIncreasing~ and ~headerText~
   properties set to =null=.

   - ~numberOfCharactersIsIncreasing~ will keep track of whether a tweet that
     will be displayed next has more characters in its text than a currently
     displayed tweet.  We'll set it to a Boolean value in our next component
     lifecycle method.

   - The ~headerText~ will store the text for the ~Header~ component that
     ~StreamTweet~ renders.


As with all the mounting methods, ~getInitialState()~ will be called only once.

**** The ~componentWillMount()~ Method

#+CINDEX:@code{componentWillMount()} mounting method
The ~componentWillMount()~ method is invoked second.  It is invoked
/immediately before/ React inserts a component into the DOM.  Add this code
right after the ~getInitialState()~ method in your ~StreamTweet~ component.

#+NAME:componentWillMount
#+CAPTION:StreamTweet's ~componentWillMount()~ Method
#+BEGIN_SRC js
// componentWillMount method
componentWillMount: function () {
    console.log('[Snapterest] StreamTweet: 2. Running componentWillMount()');

    this.setState({
        numberOfCharactersIsIncreasing: true,
        headerText: 'Latest public photo from Twitter'
    });

    window.snapterest = {
        numberOfReceivedTweets: 1,
        numberOfDisplayedTweets: 1
    };
},

#+END_SRC

We do a number of things in this method.  First, we log the fact that this
method is being invoked.  In fact, for the purpose of demonstration, we'll log
every component lifecycle method of this component.  When you run this code in
a web browser, you should be able to open the JavaScript console and see these
log messages printed in the expected ascending order.

Next, we update the component's state using the ~this.setState()~ method:

  #+CINDEX:@code{numberOfCharactersIsIncreasing} property, set
  #+CINDEX:@code{headerText} property, set
- Set the ~numberOfCharactersIsIncreasing~ property to =true=
- Set the ~headerText~ property to 'Latest public photo from Twitter'


Because this is the very first tweet that this component will render, we know
that the number of characters is definitely increasing from nothing to the
number of characters in that first tweet.  Hence, we set it to =true=.  We also
assign the default text to our header.


#+CINDEX:@code{setState()} method
As you know, calling the ~this.setState()~ method should trigger the
component's ~render()~ method, so it seems like ~render()~ will be called twice
during the component's mounting phase.  However, in this case, React knows that
nothing has been rendered yet, so it will call the ~render()~ method only once.

#+CINDEX:@code{snapterest} global object
#+CINDEX:global object, @code{snapterest}
#+CINDEX:@code{window.snapterest} global object
Finally, in this method, we define a ~snapterest~ global object with the
following two properties:

   #+CINDEX:@code{numberOfReceivedTweets} global property
1. ~numberofReceivedTweets~: This property counts the number of all the
   received tweets

   #+CINDEX:@code{numberOfDisplayedTweets} global property
2. ~numberOfDisplayedTweets~: This property counts the number of only the
   displayed tweets


#+CINDEX:@code{numberOfReceivedTweets}, set
#+CINDEX:@code{numberOfDisplayedTweets}, set
We set ~numberOfReceivedTweets~ to 1 because we know that the
~componentWillMount()~ method is called only once when the very first tweet is
receivedf.  We also know taht our ~render()~ method will be called for this
very first tweet, so we set ~numberOfDisplayedTweets~ to 1 as well.


#+CINDEX:global object
#+CINDEX:@code{window.snapterest} global object
This global object is not part of React or our web application's logic; we can
remove it and everything will still work as expected.  ~window.snpaterest~ is a
convenience tool used to keep track of how many tweets we've processed at any
point in time.  We use the global ~window.snapterest~ object for demonstration
purposes only.  I would strongly advise you against adding your own properties
to a global object in real life projects because you might overwrite the
exsiting properties and/or your properties might be overwritten later by some
other JavaScript code that you don't own.  Later on, if you decide to deploy
Snapterest in production, then make sure to remove the global
~window.snapterest~ object and the related code from the ~StreamTweet~
component.

After running Snapterest in a web browser for a few minutes, you can open the
JavaScripty console and type the ~snapterest.numberOfReceivedTweets~ and
~snapterest.numberOfDisplayedTweets~ commands.  These commands will output the
numbers that will help you get a better understanding of how fast the new
tweets are comming in, and how many of them are not being displayed.  In our
next component lifecycle method, we'll add more properties to our
~window.snapterest~ object.

**** The ~componentDidMount()~ Method

#+CINDEX:@code{componentDidMount()} mounting method
#+CINDEX:third party libraries, integrate
#+CINDEX:integrate third party libraries
The ~componentDidMount()~ method is invoked third.  It is invoked /immediately
after/ React inserts a component into the DOM.  The updated DOM is now
available for access, which means that this method is the best place for
initializing other JavaScript libraries that need access to that DOM.

Earlier in this chapter, we created our ~Stream~ component with the
~componentDidMount()~ method that initializes the external
~snapkite-stream-client~ JavaScript library.

Let's take a look at this component's ~componentDidMount()~ method.  Add the
following code to your ~StreamTweet~ component after the ~componentWillMount()~
method:

#+NAME:componentDidMount
#+CAPTION: StreamTweet's ~componentDidMount()~ Method
#+BEGIN_SRC js
// componentDidMount() method
componentDidMount: function () {
    console.log('[Snapterest] StreamTweet: 3. Running componentDidMount()');

    var componentDOMRepresentation = ReactDOM.findDOMNode(this);

    window.snapterest.headerHTML = componentDOMRepresentation.children[0].outerHTML;
    window.snapterest.tweetHTML = componentDOMRepresentation.children[1].outerHTML;
},

#+END_SRC

#+CINDEX:@code{ReactDOM.findDOMNode()} method
#+CINDEX:@code{findDOMNode()} method
#+CINDEX:@code{componentDOMRepresentation} variable
Here, we're referencing the DOM that represents our ~StreamTweet~ component
using the ~ReactDOM.findDOMNode()~ method.  We pass ~this~ parameter that
references the current component (in this case, ~StreamTweet~).  The
~componentDOMRepresentation~ variable references the DOM tree that we can
traverse and access its various properties.  To get a good understanding of what
this DOM tree looks like, let's take a closer look at the ~render()~ method of
four ~StreamTweet~ component.

#+CINDEX:JSX, benefit
One of the greatest benefits of using JSX is that we can easily identify how
many child elements our component will have just by looking at the component's
~render()~ method.  Here, we can see that a parent ~<section>~ element has two
child components: ~<Header />~ and ~<Tweet />~.

#+CINDEX:traverse the DOM
#+CINDEX:DOM traversal
#+CINDEX:@code{children} property of the DOM API
#+CINDEX:DOM API, @code{children}
So when we traverse the resulting DOM tree using the DOM API ~children~
property, we can be sure that it will have two child elements as well:

  #+CINDEX:@code{componentDOMRepresentation.children} array access
- ~componentDOMRepresentation.children[0]~: This is our ~<Header />~ component's
  DOM representation

- ~componentDOMRepresentation.children[1]~: This is our ~<Tweet />~ component's
  DOM representation


#+CINDEX:@code{outerHTML} attribute
#+CINDEX:@code{window.snapterest} global object
The ~outerHTML~ attribute of each element gets the HTML string that represents
the DOM tree of each element.  We reference this HTML string in our global
~window.snapterest~ object for convenience.

#+CINDEX:integrate third party library
#+CINDEX:third party library, integrate
If you are using another JavaScript library such as *JQuery*, along with React,
then use the ~componentDidMount()~ method as an opportunity to integrate the
two.  If you want to send an AJAX request, or set timers using the
~setTimeout()~ or ~setInterval()~ functions, then you can do that in this
method as well.  In general, ~componentDidMount()~ should be your preferred
component lifecycle for integrating the React library with non-React libraries
and APIs.

**** Summary of Mounting Methods

So far, in this chapter, we've learned about the fundamental mounting methods
tht the React component provides us with.  We used all the three of them in our
~StreamTweet~ component.  We also discussed the ~StreamTweet~'s ~render()~
method.  This is all that we need to know to understand how React will render
the ~StreamTweet~ compoonent initially.  On its very first render, React will
execute the following sequence of methods:

1. ~getInitialState()~
2. ~componentWillMount()~
3. ~render()~
4. ~componentDidMount()~


This is called the React component's {{{dfn(mounting phase)}}}.  It is executed
onlyi once, unless we unmount a component and mount it again.

Next, let's discuss the React component's /unmounting phase/.

*** Unmounting Methods

#+CINDEX:unmounting method
Let's now take a look at one of the popular unmounting methods.

**** The ~componentWillUnmount()~ Method

#+CINDEX:@code{componentWillUnmount()} unmounting method
#+CINDEX:clean up component
React offers only one method for this phase, that is,
~componentWillUnmount()~.  It is invoked /immediately before/ React removes a
component from the DOM and destroys it.  This method is useful for cleaning up
any data that is created during the component's mounting or updating phases.
That's exactly what we do in our ~StreamTweet~ component.  Add this code to
your ~StreamTweet~ component after the ~compontDidMount()~ method:

#+NAME:componentWillUnmount
#+CAPTION:StreamTweet's ~componentWillUnmount()~ Method
#+BEGIN_SRC js
// componentWillUnmount() method
componentWillUnmount: function () {
    console.log('[Snapterest] StreamTweet: 8. Running componentWillUnmount()');

    delete window.,snapterest;
},

#+END_SRC

#+CINDEX:@code{window.snapterest} global object, delete
#+CINDEX:delete @code{window.snapterest} global object
#+CINDEX:global object @code{window.snapterest}, delete
In the ~componentWillUnmount()~ method, we delete our global
~window.snapterest~ object using the {{{command(delete)}}} operator.

Removing ~window.snapterest~ will keep our global object clean.  If you've
created any additional DOM elements in the ~componentDidMount()~ method, then
the ~componentWillUnmount()~ method is a good place to remove them.  You can
think of the ~componentDidMount()~ and ~componentWillUnmount()~ methods as a
two-step mechanism for integrating the React component with another JavaScript
API:

1. Initialize it in the ~componentDidMount()~ method
2. Terminate it in the ~componentWillUnmount()~ method


This way your external JavaScript libraries that need to work with the DOM will
stay in sync with the DOM rendered by React.

That's all we need to know to efficiently unmount React components.

** Summary

In this chapter, we created our ~Stream~ component and learned how to integrate
a React component with the external JavaScript library.  We also learned about
the React component's lifecycle methods.  We also focused on and discussed the
mounting and unmounting methods in detail and started implementing the
~StreamTweet~ component.

In our next chapter, we'll take a look at the component lifecycle's updating
methods.  We'll also implement our ~Header~ and ~Tweet~ components, and learn
how to set the component's default properties.
* 6. Update Your React Components

In the previous chapter we learned that a React component can go through three
phases:

1. Mounting

2. Updating

3. Unmounting


We've already discussed the mounting and unmounting phases.  In this chapter,
we're going to focus on the updating phase.  During this phase, a React
component is already inserted into the DOM.  This DOM represents a component's
current state, and when the state changes, React needs to evaluate how a new
state is going to mutate the previously rendered DOM.

React provides us with methods to influence what is going to be rendered during
an update as well as to make us aware of when an update happens.  These methods
allow us to control the transition from the current component's state to the
next component's state.  Let's learn more about the powerful nature of the
React component's updating methods.

** Understanding Component Lifecycle's Updating Methods

#+CINDEX:update phase of component
#+CINDEX:component's update phase
#+CINDEX:lifecycle methods of update phase
#+CINDEX:@code{componentWillReceiveProps()}
#+CINDEX:@code{shouldComponentUpdate()}
#+CINDEX:@code{componentWillUpdate()}
#+CINDEX:@code{render()}
#+CINDEX:@code{componentDidUpdate()}
A React component has *five lifecycle methods* that belong to a component's
/updating/ phase:

1. ~componentWillReceiveProps()~
2. ~shouldComponentUpdate()~
3. ~componentWillUpdate()~
4. ~render()~
5. ~componentDidUpdate()~


*** The ~componentWillReceiveProps()~ Method

We'll start with the ~componentWillReceiveProps()~ method in the ~StreamTweet~
component.  Add the following code after the ~componentDidMount()~ method in
~StreamTweet.react.js~ file:

#+NAME:componentWillReceiveProps
#+CAPTION[componentWillReceiveProps]:The ~componentWillReceivePropse()~ Method in ~StreamTweet~ Component
#+BEGIN_SRC js
// componentWillReceiveProps() Method
componentWillReceiveProps: function (nextProps) {
    console.log('[Snapterest] StreamTweet: 4. Running componentWillReceiveProps()');

    var currentTweetLength = this.props.tweet.text.length;
    var nextTweetLength = nextProps.tweet.text.length;
    var isNumberOfCharactersIncreasing = (nextTweetLength > currentTweetLength);
    var headerText;

    this.setState({
        numberOfCharactersIsIncreasing: isNumberOfCharactersIncreasing
    });

    if (isNumberOfCharactersIncreasing) {
        headerText = 'Number of characters is increasing';
    } else {
        headerText = 'Latest public photo from Twitter';
    }

    this.setState({
        headerText: headerText
    });

    window.snapterest.numberOfReceivedTweets++;
},

#+END_SRC

{{{heading(Explanation of ~componentWillReceiveProps()~)}}}

#+CINDEX:@code{componentWillReceiveProps()} update phase
This method is invoked first in the component's lifecycle's updating phase.  It
is called when a component receives new properties from its parent component.

{{{subheading(Using ~nextProps~ Object)}}}

#+CINDEX:@code{nextProps} object
This method is an opportunity for us to compare the current component's
properties using the ~this.props~ object with the next component's properties
using the ~nextProps~ object.  Based on this comparison, we can choose to
update the component's state using the ~this.setState()~ method, which will not
trigger an additional render in this scenario.

{{{subheading(Comparing the Lengths of the Tweets)}}}

We first get the lengths of the current tweet and the next tweet.  The current
one is available via ~this.props.tweet~ and the next one via
~nextProps.tweet~.  We then compare their lengths by checking whether the next
tweet is longer than the current one.  The result of the comparison is stored
in the ~isNumberOfCharactersIncreasing~ variable.  Finally, we update the
component's state by setting the ~numberOfCharactersIsIncreasing~ property to
the value of our ~isNumberOfCharactersIncreasing~ variable.

{{{subheading(Setting the ~headerText~ Property)}}}

We then set our header text.  If the next tweet is longer, we set the header
text to `Number of characters is increasing', or else we set it to `Latest
public photo from Twitter'.  We then update our component's state once more by
setting the ~headerText~ property to the value of our ~headerText~ variable.

{{{subheading(Batching State Updates)}}}

Notice that we call the ~this.setState()~ function twice in our
~componentWillReceiveProps()~ method.  This is to illustrate the point that no
matter how many times you call ~this.setState()~ in the
~componentWillReceiveProps()~ method, it won't trigger any additional renders
of that component.  React does an internal optimization where it batches the
state updates together.

{{{subheading(Counting Total Tweets Received)}}}

Since the ~componentWillReceiveProps()~ method will be called once for each new
tweet that our ~StreamTweet~ component will receive, it makes it a good place
to count the total number of received tweets.

Now we know how to check whether the next tweet is longer than the tweet we're
currently displaying, but how can we choose not to render the next tweet at
all?

*** The ~shouldComponentUpdate()~ Method

#+CINDEX:@code{shouldComponentUpdate()} updating method
The ~shouldComponentUpdate()~ method allows us to decide whether the next
component's state should trigger the component's re-rendering or not.  This
method returns a Boolena value, which by default is =true=, but you can return
=false=, and the following component methods will /not/ be called:

- ~componentWillUpdate()~
- ~render()~
- ~componentDidUpdate()~


Skipping a call to the component's ~render()~ method will prevent that
component from re-renderibng which in turn will improve your application's
performance, since no addiitional DOM mutations will be made.

This method is invoked second in the component lifecycle's updating phase.

This method is a great place for us to prevent the next tweet with one or less
characters from being displayed.  Add this code to the ~StreamTweet~ component
after the ~componentWillReceiveProps()~ method:

#+NAME:shouldComponentUpdate
#+CAPTION:The ~shouldComponentUpdate()~ Method of ~StreamTweet~
#+BEGIN_SRC js
// shouldComponentUpdate() method
shouldComponentUpdate: function (nextProps, nextState) {
    console.log('[Snapterest] StreamTweet: 5. Running shouldComponentUpdate()');

    return (nextProps.tweet.length > 1);
},

#+END_SRC

If the next tweet's length is greater than 1, then ~shouldComponentUpdate()~
returns =true=, and the ~StreamTweet~ component renders the next tweet.  Or
else, it returns =false=, and the ~StreamTweet~ component doesn't render the
next state.

*** The ~componentWillUpdate()~ Method

#+CINDEX:@code{componentWillUpdate()} method
The ~componentWillUpdate()~ method is called /immediately before/ React updates
the DOM.  It gets the following two arguments:

1. ~nextProps~: The next properties object
2. ~nextState~: The next state object


You can use these arguments to prepare for the DOM update.  However, you cannot
use ~this.setState()~ in the ~componentWillUpdate()~ method.  If you want to
update the component's state in response to its properties change, then do that
in the ~componentWillReceiveProps()~ method, which will be called by React when
the properties change.

To demonstrate when the ~componentWillUpdate()~ method is called, we need to
log it in the ~StreamTweet~ component.  Add this code after the
~shouldComponentUpdate()~ method:

#+NAME:componentWillUpdate
#+CAPTION:The ~componentWillUpdate()~ Method of ~StreamTweet~
#+BEGIN_SRC js
// componentWillUpdate Method
componentWillUpdate: function (nextProps, nextState) {
    console.log('[Snapterest] StreamTweet: 6. Running componentWillUpdate()');
},

#+END_SRC

*** The ~componentDidUpdate()~ Method

#+CINDEX:@code{componentDidUpdate()} method
The ~componentDidUpdate()~ method is called /immediately after/ React updates
the DOM.  It gets these two arguments:

- ~prevProps~: The previous properties object
- ~prevState~: The previous state object


#+CINDEX:post-render operations
We will use this method to interact with the updated DOM or perform any
post-render operations.  In our ~StreamTweet~ component, we'll use
~componentDidUpdate()~ to increment the number of displayed tweets in our
global object.  Add this code after the ~componentWillUpdate()~ method:

#+NAME:componentDidUpdate
#+CAPTION:The ~componentDidUpdate()~ Method of ~StreamTweet~
#+BEGIN_SRC js
// componentDidUpdate() method
componentDidUpdate: function (prevProps, prevState) {
    console.log('[Snapterest] StreamTweet: 7. Running componentDidUpdate()');

    window.snapterest.numberOfDisplayedTweets++;
},

#+END_SRC

#+CINDEX:@code{forceUpdate()} method
After ~componentDidUpdate()~ is called, the updating cycle ends.  A new cycle
is started when a component's state is updated or a parent component passes new
properties.  Or when you call the ~forceUpdate()~ method, it triggers a new
updating cycle, but skips the ~shouldComponentUpdate()~ method on a component
that triggered the update.  However, ~shouldComponentUpdate()~ is called on all
child components as per the usual updating phase.  Try to avoid using the
~forceUpdate()~ method as much as possible; this will promote your
application's maintainability.

That concludes our discussion of React component lifecycle methods.

** Setting Default React Component Properties

Our ~StreamTweet~ component renders two child components: ~Header~ and ~Tweet~.

Let's create these components.

*** Creating the ~Header~ Component

#+CINDEX:Header component, create
#+CINDEX:@file{Stream} Component
Navigate to ~<dir>/snapterest/source/components/~ and create the
~Header.react.js~ file:

#+NAME:Header component
#+CAPTION[Header Component]:The ~Header~ Component in ~Header.react.js~
#+BEGIN_SRC js :tangle snapterest/source/components/Header.react.js :mkdirp
var React = require('react');

var headerStyle = {				(ref:headerStyle)
    fontSize: '16px',
    fontWeight: '300',
    display: 'inline-block',
    margin: '20px 10px'
};

var Header = React.createClass({

    getDefaultProps: function () {		(ref:getDefaultProps)
        return ({
            text: 'Default header'
        });
    },

    render: function () {
        return (
            <h2 style={headerStyle}>		(ref:style-prop)
                {this.props.text}
            </h2>
        );
    }
});

module.exports = Header;
#+END_SRC

#+CINDEX:@code{Header} component
#+CINDEX:stateless component, @code{Header}
The ~Header~ component is a stateless component that renders the ~h2~ element.
The hepader text is passed from a parent component as a ~this.props.text~
property, which makes this component flexible in that it allows us to reuse it
anywhere we need a header.  We'll reuse this component again later in this
book.

Notice that the ~h2~ element has a [[(style-prop)][=style= property]].

#+CINDEX:style property
#+CINDEX:inline styling
In React, we can define the CSS rules in a JavaScript object, and then pass
that object as a value to the React element's =style= property.  For example,
in this component, we define the [[(headerStyle)][~headerStyle~ variable]] that references an
object where:

- Each object key is a CSS property
- Each object value is a CSS value


#+CINDEX:inline styling, advantages
The advantages of defining your CSS rules inside a React component are as
follows:

#+ATTR_TEXINFO: :indic b
- Portability: ::

                 You can easily share a component together with its styling,
                 all in one JavaScript file;

- Encapsulation: ::

                   Making styles inline allows you to limit the scope they
                   affect

- Flexibility: ::

                 The CSS rules can be calculated using the power of JavaScript


#+CINDEX:Content Security Policies (CSP)
#+CINDEX:CSP
#+CINDEX:inline styling, disadvantage
The significant disadvantage of using this technique is the fact that
{{{dfn(Content Security Policies (CSP))}}} can block inline styling from having
any effect.  You can learn more about CSP at
https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP.

#+CINDEX:@code{getDefaultProps()} method
The ~Header~ component has one method that we haven't discussed yet, that is,
~getDefaultProps()~.  What if you forget to pass a property that a React
component depends on?  In that case, a component can set the default properties
using the ~getDefaultProps()~ method.

[[(getDefaultProps)][In this example]], we're setting a default value of =Default header= to our
=text= property.  If a parent component passes the ~this.props.text~ property,
then it will overwrite the default one.

*** Creating the ~Tweet~ Component

#+CINDEX:@file{Tweet} component
Next, let's create our ~Tweet~ component.  Navigate to
~<dir>snapterest/source/components/~ and create the ~Tweet.react.js~ file:

#+NAME:Tweet component
#+CAPTION[Tweet Component]:The ~Tweet~ Component in ~Tweet.react.js~
#+BEGIN_SRC js :tangle snapterest/source/components/Tweet.react.js
var React = require('react');

var tweetStyle = {
    position: 'relative',
    display: 'inline-block',
    width: '300px',
    height: '400px'
    margin: '10px'
};

var imageStyle = {
    maxHeight: '400px',
    boxShadow: '0px 1px 1px 0px #aaa',
    border: '1px solid #fff'
};

var Tweet = React.createClass({

    propTypes: {						(ref:propTypes)

        tweet: function (properties, propertyName, componentName) { (ref:tweet-validator)
            var tweet = properties[propertyName];

            if (!tweet) {
                return new Error('Tweet must be set.');
            }

            if (!tweet.media) {
                return new Error('Tweet must have an image.');
            }
        },

        onImageClick: React.PropTypes.func		(ref:func-validator)
    },

    handleImageClick: function () {			(ref:click-handler)
        var tweet = this.props.tweet;
        var onImageClick = this.props.onImageClick;

        if (onImageClick) {
            onImageClick(tweet);
        }
    },

    render: function () {
        var tweet = this.props.tweet;
        var tweetMediaUrl = tweet.media[0].url;

        return (
            <div style={tweetStyle}>
                <img src={tweetMediaUIrl}
                 onClick={this.handleImageClick}
                 style={imageStyle}
                />
            </div>
        );
    }
});

module.exports = Tweet;
#+END_SRC

#+RESULTS: Tweet

#+CINDEX:click event handler
This component renders a ~<div>~ element with a child ~<img>~ element.  Both
the elements have inline styles, and the ~<img>~ element has a click event
handler, that is, [[(click-handler)][~this.handleImageClick~]].

#+CINDEX:optional property
#+CINDEX:required property
When a user clicks on a tweet's image, the ~Tweet~ component checks whether a
parent component has passed a ~this.props.onImageClick~ callback function as a
property and calls that function.  ~this.props.onImageClick~ is an optional
~Tweet~ component's property, so we need to check whether it was passed before
we can use it.  On the other hand, ~tweet~ is a required property.

How can we ensure that a component receives all the required properties?

** Validating React Component Properties

#+CINDEX:=propTypes= object
#+CINDEX:validate component properties
#+CINDEX:properties, validate
In React, there is a way to validate the component properties using the
component's =propTypes= object:

#+NAME:PropTypes-object
#+CAPTION:The =PropTypes= Object
#+BEGIN_SRC js
propTypes: {
    propertyName: validator
}
#+END_SRC

#+CINDEX:validator function
#+CINDEX:@code{React.PropTypes} object
#+CINDEX:predefined validators
#+CINDEX:validators, predefined
In this object, you need to specify a property name and a validator function
that will determine whether a property is valid or not.  React provides some
predefined validators for you to reuse.  That are all available in the
=React.PropTypes= object:

- ~React.PropTypes.number~: ::  This will validate whether a property is a
     numberr or not

- ~React.PropTypes.string~: :: This will validate whether a property is a
     string or not

- ~React.PropTypes.bool~: :: This will validate whether a property is a Boolean
     or not

- ~React.PropTypes.object~: :: This will validate whether a property is an
     object or not

- ~React.PropTypes.element~: :: This will validate whether a property is a
     React element or not


For a complete list of the =React.PropTypes= validators, you can check the docs
at https://reactjs.org/docs/typechecking-with-proptypes.html.

By default, all the properties that you validate with the =React.PropTypes=
validators are optional.  You can chain any of them with ~isRequired~ to make
sure that a warning message is displayed on a JavaScript console when a
property is missing:

#+NAME:PropTypes-object-isRequired
#+CAPTION:The =PropTypes= Object with ~isRequired~
#+BEGIN_SRC js
propTypes: {
    propertyName: React.PropTypes.number.isRequired
}
#+END_SRC

#+CINDEX:custom validator function
#+CINDEX:validator function, custom
#+CINDEX:@code{Error} object
You can also specify your own custom validator function tht should return an
=Error= object if the validation fails:

#+NAME:PropTypes-object-custom
#+CAPTION:A Custom =PropTypes= Object
#+BEGIN_SRC js
propTypes: {
    propertyName: function (properties, propertyName, componentName) {
        // ... validation failed
        return new Error('A property is not valid.');
    }
}
#+END_SRC

#+CINDEX:custom validator function
Look at the [[(propTypes)][=propTypes= object]] in the ~Tweet~ component.  We're validating two
~Tweet~ component properties: ~tweet~ and ~onImageClick~.  We use the custom
validator function to validate the ~tweet~ property.  React passes three
parameters to this function:

1. ~properties~: This is the component properties object
2. ~propertyName~: This is the name of the property that we're validating
3. ~componentName~: This is the name of the Component


We first check whether our ~Tweet~ component received the [[(tweet-validator)][~tweet~ property]].
Then we assume that the ~tweet~ proeprty is an object, and we check whether
that object has no ~media~ property.  Both of these checks return an =Error=
object that will be logged in a JavaScript console.

Another ~Tweet~ component's property that we will validate is [[(func-validator)][~onImageClick~]].
We validate that the value of the ~onImageClick~ is a function.  In this case,
we reuse a validator function provided by the =React.PropTypes= object.
~onImageClick~ is an optional property because we didn't add ~isRequired~.

Finally, for performance reasons, =propTypes= is only checked in the
development version of React.

** Creating a Collection Component

[[two child components][Recall]] that our topmost hierarchy ~Application~ component has two child
components:
- ~Stream~
- ~Collection~


#+CINDEX:~Collection~ component
So far, we've discussed and implemented our ~Stream~ component and its child
components.  Next, we're going to focus on our ~Collection~ component.

Create the ~<dir>/snapterest/source/components/Collection.react.js~ file:

#+NAME:Collection-component
#+CAPTION:The ~Collection~ Component in ~Collection.react.js~
#+BEGIN_SRC js :tangle snapterest/source/components/Collection.react.js :mkdirp
var React = require('react');
var ReactDOMServer = require('react-dom/server');
var CollectionControls = require('./CollectionControls.react');
var TweetList = require('./TweetList.react');
var Header = require('./Header.react');

var Collection = React.createClass({

    createHtmlMarkupStringOfTweetList: function () {	(ref:htmlString)
        var htmlString = ReactDOMServer.renderToStaticMarkup(
            <TweetList tweets={this.props.tweets} />
        );

        var htmlMarkup = {
            html: htmlString
        };

        return (JSON.stringify(htmlMarkup));
    },

    getListOfTweetIds: function () {
        return (Object.keys(this,.props.tweets));
    },

    getNumberOfTweetsInCollection: function () {
        return (this.getListOfTweetIds().length);
    },

    render: function () {				(ref:Collection-render)
        var numberOfTweetsInCollection = this.getNumberOfTweetsInCollection();

        if (numberOfTweetsInCollection > 0) {	(ref:four-variables)
            var tweets = this.props.tweets;
            var htmlMarkup = this.createHtmlMarkupStringOfTweetsList();
            var removeAllTweetsFromCollection = this.props.onRemoveAllTweetsFromCollection;
            var handleRemoveTweetFromCollection = this.props.onRemoveTweetFromCollection;

            return (				(ref:Collection-notempty)
                <div>
                    <CollectionControls
                        numberOfTweetsInCollection={numberOfTweetsInCollection}
                	htmlMarkup={htmlMarkup}
                	onRemoveAllTweetsFromCollection={removeAllTweetsFromCollection}
                    />

                    <TweetList
                	tweets={tweets}
                	onRemoveTweetFromCollection={handleRemoveTweetFromCollection}
                    />
                </div>
            );
        }

        return (
            <Header text='Your Collection is empty' />;
        );
    }
});

module.exports = Collection;
#+END_SRC

*** Collection Renders Tweets and Control Elements

#+CINDEX:@file{Collection} component
The ~Collection~ component is responsible for rendering two things:

1. Tweets that a user has collected

2. User interface control elements for manipulating that collection


{{{subheading(Collection's ~render()~ Method)}}}

#+CINDEX:@file{Collection} @code{render()} method
Take a look at the component's [[(Collection-render)][~render()~ method]].

#+CINDEX:@code{getNumberOfTweetsInCollection()} method
#+CINDEX:@code{getListOfTweetIds()} method
We first get a number of tweets in the collection using the
~this.getNumberOfTweetsInCollection()~ method.  This method in turn uses
another method to get a list of tweet IDs: ~getListOfTweetIds()~ method, which
returns an array of tweet IDs, and then ~this.getNumberOfTweetsInCollection()~
returns the length of this array.

Once we know the number of tweets in our collection, we have to make a choice:

  #+CINDEX:@file{CollectionControls} component
  #+CINDEX:@file{TweetList} component
- If the collection is /not/ empty, then render the ~CollectionControls~ and
  ~TweetList~ components;

  #+CINDEX:@file{Header} component
- Otherwise, render the ~Header~ component;


What do all these components render?

  #+CINDEX:@file{CollectionControls} component @code{render()}
- The ~CollectionControls~ component renders a header with a collection name
  and a set of buttons that allow users to rename, empty, and export a
  collection;

  #+CINDEX:@file{TweetList} component @code{render()}
- The ~TweetList~ component renders a list of tweets;

  #+CINDEX:@file{Header} component @code{render()}
- The ~Header~ component simply renders a header with a message that the
  collection is empty;


The idea is to only show a collection when it is not empty.  In that case,
we're creating [[(four-variables)][four variables]]:

  #+CINDEX:@code{tweets} variable
- the ~tweets~ variable references our ~tweets~ property that is passed from a
  parent component;

  #+CINDEX:@code{htmlMarkup} variable
- the ~htmlMarkup~ variable references a string that is returned by the
  component's ~this.createHtmlMarkupStringOfTweetList()~ method;

  #+CINDEX:@code{removeAllTweetsFromCollection} variable
  #+CINDEX:@code{handleRemoveTweetFromCollection} variable
- The ~removeAllTweetsFromCollection~ and ~handleRemoveTweetFromCollection~
  variables reference functions that are passed from a parent component;


*** HTML Markup • Flexible • JSX Syntax

{{{subheading(Creating HTML Markup)}}}

#+CINDEX:@code{createHtmlMarkupStringOfTweetList()} method
#+CINDEX:@code{ReactDOMServer.renderToStaticMarkup()} method
#+CINDEX:@code{renderToStaticMarkup()} method
#+CINDEX:@file{TweetList} component as argument
As the name suggests, the ~this.createHtmlMarkupStringOfTweetList()~ method
creates a [[(htmlString)][string]] that represents the HTML markup created by rendering the
~TweetList~ component.  This method uses the
~ReactDOMServer.renderToStaticMarkup()~ method that we discussed in [[renderToStaticMarkup][Chapter 2]].
We pass the ~TweetList~ component as its argument.  This ~TweetList~ component
has a =tweets= property that references the =tweets= property passed by a
parent component.

#+CINDEX:@code{htmlString} variable
#+CINDEX:@code{htmlMarkup} object
#+CINDEX:@code{JSON.stringify()} function
#+CINDEX:@code{createHtmlMarkupStringOfTweetList()} method
The resuling HTML string produced by the
~ReactDOMServer.renderToStaticMarkup()~ method is stored in the ~htmlString~
variable.  Then, we create a new ~htmlMarkup~ object with the ~html~ property
that references our ~htmlString~ variable.  Finally, we use the
~JSON.stringify()~ function to convert our ~htmlMarkup~ JavaScript object to a
JSON string.  The result of the ~JSON.stringify(htmlMarkup)~ call is what our
~createHtmlMarkupStringOfTweetList()~ method returns.

{{{subheading(React Components are Flexible)}}}

This method demonstrates how flexible React components are; you can use the
same React components to render the DOM elements as well as produce a string of
HTML markup that can be passed to a third-party API.

{{{subheading(JSX Syntax can be used Anywhere)}}}

#+CINDEX:JSX syntax outside @code{render()} method
Another interesting observation that one can make is the use of JSX syntax
outside a ~render()~ method.  In fact, you can use JSX anywhere in your source
file, even outside the ~React.createClass()~ method.

*** What ~Collection~ Returns When Collection is not Empty

#+CINDEX:root element, only one
#+CINDEX:@file{CollectionControls} component
Take a closer look at what the ~Collection~ component returns when our
collection [[(Collection-notempty)][is /not/ empty]].  We wrap the ~CollectionControls~ and ~TweetList~
components in the ~<div>~ element because React allows only one root element.
Let's take a look at each component and discuss its properties.

We pass the following three properties to the ~CollectionsControls~ component:

   #+CINDEX:@code{numberOfTweetsInCollection} property
1. The =numberOfTweetsInCollection= property references the current number of
   tweets in our collection.

   #+CINDEX:@code{htmlMarkup} property
2. The =htmlMarkup= property references a string of HTML markup that we produce
   in this component using the ~createHtmlMarkupStringOfTweetList()~ method.

   #+CINDEX:@code{onRemoveAllTweetsFromCollection} property
3. The =onRemoveAllTweetsFromCollection= property references a function that
   removes all the tweets from our collection.  This function is implemented in
   the ~Application~ component as discussed in [[removeAllTweets][Chapter 4]].


#+CINDEX:@file{TweetList} component, arguments passed to
We pass these two properties to the ~TweetList~ component:

  #+CINDEX:@code{tweets} property
- The =tweets= property references tweets passed from a parent ~Application~
  component;

  #+CINDEX:@code{onRemoveTweetFromCollection} property
- The =onRemoveTweetFromCollection= property references a function that removes
  a tweet from a collection of tweets tht we store in the ~Application~
  component's state.  We've already discussed this function in [[removeTweet][Chapter 4]].

** Summary

In this chapter, we learned about a component's lifecycle updating methods.  We
also discussed how to validate the component properties and set the default
properties.  We also made good progress with our Snapterest application; we
created and discussed the ~Header~, ~Tweet~, and ~Collection~ components.

In the next chapter we'll focus on building more complex React components and
finish building our Snapterest application.

* 7. Build Complex React Components

In this chapter we'll put everything we learned so far about React components
in action by building the most complex components in our application, that is,
child components of our ~Collection~ component.  Our aim in this chapter is to
gain a solid React experience and grow our React muscles.

** Creating the ~TweetList~ Component

#+CINDEX:@file{TweetList} component
The ~Collection~ component has two child components:

1. ~CollectionControls~
2. ~TweetList~


#+CINDEX:@file{TweetList} component
First build the ~TweetList~ component.  Create the following
~<dir>/snapterest/source/components/TweetList.react.js~ file:

#+NAME:TweetList-component
#+CAPTION[TweetList Component]:The ~TweetList~ Component of the ~Collection~ Component
#+HEADER: :noweb tangle :mkdirp yes
#+BEGIN_SRC js :tangle snapterest/source/components/TweetList.react.js
var React = require('react');
var Tweet = require('./Tweet.react');

var listStyle = {
    padding: '0'
};

var listItemStyle = {
    display: 'inline-block',
    listStyle: 'none'
};

var TweetList = React.createClass({
    <<TweetList getListOfTweetIds method>>
    <<TweetList getTweetElement method>>
    <<TweetList render method>>
});

module.exports = TweetList;
#+END_SRC

*** The ~render()~ Method

#+CINDEX:list of tweets
#+CINDEX:@code{Tweet} elements
#+CINDEX:@file{Tweet} component
#+CINDEX:@code{map} method
#+CINDEX:@code{getTweetElement()} method
The ~TweetList~ component renders a [[(list-of-tweets)][list of tweets]] using the ~render()~
function.

#+NAME:TweetList render method
#+CAPTION:The ~TweetList~ ~render()~ Method
#+BEGIN_SRC js
render: function () {				(ref:list-of-tweets)
    var tweetElements = this.getListOfTweetIds().map(this.getTweetElement);

    return (
        <ul style={listStyle}>
            {tweetElements}
        </ul>
    );
}
#+END_SRC

First, we create a list of ~Tweet~ elements.

{{{subheading(The ~getListOfTweetIds~ Method)}}}

The ~this.getListOfTweetIds()~ method returns an array of tweet IDs.

#+NAME:TweetList getListOfTweetIds method
#+CAPTION:The ~getListOfTweetIds~ Method of ~TweetList~
#+BEGIN_SRC js
getListOfTweetIds: function () {
    return Object.keys(this.props.tweets);
},

#+END_SRC

Then, for each tweet ID in that array, we create a ~Tweet~ component.  For
this, we will call the ~map()~ method on our array of tweet IDs and pass the
~this.getTweetElement()~ method as a callback function.

{{{subheading(The ~getTweetElement~ Method)}}}

#+NAME:TweetList getTweetElement method
#+CAPTION:The ~getTweetElement~ Method of ~TweetList~
#+BEGIN_SRC js
getTweetElement: function (tweetId) {
    var tweet = this.props.tweets[tweetId];
    var handleRemoveTweetFromCollection = this.props.onRemoveTweetFromCollection;
    var tweetElement;

    if (handleRemoveTweetFromCollection) {	(ref:scenario1)
        tweetElement = (
            <Tweet
                tweet={tweet}
                onImageClick={handleRemoveTweetFromCollection}
            />
        );
    } else {					(ref:scenario2)
        tweetElement = <Tweet tweet={tweet} />;
    }

    return (					(ref:tweet-in-li)
        <li style={listItemStyle} key={tweet.id} >
            {tweetElement}
        />
    );
},

#+END_SRC

*** Handling the Optional ~onImageClick~ Property

#+CINDEX:@code{onImageClick} property
The ~getTweetElement()~ method returns a ~Tweet~ element [[(tweet-in-li)][wrapped]] in the ~<li>~
element.  The ~Tweet~ component has an optional ~onImageClick~ property.  When
do we want to provide this optional property and when don't we?

There are two scenarios.

- In the [[(scenario1)][first scenario]], the user will click on a tweet image to remove it from
  a collection of tweets.  In this scenario, our Tweet component will react to
  a ~click~ even, so we need to provide the ~onImageClick~ property.

- In the [[(scenario2)][second scenario]], the use will export a static collecton of tweets that
  has no user interaction.  In this scenario, we don't need to provide the
  ~onImageClick~ property.


#+CINDEX:@code{getTweetElement()} method
#+CINDEX:@code{tweet} variable
#+CINDEX:@code{tweetId} argument
#+CINDEX:@code{onRemoveTweetFromCollection} property
That's exactly what we do in our ~getTweetElement()~ method.  We create a
~tweet~ variable that stores a tweet with an ID that is provided by the
~tweetId~ argument.  Then, we create a variable that stores a
~this.props.onRemoveTweetFromCollection~ property that is passed by a parent
~Collection~ component.

#+CINDEX:@code{onImageClick} property
Next we check whether the ~this.props.onRemoveTweetFromCollection~ property is
provided by a ~Collection~ component.  If it is, then we create a ~Tweet~
component with an ~onImageClick~ property.  If it isn't provided, then we
create a ~Tweet~ component without a ~handleImageClick~ property.

*** Using the ~TweetList~ Component

#+CINDEX:@code{TweetList} component
We use the ~TweetList~ component in the following two cases:

  #+CINDEX:@code{onRemoveTweetFromCollection} property
- This component is used when rendering a collection of tweets in the
  ~Collection~ component.  In this case, the ~onRemoveTweetFromCollection~
  property /is/ provided.

- This component is used when rendering a string of HTML markup that represents
  a collection of tweets in the ~Collection~ component.  In this case, the
  ~onRemoveTweetFromCollection~ property /is not/ provided.


#+CINDEX:@code{tweetElement} variable
Once we create our ~Tweet~ element, and put it into the ~tweetElement~
variable, we return the ~<li>~ element with an inline style.

#+CINDEX:@code{key} property
#+CINDEX:dynamic children
Besides the =style= property, our ~<li>~ element has a =key= property.  It is
used by React to identify each child element that is created dynamically.  I
recommend that you read more about dynamic children at
https://react.tips/how-to-create-components-dynamically-in-react-16/.

#+CINDEX:@code{getTweetElement()} method
That's how the ~getTweetElement()~ method works.  As a result, the ~TweetList~
component returns an unordered list of ~Tweet~ elements.

** Creating the ~CollectionControls~ Component

#+CINDEX:child components of @file{Collection} componenet
Now, when we understand what the ~Collection~ component renders, let's discuss
its child components.  We'll start with ~CollectionControls~.  Create the
following ~<dir>/snapterest/source/components/CollectionControls.react.js~
file:

#+NAME:CollectionControls-component
#+CAPTION[CollectionControls Component]:The ~CollectionControls~ Component of ~Collection~ Component
#+HEADER: :noweb tangle :mkdirp yes
#+BEGIN_SRC js :tangle snapterest/source/components/CollectionControls.react.js
var React = require('react');
var Header = require('./Header.react');
var Button = require('./Button.react');
var CollectionRenameForm = require('./CollectionRenameForm.react');
var CollectionExportForm = require('./CollectionExportForm.react');

var CollectionControls = React.createClass({
    <<CollectionControls getInitialState method>>
    <<CollectionControls getHeaderText method>>
    <<CollectionControls toggleEditCollectionName method>>
    <<CollectionControls setCollectionName method>>
    <<CollectionControls render method>>
});

module.exports = CollectionControls;
#+END_SRC

#+CINDEX:@file{CollectionsControls} Component
#+CINDEX:user interface
#+CINDEX:collection, control
The ~CollectionsControls~ Component renders a user interface to control a
collection.  These controls allow the use to:

- Rename a collection
- Empty a collection
- Export a collection


A collection has a name.  By default this name is =new= and users can change
it.  A collection name is displayed in a header that is rendered by the
~CollectionControls~ component.  This component is a perfect candidate for
storing the collection's name, and since changing a name will require a
component re-render, we'll store that name in the component's state object:

#+NAME:CollectionControls getInitialState method
#+CAPTION[CollectionControls getInitialState()]:The ~getInitialState()~ Method of ~CollectionControls~ Component
#+BEGIN_SRC js
getInitialState: function () {
    return ({
        name: 'new',
        isEditingName: false
    });
},

#+END_SRC

#+CINDEX:@code{isEditingName} property
The ~CollectionControls~ component can render either collection control
elements or a form to change the collection name.  A user can switch betweeen
the two.  We need a way to represent these two states---we'll use the
=isEditingName= property for that purpose.  By default, =isEditingName= is set
to =false=; and therefore, users won't see a form to change the collection
name, when the ~CollectionControls~ component is mounted.

{{{subheading(The ~render()~ Method of ~CollectionControls~ Component)}}}

#+CINDEX:@code{render} method of @file{CollectionControls} component
Let's take a look at its ~render()~ method:

#+NAME:CollectionControls render method
#+CAPTION[CollectionControls render()]:The ~render()~ Method of ~CollectionControls~ Component
#+BEGIN_SRC js :noweb tangle
render: function () {
    if (this.state.isEditingName) {
        return (
            <<CollectionControls render CollectionRenameForm>>
        );
    }

    return (
        <div>
            <Header text={this.getHeaderText()} />

            <<CollectionControls render Rename Button component>>
            <<CollectionControls render Empty Button component>>

            <<CollectionControls render Export component>>
        </div>
    );
}
#+END_SRC

#+CINDEX:@code{isEditinName} property
#+CINDEX:@file{CollectionRenameForm} component
First we check whether the component state's property
~this.state.isEditingName~ is set to =true=.  If it is, then the
~CollectionControls~ component returns the ~CollectionRenameForm~ component
that renders a form to change the collection name:

#+NAME:CollectionControls render CollectionRenameForm
#+CAPTION:CollectionControls render CollectionRenameForm
#+BEGIN_SRC js
            <CollectionRenameForm
                name={this.state.name}
                onChangeCollectionName={this.setCollectionName}
                onCancelCollectionNameChange={this.toggleEditCollectionName}
            />
#+END_SRC

The ~CollectionRenameForm~ component renders a form to change the collection
name.  It receives three properties:

- The =name= property referendes the current collection name
- The =onChangeCollectionName= and =onCancelCollectionNameChange= properties
  reference the component's methods


We'll implement the ~CollectionRenameForm~ component [[*Creating the ~CollectionRenameForm~ Component][later in this chapter]].

{{{subheading(The ~setCollectionName()~ Method)}}}

#+CINDEX:@code{setCollectionName()} method
Now let's take a closer look at the ~setCollectionName~ method.

#+NAME:CollectionControls setCollectionName method
#+CAPTION:The ~setCollectionName()~ Method of ~CollectionList~
#+BEGIN_SRC js
    setCollectionName: function (name) {
        this.setState({
            name: name,
            isEditingName: false
        });
    },

#+END_SRC

The ~setCollectionName()~ method updates the collection's name and hides a form
to edit the collection name by updating the component's state.  We'll call this
method when the user submits a new collection name.

{{{subheading(The ~toggleCollectionName()~ Method)}}}

#+CINDEX:@code{toggleEditCollectionName()} method
Now, let's take a look at the ~toggleEditCollectionName()~ method.

#+NAME:CollectionControls toggleEditCollectionName method
#+CAPTION:The ~toggleEditCollectionName()~ Method
#+BEGIN_SRC js
toggleEditCollectionName: function () {
    this.setState({
        isEditingName: !this.state.isEditingName
    });
},

#+END_SRC

#+CINDEX:@code{isEditingName} property
#+CINDEX:@key{Rename collection} button
#+CINDEX:@key{Cancel} button
It shows or hides the collection's name editing form by setting the
=isEditingName= property to the opposite of its current Boolean value using the
=!= operator.  We'll call this method when the user clicks on the {{{key(Rename
collection)}}} or {{{key(Cancel)}}} buttons, that is, show or hide the
collection name change form.

#+CINDEX:collection controls
If the ~CollectionControls~ component state's property
=this.state.isEditingName= is set to =false=, then it returns collection
controls.  [[CollectionControls render method]].

#+CINDEX:@file{Header} component
#+CINDEX:@file{CollectionExportForm} component
#+CINDEX:@code{getHeaderText()} method
We wrap the ~Header~ component, two ~Button~ components, and the
~CollectionExportForm~ component in a ~<div>~ element.  You're already familiar
with a ~Header~ component from the [[Header component][previous chapter]].  It receives a =text=
property that references a string.  However, in this case, we do not directly
pass a string, but rather a call to the ~this.getHeaderText()~ method.

#+NAME:CollectionControls getHeaderText method
#+CAPTION[CollectionControls getHeaderText() Method]:The ~getHeaderText()~ Method of ~CollectionControls~ Component
#+BEGIN_SRC js :noweb tangle
getHeaderText: function () {
    var numberOfTweetsInCollection = this.props.numberOfTweetsInCollection;
    var text = numberOfTweetsInCollection;

    if (numberOfTweetsInCollection === 1) {
        text = text + ' tweet in your';
    } else {
        text = text + 'tweets in your';
    }

    <<getHeaderText return>>
},

#+END_SRC

#+CINDEX:tree of React elements
#+CINDEX:@code{numberOfTweetsInCollection} variable
#+CINDEX:@code{text} variable
This method generates a string for a header based on the number of tweets in
our collection.  The important feature of this method is that it returns not
only a string, but rather a tree of React elements that encapsulate that
string.  First, we create the ~numberOfTweetsInCollection~ variable.  It stores
a number of tweets in a collection.  We then create a ~text~ variable and
assign it a number of tweets in a collection.  At this point, the ~text~
variable stores an integer value.  Our next task is to concatenate the right
string to it based on what that integer value is:

- If ~numberOfTweetsInCollection~ is 1, then we need to concatenate ` tweet in
  your'
- Otherwise, we need to concatenate ` tweets in your'


Once the header string is created, then we return the following elements:

#+NAME:getHeaderText return
#+BEGIN_SRC js
return (
    <span>
        {text} <strong>{this.state.name}</strong> collection
    </span>
);

#+END_SRC

The final string encapsulated inside a ~<span>~ element consists of a value of
a ~text~ variable, a collection name, and the =collection= keyword.  For
example, run the following command:
: 1 tweet in your new collection.

Once this string is returned by the ~getHeaderText()~ method, it is then passed
as a property to a ~Header~ component.

*** The ~Button~ Controls

#+CINDEX:@file{Button} controls
#+CINDEX:@key{Rename collection} button
{{{subheading(The =Rename collection= Button)}}}

#+CINDEX:@code{toggleEditCollectionName} method
#+CINDEX:@code{handleClick} property
Our next collection control element in the ~CollectionControls~'s ~render()~
method is ~Button~.

#+NAME:CollectionControls render Rename Button component
#+CAPTION:Rendering the Rename ~Button~ Component
#+BEGIN_SRC js
<Button
     label="Rename collection"
     handleClick={this.toggleEditCollectionName}
/>

#+END_SRC

#+CINDEX:@code{toggleEditCollectionName} method
#+CINDEX:@code{handleClick} property
We pass the =Rename collection= string to its =label= property and the
~this.toggleEditCollectionName~ method to its =handleClick= property.  As a
result, this button will have the =Rename collection= label, and it will toggle
a form to change the collection name.

{{{subheading(The =Empty collection= Button)}}}

#+CINDEX:@code{Empty collection} @file{Button} component
#+CINDEX:tweets, remove all
#+CINDEX:remove all tweets
The next collection control element is our second ~Button~, =Empty collection=.
It will remove all the tweets from a collection.

#+NAME:CollectionControls render Empty Button component
#+CAPTION:Rendering the Empty ~Button~ Component
#+BEGIN_SRC js
<Button
     label="Empty collection"
     handleClick={this.props.onRemoveAllTweetsFromCollection}
/>
#+END_SRC

{{{subheading(The =CollectionExportForm= Button)}}}

#+CINDEX:@file{CollectionExportForm} component, rendering to
Our final collection control element is =CollectionExportForm=.

#+NAME:CollectionControls render Export component
#+CAPTION:Rendering the ~ExportForm~ Component
#+BEGIN_SRC js
<CollectionExportForm htmlMarkup={this.props.htmlMarkup} />
#+END_SRC

#+CINDEX:HTML markup string
It receives an HTML markup string that represents our collection, and it will
render a button.  We'll create this component [[*Creating the ~CollectionExportForm~ Component][later in this chapter]].

Now, when we understand what the ~CollectionControls~ component will render,
let's take a closer look at its child components.

** Creating the ~CollectionRenameForm~ Component

First, let's create the
~<dir>/snapterest/source/components/CollectionRenameForm.react.js~ file:

#+CINDEX:@file{CollectionRenameForm} component
#+NAME:CollectionRenameForm Component
#+CAPTION:The ~CollectionRenameForm~ Component
#+HEADER: :noweb tangle :mkdirp yes
#+BEGIN_SRC js :tangle snapterest/source/componentsCollectionRenameForm.react.js
var React = require('react');
var ReactDOM = require('react-dom');
var Header = require('./Header.react');
var Button = require('./Button.react');

var inputStyle = {
    marginRight: '5px'
};

var CollectionRenameForm = React.createClass({

    <<CollectionRenameForm getInitialState method>>
    <<CollectionRenameForm setInputValue method>>
    <<CollectionRenameForm handleInputValueChange method>>
    <<CollectionRenameForm handleFormSubmit method>>
    <<CollectionRenameForm handleFormCancel method>>
    <<CollectionRenameForm componentDidMount method>>
    <<CollectionRenameForm render method>>
});

module.exports = CollectionRenameForm;
#+END_SRC

*** CollectionRenameForm ~render()~ Method

#+CINDEX:@code{render()} method of @file{CollectionRenameForm} component
This component renders a form to change the collection name:

#+NAME:CollectionRenameForm render method
#+CAPTION[CollectionRenameForm render() Method]:The ~render()~ Method of ~CollectionRenameForm~ Component
#+BEGIN_SRC js
render: function () {
    return (
        <form
            className="form-inline"
            onSubmit={this.handleSubmit}
        />

            <Header text="Collection name:" />

            <div className="form-group">
                <input
                    className="form-control"
                    style={inputStyle}
                    onChange={this.handleInputValueChange}
                    value={this.state.inputValue}
                    ref="collectionName"
                />
            </div>
    );
}
#+END_SRC

#+CINDEX:@code{form} element of @file{CollectionRenameForm} component
The ~<form>~ element wraps four elements, which are as follows:

- One ~Header~ component
- One ~<input>~ element
- Two ~Button~ components


#+CINDEX:@file{Header} component of @file{CollectionRenameForm} component
#+CINDEX:Bootstrap framework
#+CINDEX:styling
The ~Header~ component renders the ='Collection name:'= string.  The ~<input>~
element is wrapped inside a ~<div>~ element with a =className= property set to
=form-group=.  This name is part of the [[Bootstrap][Bootstrap framework]] that we discussed
in Chapter 4.  It's used for layout and styling and it's not part of our React
application's logic.

#+CINDEX:@code{<input>} element of @file{CollectionRenameForm} component
The ~<input>~ element has quite a few properties.

- The =className= property is set to =form-control=.  It is another class name,
  which is part of the Bootstrap framework.  We will use this for styling
  purposes.
- In addition, we apply our own style to this =input= element using the =style=
  property that references the =inputStyle= object with a single style rule:
  =marginRight=.
- The =value= property is set to a current value stored in the component's
  state, ~this.state.inputValue~.
- The =onChange= property references a ~this.handleInputValueChange~ method
  that is an ~onChange~ event handler.
- =ref= is a special React property that you can attach to any component that
  is returned by a ~render()~ method.  It allows you to refer to that component
  outside a ~render()~ method.  Shortly, we'll see an example of this.


#+CINDEX:@code{ref} property
#+CINDEX:@code{value} property, changing
Focus on the last three properties: =value=, =onChange=, and =ref=.  The
=value= property is set to the component state's property, and the only way to
change that value is to update its state.  On the other hand, we know that a
user can interact with an input field and change its value.  Will this behavior
apply to our component?  No.  Whenever a user types, our input field's value
won't change.  This is because a component is in control of ~<input>~, not a
user.  In our ~CollectionRenameForm~ component, the value of the ~<input>~
always reflects the value of ~this.state.inputValue~ property, regardless of
what the user types.  The user is not in control, but the
~CollectionRenameForm~ component is.

#+CINDEX:user input, reacting to
#+CINDEX:reacting to user input
Then how can we make sure that our input field reacts to a user input?  We need
to listen to a user input, and update the state of the ~CollectionRenameForm~
component, which in turn will re-render the input field with an updated value.
Doing so on every inputer's ~change~ event will make our input look like it
works as usual, and the user can freely change its value.

#+CINDEX:@code{onChange} property
#+CINDEX:@file{handleInputValueChange()} method
For this, we provide our ~<input>~ element with the =onChange= property that
references the component's ~this.handleInputValueChange~ method:

#+NAME:CollectionRenameForm handleInputValueChange method
#+CAPTION[CollectionRenameForm handleInputValueChange() Method]:handleInputValueChange Method
#+BEGIN_SRC js
handleInputValueChange: function (event) {
    var inputValue = event.target.value
    this.setInputValue(inputValue);
},

#+END_SRC

#+CINDEX:@file{SyntheticEvent}
#+CINDEX:event handlers
#+CINDEX:@code{handleInputValueChange()} method
#+CINDEX:@code{value} property
#+CINDEX:@code{setInputValue()} method
As we discussed in Chapter 3, React passes instances of [[SyntheticEvent][~SyntheticEvent~]] to
event handlers.  The ~handleInputValueChange()~ method receives an =event=
object with a =target= property that has a =value= property.  This =value=
property stores a string that a user has typed in our input field.  We pass
that string into our ~this.setInputValue()~ method:

#+NAME:CollectionRenameForm setInputValue method
#+CAPTION[CollectionRenameForm setInputValue]:The ~setInputValue()~ Method of ~CollectionRenameForm~ Component
#+BEGIN_SRC js
setInputValue: function (inputValue) {
    this.setState({
        inputValue: inputValue
    });
},

#+END_SRC

~setInputValue()~ is a convenience method that updates the component's state
with a new input value.  In turn, this update will re-render the ~<input>~
element with an updated value.

What is the initial input's value when the ~CollectionRenameForm~ component is
mounted?  Let's take a look at this:

#+CINDEX:@code{getInitialState()} method
#+NAME:CollectionRenameForm getInitialState method
#+CAPTION[CollectionRenameForm getInitialState() Method]:The ~getInitialState()~ Method of ~CollectionRenameForm~ Component
#+BEGIN_SRC js
getInitialState: function () {
    return ({
        inputValue: this.props.name
    });
},

#+END_SRC

We pass the collection's name from a parent component, and we use it to set our
initial input value.

After we mount this component, we want to set focus on the input field so that
the user can start editing the collection's name straightaway.  We know that
once a component is inserted into the DOM, React calls its
~componentDidMount()~ method.  This method is our best opportunity to set
focus:

#+CINDEX:@code{componentDidMount()} method
#+NAME:CollectionRenameForm componentDidMount method
#+CAPTION[CollectionRenameForm componentDidMount() Method]:The ~componentDidMount()~ Method of ~CollectionRenameForm~ Component
#+BEGIN_SRC js
componentDidMount: function () {
    this.refs.collectionName.focus();
},

#+END_SRC

#+CINDEX:@code{focus()} function
To do this, we get our input element and call ~focus()~ function on it.

#+CINDEX:@code{refs} object
#+CINDEX:@code{refs.collectionName}
How can we reference an element inside the ~componentDidMount()~ method?  We
can use the =this.refs= object to refer to our ~input~ element.  Because we
provided our ~input~ element with a =ref= property, which is set to
=collectionName=, we can refer to it via ~this.refs.collectionName~.

#+CINDEX:form buttons
#+CINDEX:@code{Change} button
#+CINDEX:@code{Cancel} button
Finally, let's discuss our two form buttons:

- The ~Change~ button submits the form and changes the collection name
- The ~Cancel~ button submits the form but doesn't change the collection name


We'll start with a ~Change~ button.  When a user clicks on it, the
~this.handleFormSubmit()~ method is called:

#+CINDEX:@code{handleFormSubmit()} method
#+NAME:CollectionRenameForm handleFormSubmit method
#+CAPTION[CollectionRenameForm handleFormSubmit Method]:The ~handleFormSubmit()~ Method of ~CollectionRenameForm~ Component
#+BEGIN_SRC js
handleFormSubmit: function (event) {
    event.preventDefault();

    var collectionName = this.state.inputValue;
    this.props.onChangeCollectionName(collectionName);
},

#+END_SRC

#+CINDEX:@code{props.onChangeCollectionName()} method call
#+CINDEX:@code{onChangeCollectionName()} method
#+CINDEX:@file{CollectionControls} component
We cancel the ~submit~ event, then get the collection name from the component's
state, and pass it to the ~this.props.onChangeCollectionName()~ method call.
The ~onChangeCollectionName()~ method is passed by a parent
~CollectionControls~ component.  Calling this method will change our
collection's name.

Now let's discuss our second form button.

#+CINDEX:@code{handleFormCancel()} method
When a user clicks on it, the ~this.handleFormCancel()~ method is called:

#+NAME:CollectionRenameForm handleFormCancel method
#+CAPTION[CollectionRenameForm handleFormCancel() Method]:The ~handleFormCancel()~ Method of ~CollectionRenameForm~ Component
#+BEGIN_SRC js
handleFormCancel: function (event) {
    event.preventDefault();

    var collectionName = this.props.name;
    this.setInputValue(collectionName);
    this.props.onCancelCollectionNameChange();
},

#+END_SRC

#+CINDEX:@code{props.onCancelCollectionNameChange()} method
#+CINDEX:@code{onCancelCollectionNameChange()} method
#+CINDEX:@code{setInputValue()} method
Once again, we cancel a ~submit~ event, then get the original collection name
that is passed as a property by a parent ~CollectionControls~ component, and
pass it to our ~this.setInputValue()~ method.  Then, we call the
~this.props.onCancelCollectionNameChange()~ method that hides the collection
controls.

That's our ~CollectionRenameForm~ component.  Next, let's create our ~Button~
component that we reused twice in our ~CollectionRenameForm~ Component.

** Creating the ~Button~ Component

** Creating the ~CollectionExportForm~ Component

** Summary

* 8. Test Your React Application With Jest

** TODO Install Jest 0.4

- See [[https://github.com/fedosejev/react-essentials/blob/master/updates.md#chapter-8-page-6][Errata]]
  : npm install --save-dev jest-cli@^0.4

* 9. Supercharge Your React Architecture With Flux

* 10. Prepare Your React Application for Painless Maintenance with Flux

** TODO Fix Tweet commands

- See [[https://github.com/fedosejev/react-essentials/blob/master/updates.md#chapter-10-page-29][Errata]]
  Use these:
  : <Tweet tweet={this.props.tweet} onImageClick={this.props.onAddTweetToCollection} />
  : <Tweet tweet={this.props.tweet} onImageClick={this.addTweetToCollection} />
* React.js
:PROPERTIES:
:APPENDIX: t
:END:

A JavaScript library for building user interfaces.

- [[https://reactjs.org/][React.js Home]]

* Flux
:PROPERTIES:
:APPENDIX: t
:END:

{{{heading(APPLICATION ARCHITECTURE FOR BUILDING USER INTERFACES)}}}

{{{subheading(An application architecture for React utilizing a unidirectional data flow.)}}}

Flux is the application architecture that Facebook uses for building
client-side web applications. It complements React's composable view components
by utilizing a unidirectional data flow. It's more of a pattern rather than a
formal framework, and you can start using Flux immediately without a lot of new
code.

- [[https://facebook.github.io/flux/][Flux Home]]
- [[https://github.com/facebook/flux][Flux Github Home]]
- [[https://facebook.github.io/flux/docs/overview.html][Flux Docs]]
- [[https://facebook.github.io/flux/docs/videos.html#content][Flux Videos]]

** Getting Started

Start by looking through the guides and examples on Github. For more resources
and API docs check out [[https://facebook.github.io/flux][facebook.github.io/flux]].

#+NAME:flux-diagram.png
#+CAPTION:Flux Diagram
[[file:img/flux-diagram-white-background-25.png]]

** How Flux works

For more information on how Flux works check out the [[https://github.com/facebook/flux/blob/master/examples/flux-concepts][Flux Concepts]] guide, or
the [[https://facebook.github.io/flux/docs/in-depth-overview.html#content][In Depth Overview]].

** Flux Concepts

#+CINDEX:Flux concepts
#+CINDEX:concepts of Flux
These are the important high-level concepts and principles you should know
about when writing applications that use Flux.

{{{heading(Overview)}}}

#+CINDEX:Flux overview
#+CINDEX:overview of Flux
Flux is a pattern for managing data flow in your application. The most
important concept is that /data flows in one direction/.  As we go through this
guide we'll talk about the different pieces of a Flux application and show how
they form /unidirectional cycles/ that data can flow through.

{{{subheading(Flux Parts)}}}

- Dispatcher

- Store

- Action

- View

*** Dispatcher

#+CINDEX:Dispatcher
#+CINDEX:actions
#+CINDEX:stores
#+CINDEX:register store with dispatcher
#+CINDEX:singleton dispatcher
The {{{dfn(dispatcher)}}} receives actions and dispatches them to stores that
have registered with the dispatcher.  Every store will receive every action.
There should be only one singleton dispatcher in each application.

Example:

1. User types in title for a todo and hits enter.
2. The view captures this event and dispatches an "add-todo" action containing
   the title of the todo.
3. *Every store* will then receive this action.

*** Store

#+CINDEX:store
#+CINDEX:store, register with dispatcher
#+CINDEX:register, store with dispatcher
#+CINDEX:action
#+CINDEX:mutate data
#+CINDEX:setters
#+CINDEX:getters
#+CINDEX:@samp{change} event
A store is what holds the data of an application. Stores will register with the
application's dispatcher so that they can receive actions.  The data in a store
must only be mutated by responding to an action. There should not be any public
setters on a store, only getters.  Stores decide what actions they want to
respond to.  Every time a store's data changes it must emit a
{{{samp(change)}}} event.  There should be many stores in each application.

Examples:

1. Store receives an "add-todo" action.
2. It decides it is relevant and adds the todo to the list of things that need
   to be done today.
3. The store updates its data and then emits a "change" event.

*** Actions

#+CINDEX:actions
#+CINDEX:@samp{type} field
Actions define the internal API of your application.  They capture the ways in
which anything might interact with your application.  They are simple objects
that have a {{{samp(type)}}} field and some data.

Actions should be semantic and descriptive of the action taking place.  They
should not describe implementation details of that action. Use
{{{samp(delete-user)}}} rather than breaking it up into
{{{samp(delete-user-id)}}}, {{{samp(clear-user-data)}}},
{{{samp(refresh-credentials)}}} (or however the process works).  Remember that
all stores will receive the action and can know they need to clear the data or
refresh credentials by handling the same {{{samp(delete-user)}}} action.

Examples:

1. When a user clicks "delete" on a completed todo a single "delete-todo"
   action is dispatched:

   #+BEGIN_SRC js
  {
    type: 'delete-todo',
    todoID: '1234',
  }
   #+END_SRC

*** Views

#+CINDEX:views
#+CINDEX:subscribe to change events, view
#+CINDEX:actions, dispatched from views
Data from stores is displayed in views.  Views can use whatever framework you
want (In most examples here we will use React).  When a view uses data from a
store it must also subscribe to change events from that store.  Then when the
store emits a change the view can get the new data and re-render.  If a
component ever uses a store and does not subscribe to it then there is likely a
subtle bug waiting to be found.  Actions are typically dispatched from views as
the user interacts with parts of the application's interface.

Example:

1. The main view subscribes to the TodoStore.
2. It accesses a list of the Todos and renders them in a readable format for
   the user to interact with.
3. When a user types in the title of a new Todo and hits enter the view tells
   the Dispatcher to dispatch an action.
4. All stores receive the dispatched action.
5. The TodoStore handles the action and adds another Todo to its internal data
   structure, then emits a "change" event.
6. The main view is listening for the "change" event. It gets the event, gets
   new data from the TodoStore, and then re-renders the list of Todos in the
   user interface.

*** Flow of data

We can piece the parts of Flux above into a diagram describing how data flows
through the system.

1. Views send actions to the dispatcher.
2. The dispatcher sends actions to every store.
3. Stores send data to the views.

#+NAME:flow.png
#+CAPTION:Views get data from the stores.
[[file:img/flux-simple-f8-diagram-with-client-action-1300w-50.png]]

*** Next steps

You can start coding with the [[todo-example][flux-todomvc]] example, or head back to check out
the full list of [[*Examples][example topics]].
** Requirements

{{{subheading{EventEmitter}

#+CINDEX:EventEmitter, Flux
Flux is more of a pattern than a framework, and does not have any hard
dependencies.  However, we often use [[https://nodejs.org/api/events.html#events_class_events_eventemitter][EventEmitter]] as a basis for Stores and
[[https://github.com/facebook/react][React]] for our Views.

{{{subheading(Dispatcher)}}}

#+CINDEX:Dispatcher, Flux
The one piece of Flux not readily available elsewhere is the =Dispatcher=.
This module, along with some other utilities, is available here to complete
your Flux toolbox.

** Installing Flux

#+CINDEX:Flux, install
#+CINDEX:install Flux
#+CINDEX:@code{Flux.Dispatcher}
Flux is available as an [[https://www.npmjs.org/package/flux][npm module]], so you can add it to your ~package.json~
file or run {{{command(npm install flux)}}}. The dispatcher will be available
as ~Flux.Dispatcher~ and can be required like this:
: const Dispatcher = require('flux').Dispatcher;

  #+CINDEX:dispatcher API
- Take a look at the [[https://facebook.github.io/flux/docs/dispatcher.html#content][dispatcher API and some examples]].

** Building Flux from a Cloned Repo

Clone the repo and navigate into the resulting flux directory. Then run
{{{command(npm install)}}}.

#+CINDEX:Gulp, Flux
#+CINDEX:build process, Flux
This will run Gulp-based build tasks automatically and produce the file
~Flux.js~, which you can then require as a module.

#+CINDEX:Dispatcher
You could then require the Dispatcher like so:
: const Dispatcher = require('path/to/this/directory/Flux').Dispatcher;

The build process also produces de-sugared versions of the =Dispatcher= and
=invariant= modules in a ~lib~ directory, and you can require those modules
directly, copying them into whatever directory is most convenient for you. The
flux-todomvc and flux-chat example applications both do this.

** Examples

https://github.com/facebook/flux/tree/master/examples

This directory contains examples that should help get you started with
Flux. They are listed in the order you should complete them.

- [[https://github.com/facebook/flux/blob/master/examples/flux-concepts][Basic concepts (no code)]]

  These are the important high-level concepts and principles you should know
  about when writing applications that use Flux.

- [[https://github.com/facebook/flux/blob/master/examples/flux-todomvc][Start coding here]]

  <<todo-example>>This example is where you should start. It walks you through
  creating the classic TodoMVC application using a simple Flux implementation.

- [[https://github.com/facebook/flux/blob/master/examples/flux-jest][Unit Testing Stores]]

  Being able to unit test stores is critical. This example shows you how to
  write tests for the TodoMVC stores we created in an earlier example.

- [[https://github.com/facebook/flux/blob/master/examples/flux-flow][Static typing]]

  This is a very simple example that highlights how to set up Flux and Flow in
  the same project. Flow is a static-type checking tool that will help catch
  errors in your code statically. It complements Flux well since it supports
  refining the action based on a type string.

- [[https://github.com/facebook/flux/blob/master/examples/flux-logging][Add logging to Flux apps]]

  Taking advantage of the fact that a store gets every action makes it easy to
  add logging to a Flux application. Check out this quick example where we add
  a logger store to the TodoMVC app we created in an earlier example.

- [[https://github.com/facebook/flux/blob/master/examples/flux-jest-container][Unit Testing Containers]]

  Testing the container logic that connects stores to views can be tricky. This
  example shows you how to create some utilities to help mock out store data in
  order to write these kinds of tests effectively.

- [[https://github.com/facebook/flux/blob/master/examples/flux-async][Flux with async requests]]

  This is an advanced example. It pulls a lot of the concepts from previous
  examples into a single application. This implements TodoMVC where the data is
  persisted and requested through a simple server. The server simulates delays
  and errors. In the example we will handle things like optimistic updates,
  loading states, and failing API requests.

** In-Depth Overview

- [[https://facebook.github.io/flux/docs/in-depth-overview.html#content][Link]]
- [[https://youtu.be/nYkdrAPrdcw?list=PLb0IAmt7-GS188xDYE-u1ShQmFFGbrk0v][Video]]

** Reference

*** Disptacher Docs

#+CINDEX:Dispatcher
Dispatcher is used to broadcast payloads to registered callbacks. This is
different from generic pub-sub systems in two ways:

- Callbacks are not subscribed to particular events. Every payload is
  dispatched to every registered callback.
- Callbacks can be deferred in whole or part until other callbacks have been
  executed.


Check out [[https://github.com/facebook/flux/blob/master/src/Dispatcher.js][Dispatcher.js]] for the source code.

  #+CINDEX:Dispatcher API
**** Dispatcher API

  #+CINDEX:@code{register()}
- ~register(function callback)~: string ::

     Registers a callback to be invoked with every dispatched payload. Returns
     a token that can be used with ~waitFor()~.

  #+CINDEX:@code{unregister()}
- ~unregister(string id)~: void ::

     Removes a callback based on its token.

  #+CINDEX:@code{waitFor()}
- ~waitFor(array<string> ids)~: void ::

     Waits for the callbacks specified to be invoked before continuing
     execution of the current callback. This method should only be used by a
     callback in response to a dispatched payload.

  #+CINDEX:@code{dispatch()}
- ~dispatch(object payload)~: void ::

     Dispatches a payload to all registered callbacks.

  #+CINDEX:@code{isDispatching()}
- ~isDispatching()~: boolean ::

      Is this Dispatcher currently dispatching.

**** Example

#+CINDEX:flight destination form
For example, consider this hypothetical flight destination form, which selects
a default city when a country is selected:

#+BEGIN_SRC js -n
var flightDispatcher = new Dispatcher();

// Keeps track of which country is selected
var CountryStore = {country: null};

// Keeps track of which city is selected
var CityStore = {city: null};

// Keeps track of the base flight price of the selected city
var FlightPriceStore = {price: null};
#+END_SRC

When a user changes the selected city, we dispatch the payload:

#+BEGIN_SRC js +n
flightDispatcher.dispatch({
  actionType: 'city-update',
  selectedCity: 'paris'
});
#+END_SRC

This payload is digested by CityStore:

#+BEGIN_SRC js +n
flightDispatcher.register(function(payload) {
  if (payload.actionType === 'city-update') {
    CityStore.city = payload.selectedCity;
  }
});
#+END_SRC

When the user selects a country, we dispatch the payload:

#+BEGIN_SRC js +n
flightDispatcher.dispatch({
  actionType: 'country-update',
  selectedCountry: 'australia'
});
#+END_SRC

This payload is digested by both stores:

#+BEGIN_SRC js +n
CountryStore.dispatchToken = flightDispatcher.register(function(payload) {
  if (payload.actionType === 'country-update') {
    CountryStore.country = payload.selectedCountry;
  }
});
#+END_SRC

When the callback to update ~CountryStore~ is registered, we save a reference
to the returned token. Using this token with ~waitFor()~, we can guarantee that
~CountryStore~ is updated before the callback that updates ~CityStore~ needs to
query its data.

#+BEGIN_SRC js +n
CityStore.dispatchToken = flightDispatcher.register(function(payload) {
  if (payload.actionType === 'country-update') {
    // `CountryStore.country` may not be updated.
    flightDispatcher.waitFor([CountryStore.dispatchToken]);
    // `CountryStore.country` is now guaranteed to be updated.

    // Select the default city for the new country
    CityStore.city = getDefaultCityForCountry(CountryStore.country);
  }
});
#+END_SRC

The usage of ~waitFor()~ can be chained, for example:

#+BEGIN_SRC js +n
FlightPriceStore.dispatchToken =
  flightDispatcher.register(function(payload) {
    switch (payload.actionType) {
      case 'country-update':
      case 'city-update':
        flightDispatcher.waitFor([CityStore.dispatchToken]);
        FlightPriceStore.price =
          getFlightPriceStore(CountryStore.country, CityStore.city);
        break;
  }
});
#+END_SRC

The ~country-update~ payload will be guaranteed to invoke the stores' registered
callbacks in order: ~CountryStore~, ~CityStore~, then ~FlightPriceStore~.

*** Flux Utils

#+CINDEX:Flux utils
#+CINDEX:utility classes, Flux
#+CINDEX:class, Flux utility
We have also provided some basic utility classes to help get you started with
Flux.  These base classes are a solid foundation for a simple Flux application,
but they are *not* a feature-complete framework that will handle all use cases.
There are many other great Flux frameworks out there if these utilities do not
fulfill your needs.

{{{heading(Usage)}}}

There are four[sic] main classes exposed in Flux Utils:

1. Store
2. ReduceStore
3. Container

These base classes can be imported from ~flux/utils~ like this:

#+NAME:flux-utils.js
#+CAPTION:Importing base classes from ~flux/utils~
#+BEGIN_SRC js
import {ReduceStore} from 'flux/utils';

class CounterStore extends ReduceStore<number> {
  getInitialState(): number {
    return 0;
  }

  reduce(state: number, action: Object): number {
    switch (action.type) {
      case 'increment':
        return state + 1;

      case 'square':
        return state * state;

      default:
        return state;
    }
  }
}
#+END_SRC

* Twitter and Snapkite

** Twitter Docs

- [[https://developer.twitter.com/en/docs.html][Twitter Docs]]

** Twitter Tutorial on Consuming Streaming Data

- [[https://developer.twitter.com/en/docs/tutorials/consuming-streaming-data][Consuming streaming data]]

** Snapkite Engine

Snapkite Engine gives you filtered stream of photos posted publicly on Twitter.

- [[https://github.com/Snapkite][Snapkite on Github]]
- [[https://github.com/snapkite/snapkite-engine][Snapkite Engine on Github]]

It can do 2 (either or both) things with those photos:

1. Send them to a socket connection and allow all your clients to receive them
   in real-time.
2. Store them in MongoDB and retrieve later with [[https://github.com/snapkite/snapkite-api-server.git][Snapkite API Server]] or your
   own application.

{{{heading(Examples)}}}

- [[http://snapterest.com/][Snapterest.com]]
- [[http://map.snapkite.com/][Map.Snapkite.com]]

*** Installation Instructions

- https://github.com/snapkite/snapkite-engine#install


1. git clone https://github.com/Snapkite/snapkite-engine.git
2. cd snapkite-engine
3. npm install
4. cp example.config.json config.json
5. Add your Twitter API keys to config.json
6. Change default MongoDB config in config.json

*** Configure Instructions

- https://github.com/snapkite/snapkite-engine#configure


You can configure Snapkite Engine by editing config.json.

- ~application.pushTweets~ :: Send tweets to client?  Expects true or false.

- ~application.storeTweets~ :: Store tweets in a MongoDB collection?  Expects
     true or false.

- ~application.pushKeywords~ :: Send keyword stats to client?  Expects true or
     false.

- ~application.trackKeywords~ ::
     Which keywords should we ask Twitter to track for us?  Expects a string of
     keywords separated by a single whitespace or comma, e.g.: =selfie london= or
     =selfie,london=

     Read this for more details:
     https://dev.twitter.com/streaming/overview/request-parameters#track

- ~application.excludeKeywords~ ::
     Which keywords should be ignored?  Expects a string of keywords separated
     by a comma, e.g.: =exclude,these,keywords=

- ~application.filters~ ::
     List of Snapkite filters that this application should use. You can find
     the list of all available filters [[https://github.com/snapkite/snapkite-engine/tree/master/filters/README.md][here]].

- ~application.twitter.api~ ::
     Twitter API keys that Twitter provides you with. You can find them [[https://apps.twitter.com/][here]].

- ~application.database~ :: MongoDB connection configuration.

- ~application.socket~ :: Socket configuration.

*** Snapkite Filters

[[https://github.com/snapkite/snapkite-filters/blob/master/README.md][Everything you need to know]] about Snapkite filters.

*** MongoDB

https://github.com/snapkite/snapkite-engine#mongodb

* Babelify
:PROPERTIES:
:APPENDIX: t
:END:

[[https://github.com/babel/babel][Babel browserify]] transform.

- [[https://www.npmjs.com/package/babelify][Babelify on npm]]
- [[https://babeljs.io/][Babel]]
- [[https://github.com/babel/babel][Babel on Github]]

Babel is a compiler for writing next generation JavaScript. 

** Installation

{{{heading(Babel 7)}}}

: $ npm install --save-dev babelify @babel/core

{{{heading(Babel 6)}}}

: $ npm install --save-dev babelify@6 babel-core

** Usage

{{{heading(Presets and Plugins)}}}

NOTE: Presets and plugins need to be installed as separate modules. For the
examples to work, you'd need to also install ~@babel/preset-env~ and
~@babel/preset-react~:

{{{subheading(CLI)}}}

: $ browserify script.js -o bundle.js -t [ babelify \
: --presets [ @babel/preset-env @babel/preset-react ] \
: --plugins [ @babel/plugin-transform-class-properties ] ]

{{{subheading(Node)}}}

#+BEGIN_SRC js
var fs = require("fs");
var browserify = require("browserify");
browserify("./script.js")
  .transform("babelify", {presets: ["@babel/preset-env", "@babel/preset-react"]})
  .bundle()
  .pipe(fs.createWriteStream("bundle.js"));
#+END_SRC

{{{subheading(Options)}}}

See the babel docs for the complete list of [[http://babeljs.io/docs/usage/options/][options]].

* Listings
:PROPERTIES:
:APPENDIX: t
:END:
#+TEXINFO:@listoffloats Listing

* Figures
:PROPERTIES:
:APPENDIX: t
:END:
#+TEXINFO:@listoffloats Figure
* Index
  :PROPERTIES:
  :INDEX:    cp
  :END:
* COPYING
  :PROPERTIES:
  :COPYING:  t
  :END:
  {{{TITLE}}} by {{{AUTHOR}}}
  \copy 2015 Packt Publishing

#+BEGIN_QUOTE
A fast-paced guide to designing and building scalable and maintainable web apps
with React.js
#+END_QUOTE

Outline prepared by WLHarvey \copy {{{date(%F)}}}
* MACROS                                                           :noexport:
#+MACRO:heading @@texinfo:@heading @@$1
#+MACRO:subheading @@texinfo:@subheading @@$1
#+MACRO:tiauthor @@texinfo:@author @@$1
#+MACRO:key @@texinfo:@key{@@$1@@texinfo:}@@
#+MACRO:file @@texinfo:@file{@@$1@@texinfo:}@@
#+MACRO:command @@texinfo:@command{@@$1@@texinfo:}@@
#+MACRO:samp @@texinfo:@samp{@@$1@@texinfo:}@@
#+MACRO:cite @@texinfo:@cite{@@$1@@texinfo:}@@
#+MACRO:noindent @@texinfo:@noindent @@
#+MACRO:dfn @@texinfo:@dfn{@@$1@@texinfo:}@@
* EXPORT SETTINGS                                                  :noexport:
#+PROPERTY: header-args :eval never
#+OPTIONS: h:4
#+TEXINFO_CLASS: info
#+TEXINFO_HEADER:
#+TEXINFO_POST_HEADER:
#+TEXINFO_DIR_CATEGORY: React
#+TEXINFO_DIR_TITLE: React.js Essentials
#+TEXINFO_DIR_DESC:Fast-paced guide to designing web apps with React.js
