# -*- mode: org; fill-column: 79; -*-

#+TITLE: React.js Essentials
#+SUBTITLE: A fast-paced guide to designing and building scalable and maintainable web apps with React.js
#+AUTHOR: Artemij Fedosejev
#+DATE: <2019-03-06 Wed 19:24>

#+TEXINFO: @insertcopying

* Preface
:PROPERTIES:
:UNNUMBERED: t
:END:

#+CINDEX:imperative code
#+CINDEX:declarative code
#+CINDEX:jQuery
#+CINDEX:modular
#+CINDEX:scalable
The Web is different.  The way we build for the Web is different.  Faced by the
challenges of dealing with unmaintainable /imperative code/ produced by jQuery
we had to look for new ways of managing the complexity of modern user
interfaces.  We needed a new user interface library that would help us build
/declarative/, /modular/, fast and /scalable/ frontend applications.

{{{subheading(React.js --- User Interface Library)}}}

#+CINDEX:user interface library
#+CINDEX:Facebook
#+CINDEX:DOM
#+CINDEX:data flow, organize
Meet React.js --- a JavaScript user interface library developed by Facebook.
It brings profound ideas on how to work with the DOM, organize your
application's data flow, and think about user interface elements as individual
components.  And yet, it's only a user interface library that makes no
assumptions about the rest of your technology stack.

{{{subheading(With Flux)}}}

#+CINDEX:Flux
#+CINDEX:frontend architecture
Combined with Flux, we get a powerful frontend architecture that makes sense
not only to experienced developers, but also those who are just starting their
frontend journey.

** From the Author

  #+CINDEX:Fedosejev, Artemij
- [[https://github.com/fedosejev][Artemij Fedosejev]]


  #+CINDEX:React Essentials Github
- [[https://github.com/fedosejev/react-essentials][Author's React Essentials Github Page]]

  #+CINDEX:tutorials, React
- [[https://react.tips][React Tutorials]]

- [[https://react.tips/from-react-to-flux-to-redux/][From React.js To Flux To Redux]]

  If you want to really understand what's the difference between building web
  apps with React only, or with React and Flux, or with React and Redux, then
  check the four examples that I've prepared for you.

  #+CINDEX:shopping list app examples
  #+CINDEX:examples, shopping list app
  They all implement exactly the same Shopping List app, but most importantly -
  they highlight the difference in how you approach building web apps using
  different tools.

    #+CINDEX:ES5 JavaScript
    #+CINDEX:JavaScript ES5
  - Built with React.js and JavaScript ES5

    In this [[https://github.com/fedosejev/shopping-list-react][example]], I am using only React.js without Flux or Redux to build
    the entire app. And I am using the good old JavaScript that all know and
    love (or hate?): version ECMAScript 5.

    This example is the best place for you to start if you're not familiar with
    Flux or Redux at all. It helps you to understand why we need Flux or
    Redux. You will feel strange when storing application state (the shopping
    list itself) in React components, knowing that React should only be
    responsible for knowing how to render the user interface.

    #+CINDEX:ES2015, JavaScript
    #+CINDEX:JavaScript ES2015
  - Built with React.js and JavaScript ES2015

    The industry uses a newer version of JavaScript today: ECMAScript 2015. It
    brings new syntax and React takes advantage of that syntax.

    If you want to see how to transition from tradition ES5 syntax to newer
    ES2015 syntax in the context of React app, then this [[https://github.com/fedosejev/shopping-list-react-es2015][example]] is perfect for
    you. Feel free to compare it with the the previous one (ES5 version).

    #+CINDEX:Flux with ES5
    #+CINDEX:ES5 and Flux
  - Built with React.js and Flux and JavaScript ES5

    If React feels familiar to you and you can build simple apps with it then
    you most likely faced a problem of accessing application state from
    different React components. It's not a straight forward task! And it feels
    awkward, because we know that React is a UI library, and if we follow the
    separation of concerns principle, then it's clear to us that we shouldn't
    store application state in React components!

    Where do we store it then? That's why you might need to introduce Flux
    architecture to your React application.

    This [[https://github.com/fedosejev/shopping-list-react-flux][example]] is a perfect introduction to the Flux architecture, because
    you're building exactly the same app, but now you're clearly separating
    your UI logic from your application state logic.

    #+CINDEX:Redux with ES2015
    #+CINDEX:ES2015 and Redux
  - Built with React.js and Redux and JavaScript ES2015

    Flux is a great start for understanding how data flows in your React
    application. Redux takes it to the next level by building on top of ideas
    from Flux and introducing new important concepts that allow you to build
    really scalable and robust React apps.  See [[https://github.com/fedosejev/shopping-list-react-redux][example]].

** What this Book Covers

*** Chapter 1 Installing Powerful Tools

- Goals
- Tools
- Structure for project

*** Chapter 2 Create Your First React Element

- Install React
- Virtual DOM
- React Element
- Create and render a React element
- with native JavaScript
- JSX syntax
- Create React Elements using JSX

*** Chapter 3 Create Your First React Component

- React components
- Difference between stateless and stateful React components
- Creates both kinds

*** Chapter 4 Make Your React Components Reactive

- How to solve problems with React
- Plan a React application
- Create a React component that encapsulates entire app
- Relationship between parent and child React components

*** Chapter 5 Use Your React Components with Another Library

- How to use third party JavaScript libraries
- React component's lifecycle
- How to use mounting methods
- Create new components for project

*** Chapter 6 Update Your React Components

- React component lifecycle's updating mnethods
- CSS styles in JavaScript
- Validate and set default component properties

*** Chapter 7 Build Complex React Components

- Building more complex React components
- Implement different React components
- Put them together into one coherent and functional app

*** Chapter 8 Test Your React Application with Jest

- Unit testing
- Write and run unit tests with Jest
- Test React components
- Test suites, specs, expectations, and matchers

*** Chapter 9 Supercharge Your React Architecture with Flux

- Improve the architecture of React application
- Flux architecture
- Role of dispatcher, stores, and and action creators

*** Chapter 10 Prepare Your React Application for Painless Maintenance with Flux

- Decouple concerns in a React app with Flux
- Refactor React app to allow painless maintainability

** What You Need for this Book

1. Latest version of a modern web browser, e.g.,
   - [[https://www.google.com/chrome/browser][Google Chrome]]
   - [[https://www.mozilla.org/en-US/firefox/new/][Mozilla Firefox]]

2. Git

3. Node.js

4. npm

5. Code editor, e.g.
   - [[http://www.sublimetext.com][Sublime Text]]
   - [[https://atom.io][Atom]]
   - [[http://brackets.io][Brackets]]
   - [[https://code.visualstudio.com][Visual Studio Code]]
   - Your choice

** Who this Book is For

This book is intended for frontend developers who want to build scalable and
maintainable user interfaces for the Web.  Some core knowledge of JavaScript,
HTML, and CSS is the only thing you need to know to start benefiting.  If you
have previous experience with jQuery or Angular.js, then you will benefit from
understanding how React.js is different and how to take advantage of
integrating different libraries with it.

** Conventions

** Reader Feedback

** Downloading the Example Code

https://github.com/fedosejev/react-essentials

** Errata

https://wwwpacktpub.com/books/content/support

enter the name of the book in the search field.

** ES6 Version

A refactoring of the project described in "React.js Essentials" using ES6
rather than just ES5.  This is merely a refactoring of the project described in
"React.js Essentials" (by Artemij Fedosejev) that uses ES6 features (e.g.,
class, import, etc.) rather than just ES5. (It also leaves out the console.log
spam.)

- From [[https://github.com/jmrog/react-essentials-es6-version][Jason Roger]]

* 1. Installing Powerful Tools for your Project

#+CINDEX:Kettering, Charles
#+BEGIN_QUOTE
My interest is in the future because I am going to spend the rest of my life
there.
{{{tiauthor(Charles F. Kettering)}}}
#+END_QUOTE

#+CINDEX:spaghetti code
#+CINDEX:mental model, spaghetti
This brilliant inventor has left software engineers with the single most
important piece of advice way before we even started thinking about how to
write software.  Yet, half a century later, we're still figuring out why we end
up with spaghetti code or the ``spaghetti mental model.''

{{{heading(Writing Softward for the Future)}}}

#+CINDEX:mental model
#+CINDEX:complexity remains the same
What does it mean to ``write software for the future, today''?  It boils down
to creating a simple mental model that doesn't change, no matter how big your
project becomes over time.  When the size of your project grows, the complexity
always stays the same.  This mental model is your blueprint, and once you
understand it you will understand how your whole piece of software works.

{{{heading(Facebook Releases React in 2013)}}}

#+CINDEX:Facebook
#+CINDEX:Occhino, Tom
In 2013, Facebook released React---an open source JavaScript library for
building user interfaces.  You can read more about it at
http://facebook.github.io/react/.  In early 2015, Tom Occhino from Facebook
summarized what makes React so powerful:

{{{heading(Declarative vs Imperative Programming)}}}

#+BEGIN_QUOTE
React wraps an imperative API with a declarative one.  React's real power lies
in how it makes you to write code.
{{{tiauthor(Tom Occhino)}}}
#+END_QUOTE

#+CINDEX:declarative style
#+CINDEX:imperative style
#+CINDEX:DOM API
#+CINDEX:jQuery
A declarative style of programming results in less code.  It tells a computer
what to do without specifying how, while an imperative style of programming
describes how to do it.  JavaScript's call to the DOM API is an example of
imperative programming.  jQuery is another such example.

{{{heading(React is Good for Small Projects)}}}

#+CINDEX:small React project
#+CINDEX:shopping list
It works for small projects too; here is an example of a [[http://fedosejev.github.io/shopping-list-react][shopping list]] build
with React.  React is one of the best JavaScript libraries used for building
user interfaces that is available for developers today.

{{{heading(The Goal of this Book)}}}

#+CINDEX:goal
#+CINDEX:fundamental principles of React
#+CINDEX:React's fundamental principles
#+CINDEX:principles, fundamental
#+CINDEX:project, real-time web application
Goal is for you to understand the fundamental principles of React.  To achieve
this, you will be introduced to one React component at a time, explained it,
and shown how you can apply it.  Step by step, you'll build a real-time web
application, raise important questions along the way, and discuss solutions
that React provides us with.

{{{heading(Flux)}}}

#+CINDEX:Flux
#+CINDEX:mental model
You will learn about [[*Flux][Flux]], which implements a unidirectional flow of data.
Together with Flux and React, you'll create a predictable and manageable code
base that you will be able to expand by adding new features, without scaling
its complexity.  The mental model of how your web application works will stay
the same, no matter how many new features you add later.

** Approaching our Project

The best motivation for learning new technology is a project that excites you
and that you can't wait to build.  In this book the author wants you to build a
project that feels like a breath of fresh air.  A project which you most likely
wouldn't build in your day-to-day work.  It has to be a fun endeavor, which not
only educates you but also satisfies your curiosity and stretches your
imagination.  This project shouldn't be a time consuming long-term commitment
for you either.

#+CINDEX:Snapterest
#+CINDEX:project Snapterest
#+CINDEX:Twitter
#+CINDEX:Pinterest
#+CINDEX:website functionality
Enter *Snapterest*---a web application that allows you to discover and collect
public photos posted on Twitter.  Think of it as Pinterest with the only source
of pictures being Twitter.  We will implement a fully functional website with
the following core functionalities:

- Receiving and displaying tweets in real time

- Adding and removing tweets to / from a collection

- Reviewing collected tweets

- Exporting a collection of tweets as an HTML snippet that you can share


#+CINDEX:tools
When you start working on a new project, the very first thing that you do is
get your tools ready.  For this project, we will be using a number of tools.

** DONE Installing Node.js and npm
:todo:
:task: Check for Jest and Node.js compatibility currently
:end:

  #+CINDEX:Node.js, installation
- [[https://nodejs.org][Node.js]] ::

     #+CINDEX:JavaScript
     #+CINDEX:Node.js benefits
     #+CINDEX:event-driven
     #+CINDEX:non-blocking
     #+CINDEX:real-time
     is a platform that allows us to write server-side applications with a
     client-side language: JavaScript.  The real benefit of Node.js is that it
     uses an /event-driven/, /non-blocking I-O/ model, which is perfect for
     building /data-intensive/, /real-time/ applications.  It means that, with
     Node.js, we should be able to handle an incoming stream of tweets and
     process them as soon as they arrive.


- [[https://nodejs.org/en/][Node.js Home]]

<<install-node.js>>{{{heading(Install Node.js)}}}

#+CINDEX:install Node.js
#+CINDEX:Jest
Install Node.js.  We'll be using version =v0.10.40= because, at the time
of writing this book, that's the latest version of Node.js that Jest
supports.[fn::The current versions of Node.js as of the publication of
this document ({{{date}}}) are =10.15.2 LTS= and =11.10.1 Current=.  The
current version of Jest is =24.1=, which appears to work with the current
version of Node.js and React.]

#+CINDEX:distribution, Node.js
#+CINDEX:installation package, Node.js
- Go to http://nodejs.org/dist/v0.10.40/ and download the installation package
  for your OS:

    #+CINDEX:OS X
  - [[http://nodejs.org/dist/v0.10.40/node-v0.10.40-darwin-x64.tar.gz][OS X]]:[fn::Created 09-Jul-2015 21:30] ::

      Run it and follow the installation steps that Node.js will prompt you with.
      Test for successful installation:
      : $ node -v
      : v0.10.40


{{{subheading(npm Should Be Installed with Node.js)}}}
  #+CINDEX:npm, installation
- [[http://www.npmjs.com][npm]][fn::Current npm version is =6.8.0= as of {{{date}}}] ::

  #+CINDEX:package manager, npm
  is a package manager that manages Node.js modules.  It is shipped with
     Node.js, so it was installed by the previous step.  To test:
     : $ npm -v
     : 1.4.28

** Installing Git

#+CINDEX:Git
#+CINDEX:install Git
#+CINDEX:getting started with Git
<<install-git>>We'll be using Git to install Node.js modules.  Visit:
- [[https://git-scm.com/book/en/v2/Getting-Started-Installing-Git][{{{cite(1.5 Getting Started - Installing Git)}}}]]

{{{noindent}}}and follow the installation instructions for your OS.

** Getting Data from the Twitter Streaming API

#+CINDEX:Twitter Streaming API
#+CINDEX:Streaming API, Twitter
#+CINDEX:tweets, receive public
#+CINDEX:JSON format, tweets
<<twitter-streaming>>The data for our React application will come from Twitter.
Twitter has the *Streaming API* that anyone can plug into to start receiving an
endless flow of public tweets in the JSON format.

To start using the Twitter Streaming API, you'll need to perform the following
steps:

{{{subheading(Create a Twitter Account and App)}}}

   #+CINDEX:Twitter account, create
1. <<create-twitter-account>>Create a Twitter account.  For this, go to
   https://twitter.com and sign up; or sign in if you already have an account.

   #+CINDEX:Twitter app, create
2. <<create-twitter-app>>Create a new Twitter App by navigating to
   https://developer.twitter.com/en/apps[fn::https://apps.twitter.com has been
   sunsetted] and click on {{{key(Create New App)}}}.  You will need to fill in
   the *Application Details* form, agree with the *Developer Agreement*, and
   click on *Create your Twitter application*.  Now you should see your
   application's page.


{{{subheading(Get Twitter Keys)}}}

<<twitter-keys>>Switch to the *Keys and Access Tokens* tab.  In the
*Applications Settings* section of this page, you'll find two vital pieces of
information:

   #+CINDEX:Twitter API keys
   #+CINDEX:keys, Twiter API
1. Consumer Key (API Key)

2. Consumer Secret (API Secret)


Take a note of them.

{{{subheading(Create a Twitter Access Token)}}}

#+CINDEX:access token, Twiter API
<<twitter-token>>Now generate an /access token/.  On the same page, you'll see
*Your Access Token* section that is empty.  Click on {{{key(Create my access
token)}}}.  It creates two pieces of information:

1. Access Token

2. Access Token Secret


Take a note of them too.  An access token is unique to you and you should not
share it with anyone.  Keep it private.

** Filtering Data with Snapkite Engine
:PROPERTIES:
:CUSTOM_ID: Snapkite Engine
:END:

#+CINDEX:filter
We need to filter the stream of data from the Twitter Streaming API into a
meaningful set of tweets that we can display and interact with.

#+CINDEX:Twitter Streaming API documentation
You should first take a quick look at the [[https://dev.twitter.com/streaming][Twitter Streaming API documentation]].
In particular take a look at the page that describes how to [[https://dev.twitter.com/streaming/reference/post/statuses/filter][filter]] an incoming
stream.  Twitter provides very few filters that we can apply, so we need to
find a way to filter that stream of data even further.

{{{heading(Snapkite Engine)}}}

#+CINDEX:Snapkite Engine Node.js application
#+CINDEX:Twitter Streaming API, filter engine for
#+CINDEX:tweets, filtered
#+CINDEX:web socket connection for filtered tweets
There is a Node.js application just for this.  It's called [[https://github.com/snapkite/snapkite-engine][Snapkite Engine]].
It connects to the Twitter Streaming API, filters it using the available
filters and according to the rules that you define, and outputs the filtered
tweets to a web socket connection.  Our React app can listen to the events on
that socket connection and process tweets as they arrive.

*** Install the Snapkite Engine
:PROPERTIES:
:CUSTOM_ID: install Snapkite Engine
:END:

   #+CINDEX:Snapkite Engine, install
1. Clone the Snapkite Engine repository into a directory of your choice:
   : cd <dir>
   : git clone https://github.com/snapkite/snapkite-engine.git
   This should create the ~<dir>/snapkite-engine~ folder.

   #+CINDEX:Node-Gyp module
2. <<install-node-gyp>>Now install the other node modules that
   ~snapkite-engine~ depends on.  One of them is the ~node-gyp~ module.  Also
   install other tools that are listed on [[https://github.com/TooTallNate/node-gyp#installation][node-gyp installation]].

3. Once you install them, you're ready to install the ~node-gyp~ command:
   : npm install --global node-gyp

4. Navigate to the ~<dir>/snapkite-engine~ directory to install the Node.js
   modules that Snapkite Engine depends on:
   : cd <dir>/snapkite-engine/
   : npm install

   #+CINDEX:Snapkite Engine, configure
   #+CINDEX:configure Snapkite Engine
5. <<configure-Snapkite>>Configure Snapkite Engine.  Assuming you are in the
   ~<dir>/snapkite-engine/~ directory, copy the ~./example.config.json~ file to
   ~./config.json~ by the following command:
   : cp example.config.json config.json

   #+CINDEX:@file{config.json}
6. <<config.json>>Open ~config.json~ in your editor to edit the configuration
   properties.

      #+CINDEX:@code{trackKeywords}
   - <<trackKeywords>>~trackKeywords~ ::
        This is where we will tell what keywords we want to track.  If we want
        to track the keyword =my=, then set it as follows:
        : "trackKeywords": "my"

   #+CINDEX:Twitter Streaming API keys, access token
   #+CINDEX:keys, Twitter Streaming API
   #+CINDEX:access token, Twitter Streaming API
7. <<Twitter-keys-and-token>>Set our Twitter Streaming API keys.  Set:
   - ~consumerKey~
   - ~consumerSecret~
   - ~accessTokenKey~
   - ~accessTokenSecret~
     #+CINDEX:Snapkite Engine documentation
     #+CINDEX:documentation, Snapkite Engine
   - other properties can be set to their defaults[fn::check out the Snapkite
     Engine [[https://github.com/snapkite/snapkite-engine][documentation]]]

   #+CINDEX:Snapkite Filter module
   #+CINDEX:Snapkite Filters, list
8. <<install-Snapkite-filters>>Install Snapkite Filters.  =Snapkite Filter= is
   a Node.js module that validates tweets according to a set of rules.  There
   are a number of Snapkite Filters out there, and we can use any combination
   of them to filter our stream of tweets as we like.  You can find a list of
   all available Snapkite Filters at
   https://github.com/snapkite/snapkite-filters.

   #+CINDEX:Snapkite Filters, used in project
   In our application, we'll use the following Snapkite Filters:

     #+CINDEX:@code{is-possibly-sensitive} Snapkite filter
   - <<is-possibly-sensitive-filter>>Is Possibly Sensitive ::
        https://github.com/snapkite/snapkite-filter-is-possibly-sensitive

     #+CINDEX:@code{has-mobile-photo} Snapkite filter
   - <<has-mobile-photo-filter>>Has Mobile Photo ::
        https://github.com/snapkite/snapkite-filter-has-mobile-photo

     #+CINDEX:@code{is-retweet} Snapkite filter
   - <<is-retweet-filter>>Is Retweet ::
        https://github.com/snapkite/snapkite-filter-is-retweet

     #+CINDEX:@code{has-text} Snapkite filter
   - <<has-text-filter>>Has Text ::
        https://github.com/snapkite/snapkite-filter-has-text


   #+CINDEX:install Snapkite filters
   #+CINDEX:Snapkite filters, install
   Install them.  Navigate to the ~<dir>/snapkite-engine/filters/~ directory:
   : cd <dir>/snapkite-engine/filters/
   Clone all Snapkite Filters by running these commands:
   : git clone https://github.com/snapkite/snapkite-filter-is-possibly-sensitive
   : git clone https://github.com/snapkite/snapkite-filter-has-mobile-photo
   : git clone https://github.com/snapkite/snapkite-filter-is-retweet
   : git clone https://github.com/snapkite/snapkite-filter-has-text

   #+CINDEX:Snapkite filters, configure
   #+CINDEX:configure Snapkite filters
9. <<configure-Snapkite-filters>>Configure them.  In order to do so, you need
   to create a configuration file for each Snapkite Filter in JSON format and
   define some properties in it.  Each Snapkite Filter comes with an example
   configuration file that we can duplicate and edit as needed.

   While in the ~<dir>/snapkite-engine/filters/~ directory, run the following
   commands:

   : cp snapkite-filter-is-possibly-sensitive/example.config.json
   : snapkite-filter-is-possibly-sensitive/config.json

   : cp snapkite-filter-has-mobile-photo/example.config.json
   : snapkite/snapkite-filter-has-mobile-photo/config.json

   : cp snapkite-filter-is-retweet/example.config.json
   : snapkite-filter-is-retweet/config.json

   : cp snapkite-filter-has-text/example.config.json
   : snapkite-filter-has-text/config.json

   We don't need to change any of the default settings in these ~config.json~
   files, as they are already configured to fit our purposes.

10. <<Snapkite-config.json>>Tell Snapkite Engine which Snapkite Filters it
    should use.  Open the ~<dir>/snapkite-engine/config.json~ file in a text
    editor and look for this:
    : "filters" : []

    Now replace that with the following:

    #+NAME:config.json
    #+CAPTION:Snapkite Engine ~config.json~
    #+BEGIN_SRC js :eval never
    "filters": [
        "snapkite-filter-is-possibly-sensitive",
        "snapkite-filter-has-mobile-photo",
        "snapkite-filter-is-retweet",
        "snapkite-filter-has-text"
    ]
    #+END_SRC


#+CINDEX:Snapkite Engine, test run
<<test-Snapkite-Engine>>With that you have successfully installed Snapkite
Engine with a number of Snapkite Filters.  Now let's check if we can run it.
Navigate to ~<dir>/snapkite-engine~ and run:
: $ npm start
: [Snapkite][Socket] Listening on port 3000

You should see no error messages.  If you do and you are not sure how to fix
them, go to https://github.com/fedosejev/react-essentials/issues, create a new
issue and copy/paste the error message that you get.

** Creating the Project Structure

#+CINDEX:project structure, create
#+CINDEX:structure organization
#+CINDEX:organization of project
#+CINDEX:architecture of project
Now create our project structure.  Organizing source files is not a simple
task.  A well-thought-out project structure organization helps us understand
the underlying architecture of our application.

{{{subheading(Root Project Directory)}}}

#+CINDEX:root project directory
#+CINDEX:@file{snapterest} directory
<<create-root-project-directory>>Start by creating a /root project directory/
named {{{file(snapterest/)}}} inside a directory of your choice:
{{{file(<dir>/snapterest/)}}}.  Inside it create two other directories:

  #+CINDEX:@file{source} directory
  #+CINDEX:@file{components} directory
  #+CINDEX:directories, @file{source}, @file{components}
- <<source-directory>>{{{file(<dir>/snapterest/source/)}}} ::
     store our source JavaScript files
     - {{{file(components/)}}} ::
       create this directory inside the {{{file(source/)}}} directory

  #+CINDEX:@file{build} directory
  #+CINDEX:directory, @file{build}
- <<build-directory>>{{{file(<dir>/snapterest/build/)}}} ::
     store compiled JavaScript files and an HTML file


{{{subheading(Populate the project structure with an application file)}}}

   #+CINDEX:@file{app.js}
   #+CINDEX:application file, @file{app.js}
- <<application-file>>{{{file(app.js)}}} ::

     place the main application file in the ~source/~ directory.  This file
     will be the entry point to our application.  Leave it empty for now.

** Building the Project

   #+CINDEX:DRY
   #+CINDEX:code reuse
- *DRY*: *Don't Repeat Yourself* ::

     One of the core principles in software development --- code reuse: The
     best code is the one that you don't need to write.  One of the goals in
     this project is to write as little code as possible.  React helps us
     achieve this goal.

#+CINDEX:declarative programming style
#+CINDEX:programming style, declarative
#+CINDEX:code reuse
When it comes to not writing code, we can apply the following strategies:

- Writing our code in a /declarative/ programming style
- Reusing the code written by someone else


#+CINDEX:jQuery
We'll be using both these techniques.  The first one is covered by React
itself.  React leaves us no choice but to write our JavaScript code in a
/declarative/ style.  This means that instead of telling our web browser how to
do what we want (like we do in jQuery), we just tell it what we want it to do
and the how part is explained by React.

#+CINDEX:npm
Node.js and npm cover the second technique.  There are over a hundred thousand
different Node.js applications available for us to use.  This means that most
likely someone has already implemented the functionality that our application
depends on.

#+CINDEX:@command{npm install}
#+CINDEX:@file{package.json}
#+CINDEX:metadata, project
#+CINDEX:project metadata
The question is how do we know from where to get all these Node.js applications
that we want to reuse.  We can install them via the ~npm install
<package-name>~ command.  In the npm context, a Node.js application is called a
*package*, and each *npm package* has a ~package.json~ file that describes the
metadata associated with that package.[fn::[[https://docs.npmjs.com/files/package.json][package.json docs]]]

*** Create ~package.json~
:PROPERTIES:
:CUSTOM_ID: create package.json
:END:

#+CINDEX:package initialization
#+CINDEX:initialize a package
#+CINDEX:metadata file
#+CINDEX:@file{package.json}
#+CINDEX:@command{npm install}
Before we install our /dependency packages/, we will /initialize/ a *package*
for our own project.  Normally, ~package.json~ is only required when you want
to submit your package to the npm registry so that others can reuse your
Node.js application.  We're not going to build a Node.js application, and we're
not going to submit our project to npm.  ~package.json~ is technically only a
metadata file that the ~npm~ command understands, and as such, we can use it to
store a list of dependencies that our application requires.  Once we store a
list of dependencies in ~package.json~, we can easily install them anytime with
the ~npm install~ command; npm will figure out from where to get them
automatically.

#+CINDEX:@file{package.json} create
#+CINDEX:create @file{package.json}
How do we create the ~package.json~ file for our own application?  npm comes
with an interactive tool that asks us a bunch of questions and then, based on
our answers, creates ~package.json~ for our project.

#+CINDEX:@command{npm init}
#+CINDEX:initialize @file{package.json}
<<run-npm-init>>From the ~<dir>/snapterest/~ directory, run:
: npm init
Accept all the defaults.

#+CINDEX:modular application
#+CINDEX:modules
#+CINDEX:Node.js modules
Now we are ready to install other Node.js applications that we are going to
reuse.  An application that is built of multiple individual applications is
called /modular/ whereas individual applications are called /modules/.  This is
what we will call our Node.js dependencies from now on: *Node.js modules*

*** About Reusing Node.js Modules

#+CINDEX:build development process
#+CINDEX:build script
#+CINDEX:packaging
<<building>>There will be a step in our development process called /building/.
During this step, our build script will take our source files and all our
Node.js dependency packages, and transform them into a single file that web
browsers can successfully execute.  The most important part of this building
process is called /packaging/.  But what do we need to package and why?  We're
not creating a Node.js application, but yet we're talking about reusing Node.js
modules.  Does this mean that we'll be reusing Node.js modules in a non-Node.js
application?  Is that even possible?  Yes, there is a way of doing that.

**** Installing Browserify

#+CINDEX:Browserify
#+CINDEX:bundling, Browserify
<<Browserify>>*Browserify* is a tool used for bundling all your dependency
files together in such a way that you can reuse Node.js modules in client-side
JavaScript applications.  You can learn more about it at [[http://browserify.org][Browserify]].

#+CINDEX:install Browserify
To install Browserify, run the following command from inside the
~<dir>/snapterest/~ directory:
: npm install --save-dev browserify

Browserify will allow us to use Node.js modules in our client-side JavaScript
applications.  It will be a part of our build process.

*** Building with Gulp.js

#+CINDEX:Gulp.js
<<Gulp.js>>Today, any modern client-side application represents a mix of many
concerns that are addressed individually by various technologies.  Addressing
each concern individually simplifies the overall process of managing the
project's complexity.  The downside of this approach is that at some point in
your project, you need to put together all the individual parts into one
coherent application.  Developers have something called build-tools that
assemble their projects from individual modules.  This process is called the
/build/ process and, depending on the size and complexity of your project, it
can take anywhere from milliseconds to hours to build.

{{{subheading(Installing Gulp.js and ~gulpfile.js~)}}}

The Node.js ecosystem has a great tool for automating our build process,
*Gulp.js*.  You can learn more about it at [[http://gulpjs.com][Gulp]].

#+CINDEX:install Gulp.js
#+CINDEX:Gulp.js installation
Let's install it.
: npm install --save-dev gulp
: npm install --global gulp-cli

{{{subheading(An Example ~gulpfile.js~)}}}

#+CINDEX:gulpfile
#+CINDEX:@file{gulpfile.js}
<<example-gulpfile.js>>What is a /gulpfile/?  It's a file where we describe our
build process.  Create ~gulpfile.js~ in your ~<dir>/snapterest/~ directory and
add the following content to it[fn::from
https://gulpjs.com/docs/en/getting-started/quick-start#create-a-gulpfile]:

#+NAME:example-gulpfile.js
#+CAPTION:Example of a ~gulpfile.js~
#+BEGIN_SRC js :eval never
function defaultTask(cb) {
  console.log("I am about to learn the essentials of React.js");
  cb();
}

exports.default = defaultTask;
#+END_SRC

#+CINDEX:@command{gulp} command
<<gulp-command>>Now if you run the ~gulp~ command, you will see output that
looks like this:

#+BEGIN_EXAMPLE
Using gulpfile ~/<dir>/snapterest/gulpfile.js
Starting 'default'...
I am about to learn the essentials of React.js
Finished 'default' after 62 us
#+END_EXAMPLE

*** Creating a Default Gulp Task

#+CINDEX:@samp{default} task
#+CINDEX:Gulp.js build system
#+CINDEX:Browserify
<<default-gulp-task>>By default, when you run ~gulp~, it executes a task called
=default=.  You now have a working Gulp.js build system.  Let's create a task
tht will package our source and dependency modules using Browserify.

#+CINDEX:@file{gulpfile.js}
<<default-gulpfile.js>>Replace the contents of your ~gulpfile.js~ with the
following code:

#+NAME:default-task-gulpfile.js
#+CAPTION:A default ~gulpfile.js~ that will package source and dependency modules using Browserify
#+BEGIN_SRC js :eval never
var gulp = require('gulp');
var browserify = require('browserify');
var babelify = require('babelify');
var source = require('vinyl-source-stream');

gulp.task('default', function(cb) {
    return browserify('./source/app.js')
        .transform(babelify)
        .bundle()
        .pipe(source('snapterest.js'))
        .pipe(gulp.dest('./build/'));
        cb();
});
#+END_SRC

**** Install Babelify

#+CINDEX:Babelify
#+CINDEX:install @file{babelify} module
<<install-Browserify>>We have already installed the ~browserify~ module, so now
let's install ([[*Install Babelify][install Babelify]]) the [[https://www.npmjs.com/package/babelify][~babelify~ module]][fn::See [[https://github.com/fedosejev/react-essentials/blob/master/updates.md#chapter-1-page-14][errata]]; The book uses babelify
version 6.  Version 7 introduced some [[https://github.com/fedosejev/react-essentials#i-get-syntaxerror-appjs-unexpected-token-when-i-run-gulp-command-what-should-i-do][breaking changes]];  to use Version 7, see
[[https://github.com/fedosejev/react-essentials/issues/21#issuecomment-160316774][this comment]].][[fn::The current version is now =10.0.0=.]:

: npm install --save-dev babelify@^6.2.0

#+CINDEX:JSX
The ~babelify~ module allows us to write the JSX syntax that we'll introduce in
the next chapter.

**** Install Vinyl-Source-Stream Module

#+CINDEX:Vinyl Source Stream module
#+CINDEX:Browserify and Gulp
<<install-Vinyl-Source-Stream>>Why do we need the [[https://www.npmjs.com/package/vinyl-source-stream][~vinyl-source-stream~ module]]?
It allows us to use Browserify and Gulp together.  For more details on why this
works, go to [[https://www.npmjs.com/package/vinyl-source-stream][Vinyl-Source-Stream]].  Let's install the ~vinyl-source-stream~
dependency module:

: npm install --save-dev vinyl-source-stream

**** Test Default Gulp Task

#+CINDEX:gulp default task
<<test-gulp-default-task>>Now we're ready to test our ~default~ task.  Run:

#+BEGIN_EXAMPLE
$ gulp
[19:06:03] Using gulpfile ~/Dev/Programming/WebDev/React/ReactJS-Essentials/snapterest/gulpfile.js
[19:06:03] Starting 'default'...
[19:06:03] Finished 'default' after 40 ms
#+END_EXAMPLE

#+CINDEX:@file{build} directory
#+CINDEX:@file{snapterest.js} file
The project's ~<dir>/snapterest/build/~ directory now has the ~snapterest.js~
file with some code already inside it---that's our (empty) JavaScript
application with some Node.js modules that are ready to run in a web browser.

*** Creating a Web Page
:PROPERTIES:
:CUSTOM_ID: create web page
:END:

#+CINDEX:@file{index.html} file
#+CINDEX:@file{snapterest.js} file
#+CINDEX:@file{snapterest/build} directory
<<create-index.html>>All that is left to do is to create the ~index.html~ file
with a link to our ~snapterest.js~ script.  Create the ~index.html~ file in the
~<dir>/snapterest/build/~ directory.  Add the following HTML markup to it:

#+NAME:index.html
#+CAPTION:Project Snapterest ~index.html~
#+BEGIN_SRC html :eval never :tangle snapterest/build/index.html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="x-ua-compatible" content="ie-edge, chrome=1" />
    <title>Snapterest</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
  </head>
  <body>
    <div id="react-application">
      I am about to learn the essentials of React.js.
    </div>
    <script src="./snapterest.js"></script>
  </body>
</html>
#+END_SRC

<<open-index.html>>Open ~<dir>/snapterest/build/index.html~ in a web browser.
You should see the following text: ``I am about to learn the essentials of
React.js.''

** Summary

- We learned why we should use React to build user interfaces for modern web
  applications.

- We discussed the project that we'll be building in this book.

- We installed all the right tools

- We created the project's structure.

*** Installation and Configuration Steps

- [[install-node.js][Node.js and npm]]
- [[install-git][Git]]
- [[twitter-streaming][Twitter Streaming API]]
  + [[create-twitter-account][Create a Twitter Account]]
  + [[create-twitter-app][Twitter App]]
    - [[twitter-keys][Keys]]
    - [[twitter-token][Token]]
- [[#Snapkite Engine][Snapkite Engine]]
  + [[#install Snapkite Engine][Install Snapkite Engine]]
  + [[install-node-gyp][Install =node-gyp= module and command]]
  + [[configure-Snapkite][Configure Snapkite Engine]]
    - [[config.json][~config.json~]]
    - [[trackKeywords][~trackKeywords~]]
    - [[Twitter-keys-and-token%0A][configure Twitter keys and access token]]
  + [[install-Snapkite-filters][Install Snapkite Filters]]
    - [[is-possibly-sensitive-filter][is possibly sensitive]]
    - [[has-mobile-photo-filter][has mobile photo]]
    - [[is-retweet-filter][is retweet]]
    - [[has-text-filter][has text]]
  + [[configure-Snapkite-filters][Configure Snapkite Filters]]
    - [[Snapkite-config.json][~config.json~]]
  + [[test-Snapkite-Engine][Test Snapkite Engine]]
- [[*Creating the Project Structure][Create Snapterest Project Structure]]
  - [[create-root-project-directory][create root project directory]]
    + [[source-directory][~source~ directory]]
    + [[build-directory][~build~ directory]]
    + [[application-file][~app.js~ file]]
    + [[#create package.json][~package.json~ file]]
      - [[run-npm-init][{{{command(npm init)}}}]]
- [[building][The Building Process]]
  + [[Browserify][Install Browserify]]
  + [[Gulp.js][Install Gulp.js]]
    - [[example-gulpfile.js][example ~gulpfile.js~]]
  + [[gulp-command][Run ~gulp~ command]]
    - [[default-gulp-task][default gulp task]]
    - [[default-gulpfile.js][default ~gulpfile.js~]]
  + [[install-Browserify][Install Browserify]]
  + [[install-Vinyl-Source-Stream][Install Vinyl-Source-Stream]]
  + [[test-gulp-default-task][Test Gulp Default Task]]
- [[#create web page][Create a Web Page]]
  + [[create-index.html][Create ~index.html~]]
  + [[open-index.html][Open ~index.html~]]

* 2. Create Your First React Element

Creating a simple web application today involves writing the HTML, CSS, and
JavaScript code.  The reason we use three different technologies is because we
want to separate three different concerns:

- Content (HTML)
- Styling (CSS)
- Logic (JavaScript)


#+CINDEX:Single Page Application (SPA)
#+CINDEX:SPA, Single Page Application
We don't think of a website as a collection of web pages anymore.  Instead, we
build web applications that might have only one web page, and that web page
does not represent the layout for out content---it represents a /container/ for
our web application.  Such a web application with a single web page is called a
{{{dfn(Single Page Application (SPA))}}}.

How do we represent the rest of the content in a SPA?  Surely, we need to
create an additional layout using HTML tags.  Otherwise, how does a web browser
know what to render?

These are valid questions.  Let's take a look at how it works.

  #+CINDEX:Document Object Model (DOM)
  #+CINDEX:DOM, Document Object Model
- Once you load your web page in a web browser, it creates a {{{dfn(Document
  Object Model (DOM))}}} of that web page.  A DOM represents your web page in a
  tree structure, and at this point, it reflects the structure of the layout
  that you created with only HTML tags.  This is what happens regardless of
  whether you're building a traditional web page or an SPA.  The difference
  between the two is what happens next.

- If you are building a traditional web page then you would finish creating
  your web page's layout.

  #+CINDEX:JavaScript DOM API
  #+CINDEX:DOM API, JavaScript
- On the other hand, if you are building a SPA, then you would need to start
  creating additional elements by manipulating the DOM with JavaScript.  A web
  browser provides you with the {{{dfn(JavaScript DOM API)}}} to do this.  You
  can learn more about it at:
  - [[https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model][Document Object Model]]

- However, manipulating (or mutating) the DOM with JavaScript has two issues:

     #+CINDEX:imperative programming style
     #+CINDEX:programming style, imperative
     #+CINDEX:style, imperative programming
  1. Your programming style will be /imperative/ if you decide to use the
     JavaScript DOM API directly.  This programming style leads to a code base
     that is harder to maintain.

     #+CINDEX:DOM mutations
  2. DOM mutations are slow because they cannot be optimized for speed, unlike
     other JavaScript code.

  React solves both these problems for us.

** Understanding the Virtual DOM

Why do we need to manipulate the DOM in the first place?  Because our web
applications are not static.  They have /state/ represented by the {{{dfn(user
interface (UI))}}} that a web browser renders, and that state can be changed
when an event occurs.  What kind of events are we talking about?  There are two
types of events that we're interested in:

#+ATTR_TEXINFO: :indic b
- User events :: When a user types, clicks, scrolls, resizes, and so on
- Server events :: When an application receives data or an error from the
                   server


#+CINDEX:syncing states
What happens while handling these events?  Usually, we update the data that our
application depends on, and that data represents a state of our data model.  In
turn, when a state of our data model changes, we might want to reflect this
change by updating a state of our UI.  Looks like what we want is a way of
syncing the two states: the UI state and the data model state.  We want one to
react to the changes in the other and vice versa.

#+CINDEX:two-way data binding
#+CINDEX:key-value observing (KVO)
#+CINDEX:KVO, key-value observing
#+CINDEX:Ember.js
#+CINDEX:Knockout
#+CINDEX:Backbone
#+CINDEX:iOS
#+CINDEX:Angular
#+CINDEX:dirty checking
One of the ways to sync your application's UI state with an underlying data
model's state is {{{dfn(two-way data binding)}}}.  There are different types of
two-way data binding.  One of them is {{{dfn(key-value observing (KVO))}}},
which is used in *Ember.js*, *Knockout*, *Backbone*, and *iOS*, among others.
Another one is dirty checking, which is used in *Angular*.

#+CINDEX:virtual DOM
#+CINDEX:reactive
Instead of two-way data binding, React offers a different solution called the
{{{dfn(virtual DOM)}}}.  The virtual DOM is a fast, in-memory representation of
the real DOM, and it's an abstraction that allows us to treat JavaScript and
DOM as if they were reactive.

Here is how it works:

1. Whenever the state of your data model changes, the virtual DOM and React
   will rerender your UI to a virtual DOM representation.

2. React then calculates the difference between the two virtual DOM
   representations: the previous virtual DOM representation that was computed
   before the data was changed and the current virtual DOM representation that
   was computed after the data was changed.  This difference between the two
   virtual DOM representations is what actually needs to be changed in the real
   DOM.

3. React updates only what needs to be updated in the real DOM.


The process of finding a difference between the two representations of the
virtual DOM and rerendering only the updated patches in a real DOM is fast.
Aslo, the best part is, as a React developer, that you don't need to worry
about what actually needs to be rerendered.,  React allows you to write your
code as if you were rerendering the entire DOM every time your application's
state changes.

You would like to learn more about the virtual DOM, the rationale behind it,
and how it can be compared to data binding, then watch this talk by Pete Hunt
from Facebook at https://www.youtube.com/watch?v=-DX3vJiqxm4.  See also [[https://www.youtube.com/watch?v=d7pyEDqBDeE][Tech
Talk: What is the Virtual DOM?]]

** Installing React

To start using the React library, we need to first install it.  I am going to
show you two ways of doing this: the simplest one and the one using the
{{{command(npm install)}}} command.

{{{heading(Using a <Script> Tag)}}}

The simplest way is to add the ~<script>~ tag to your
~/snapterest/build/index.html~ file.

- For the development version of React, add the following command:

  : <script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.0-beta3/react.js"></script>

- For the production version of React, add the following command:

  : script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.0-beta3/react.min.js"></script>


There is a difference between the two that we'll learn about in the later
chapters of this book.  For our project, we'll be using the development of
React.

At the time of this writing, the latest version of React library is
0.14.0-beta3.  Over time, React gets updated, so make sure you use the latest
version that is available to you, unless it introduces breaking changes that
are incompatible with the code samples provided in this book.  Visit
https://github.com/fedosejev/react-essentials to learn about any compatibility
issues between the codce samples and the latest version of React.

{{{heading(Importing React from npm)}}}

You learned about *Browserify* that allows us to import all the dependency
modules for our application using the ~require()~ function.  We'll be using
~require()~ to import the React library as well, which means that, instead of
adding a ~<script>~ tag to our ~index.html~, we'll be using the {{{command(npm
install)}}} to install React:

1. Navigate to the ~<dir>/snapterest/~ directory and run this command:

   : npm install --save react@0.14.8 react-dom@0.14.8

2. Then, open the ~<dir>/snapterest/source/app.js~ file in your text editor and
   import the React and ReactDOM libraries to the ~React~ and ~ReactDOM~
   variables, respectively:

   : var React = require('react');
   : var ReactDOM = require('react-dom');


The ~react~ package contains methods that are concerned with the key idea
behind React, that is, describing what you want to render in a declarative way.
On the other hand, the ~react-dom~ package offers methods that are responsible
for rendering to the DOM.  You can read more about why developers at Facebook,
think it's a good idea to separate the React library into two packages at
https://facebook.github.io/react/blog/2015/07/03/react-v0.14-beta-1.html#two-packages.

Now we're ready to start using the React library in our project.  Next, let's
create our first React Element.

** Creating React Elements with JavaScript

We'll start by familiarizing ourselves with a fundamental React terminology.
It will help us build a clear picture of what the React library is made of.
This terminology will most likely update over time, so keep an eye on the
official documentation at https://reactjs.org/docs/glossary.html.

Just like the DOM is a tree of nodes, React's virtual DOM is a tree of React
nodes.  One of the core types in React is called =ReactNode=.  It's a building
block for a virtual DOM, and it can be any one of these core types:

- =ReactElement=: ::

     This is the primary type in React.  It's a light, stateless, immutable,
     virtual representation of a DOM =Element=.

- =ReactText=: ::
                  This is a string or a number.  It represents textual content
                  and it's a virtual representation of a Text Node in the DOM.


=ReactElement='s and =ReactText='s are =ReactNode='s.  An array of
=ReactNode='s is called a =ReactFragment=.  You will see examples of all these
in this chapter.

** Example =ReactElement=

Let's start with an example of a =ReactElement=:

1. Add the following code to your ~<dir>/snapterest/source/app.js~ file:

   #+BEGIN_SRC js :eval never
   var reactElement = React.createElement('h1');
   ReactDOM.render(reactElement, document.getElementById('react-application'));
   #+END_SRC

2. Now your ~app.js~ file should look exactly like this:

   #+BEGIN_SRC js :eval never
   var React = require('react');
   var ReactDOM = require('react-dom');

   var reactElement = React.createElement('h1');
   ReactDOM.render(reactElement, document.getElementById('react-application'));
   #+END_SRC

3. Navigate to the ~<dir>/snapterest/~ directory and run Gulp's =default= task:

   #+BEGIN_EXAMPLE
   $ gulp
   [20:28:44] Using gulpfile <dir>/snapterest/gulpfile.js
   [20:28:44] Starting 'default'...
   [20:28:45] Finished 'default' after 988 ms
   #+END_EXAMPLE

4. Navigate to the ~<dir>/build/~ directory, and open ~index.html~ in a web
   browser.  You will see a blank web page.  Open *Developer Tools* in your web
   browser and inspect the HTML markup for your blank web page.  You should see
   this line among others:
   : <h1 data-reactid=".0"></h1>

   #+BEGIN_SRC html :eval never
   <html lang="en">
     <head>
       <meta charset="utf-8">
       <meta http-equiv="x-ua-compatible" content="ie-edge, chrome=1">
       <title>Snapterest</title>
       <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
     </head>
     <body>
        <div id="react-application">
          <h1 data-reactid=".0"></h1>
        </div>
        <script src="./snapterest.js"></script>
      </body>
    </html>
    #+END_SRC


We've just created your first React element.

** The Three Parameters of ~React.createElement()~

#+CINDEX:React object
#+CINDEX:@code{React.createElement()} method
#+CINDEX:parameters to @code{React.createElement()}
#+CINDEX:@code{type} parameter
#+CINDEX:@code{props} parameter
#+CINDEX:@code{children} parameter
The entry point to the React library is the =React= object.  This object has a
method called ~createElement()~ that takes three parameters:

1. =type=
2. =props=
3. =children=
: React.createElement(type, props, children);

Let's take a look at each parameter in more detail.

#+CINDEX:type parameter
*** The =type= Parameter
:PROPERTIES:
:CUSTOM_ID: createElement type parameter
:END:

The =type= parameter can be either a string or a ~ReactClass~:

- A string could be an HTML tag name such as `div', `p', `h1', and so on.
  React supports all the common HTML tags and attributes.  For a complete list
  of HTML tags and attributes supported by React, refer to:
  - [[https://reactjs.org/docs/dom-elements.html][DOM Elements]]

- A ~ReactClass~ is created via the ~React.createClass()~ method.  This will be
  introduced in more detail in [[#Chapter 3][Chapter 3]].


The =type= parameter describes how an HTML tag or a ~ReactClass~ is going to be
rendered.  In our example, we're rendering the ~h1~ HTML tag.

#+CINDEX:@code{props} parameter
*** The =props= Parameter
:PROPERTIES:
:CUSTOM_ID: props parameter
:END:

The =props= parameter is a JavaScript object passed from a parent element to a
child element (and not the other way around) with some properties that are
considered immutable, that is, those that should not be changed.

#+CINDEX:HTML attributes as @code{props}
While creating DOM elements with React, we can pass the =props= object with
properties that represent HTML attributes such as =class=, =style=, and so on.
For example, run the following commands:

#+BEGIN_SRC js :eval never
var React = require ('react');
var ReactDOM = require('react-dom');
var reactElement = React.createElement('h1', { className: 'header' });
ReactDOM.render(reactElement, document.getElementById('react-application');
#+END_SRC

The preceding code will create an ~h1~ HTML element with a =class= attribute
set to =header=:
: <h1 class="header" data-reactid=".0"></h1>

#+CINDEX:@code{className} attribute
Notice that we name our property =className= rather than =class=.  The reason
is that the =class= keyword is reserved in JavaScript.  If you use =class= as a
property name, it will be ignored by React, and a helpful warning message will
be printed on the web browser's console.:
: Warning: Unknown DOM property class.  Did you mean className?
: Use className instead.

#+CINDEX:@code{data-reactid=".0"} attribute
What is this =data-reactid=".0" attribute doing in the ~h1~ tag?  It is added
and used by React to track the DOM nodes; it might be removed in a future
version of React.[fn::It has been.]

#+CINDEX:@code{children} parameter
*** The =children= Parameter

#+CINDEX:child elements
#+CINDEX:@code{ReactNode}
The =children= parameter describes what child elements this element should
have, if any.  A child element can be any type of ~ReactNode~: a virtual DOM
element represented by a ~ReactElement~, a string or a number represented by
~ReactText~, or an array of other ~ReactNode~'s which is also called a
~ReactFragment~.

Here is an example:

#+BEGIN_SRC js :eval never :tangle snapterest/source/app.js
var React = require('react');
var ReactDOM = require('react-dom');
var reactElement = React.createElement('h1', { className: 'header' }, 'This is React.');
ReactDOM.render(reactElement, document.getElementById('react-application'));
#+END_SRC

#+NAME:ch2-ReactElement-children-param
#+CAPTION:Example of ~children~ Parameter with a ~ReactText~ Element
[[file:img/ch2-ReactElement-children-param-50.png]]

This code will create an ~h1~ HTML element with a =class= attribute and a text
node, {{{samp(This is React.)}}}:
: <h1 class="header" data-reactid=".0">This is React.</h1>

The ~h1~ tag is represented by a ~ReactElement~, while the {{{samp(This is
React.)}}} string is represented by a ~ReactText~.

*** The =children= Parameter with Multiple React Elements as Children

Next, create a React element with a number of other React elements as it's
children:

#+BEGIN_SRC js :eval never :tangle snapterest/source/app.js
var React = require('react');
var ReactDOM = require('react-dom');

var h1 = React.createElement('h1', { className: 'header', key: 'header' }, 'This is React.');
var p = React.createElement('p', { className: 'content', key: 'content' }, "And that's how it works.");
var reactFragment = [h1, p];
var section = React.createElement('section', { className: 'container' }, reactFragment);

ReactDOM.render(section, document.getElementById('react-application'));
#+END_SRC

#+NAME:ch2-ReactElement-children-param-section
#+CAPTION:The ~children~ Parameter with an Array of ReactElements
[[file:img/ch2-ReactElement-children-param-section-50.png]]

We've created three React elements: ~h1~, ~p~, and ~section~.  ~h1~ and ~p~
both have child text nodes, {{{samp(This is React.)}}} and {{{samp(And that's
how it works.)}}}, respectively.  The ~section~ has a child that is an array of
two ~ReactElement~'s, ~h1~ and ~p~, called ~reactFragment~.  This is also an
array of ~ReactNode~'s.  Each ~ReactElement~ in the ~reactFragment~ array must
have a =key= property that helps React to identify that ~ReactElement~.  As a
result, we get the following HTML markup:

#+BEGIN_SRC html :eval never
<section class="container" data-reactid=".0">
  <h1 class="header" data-reactid=".0.$header">This is React.</h1>
  <p class="content" data-reactid=".0.$content">And that's how it works.</p>
</section>
#+END_SRC

*** React's Factory Function ~React.CreateFactory()~

#+CINDEX:factory function
#+CINDEX:@code{React.createFactory()} method
Now we understand how to create React elements.  What if we wanted to create a
number of React elements of the same type?  Does it mean that we need to call
~React.createElement('type') over and over again for each element of the same
type?  We can, but we don't need to because React provides us with a factory
function called ~React.createFactory()~.  A {{{dfn(factory function)}}} is a
function that creates other functions.  This is exactly what
~React.createFactory('type')~ does: it creates a function that produces a
~ReactElement~ of a given type.

Consider the following example:

#+BEGIN_SRC js :eval never :tangle snapterest/source/app.js
var React = require('react');
var ReactDOM = require('react-dom');

var listItemElement1 = React.createElement('li', { className: 'item-1', key: 'item-1' }, 'Item 1');
var listItemElement2 = React.createElement('li', { className: 'item-2', key: 'item-2' }, 'Item 2');
var listItemElement3 = React.createElement('li', { className: 'item-3', key: 'item-3' }, 'Item 3');

var reactFragment = [ listItemElement1, listItemElement2, listItemElement3 ];
var listOfItems = React.createElement('u1', { className: 'list-of-items' }, reactFragment);

ReactDOM.render(listOfItems, document.getElementById('react-application'));
#+END_SRC

The preceeding example produces this HTML:

#+BEGIN_SRC html :eval never
<ul class="list-of-items" data-reactid=".0">
  <li class="item-1" data-reactid=".0.$item-1">Item 1</li>
  <li class="item-2" data-reactid=".0.$item-2">Item 1</li>
  <li class="item-3" data-reactid=".0.$item-3">Item 1</li>
</ul>
#+END_SRC

#+CINDEX:factory function
We can simplify it by first creating a factory function:

#+BEGIN_SRC js :eval never :tangle snapterest/source/app.js
var React = require('react');
var ReactDOM = require('react-dom');

var createListItemElement = React.createFactory('li');

var listItemElement1 = createListItemElement({ className: 'item-1', key: 'item-1' }, 'Item 1');
var listItemElement2 = createListItemElement({ className: 'item-2', key: 'item-2' }, 'Item 2');
var listItemElement3 = createListItemElement({ className: 'item-3', key: 'item-3' }, 'Item 3');

var reactFragment = [ listItemElement1, listItemElement2, listItemElement3 ];
var listOfItems = React.createElement('ul', { className: 'list-of-items' }, reactFragment);

ReactDOM.render(listOfItems, document.getElementById('react-application'));
#+END_SRC

#+NAME:ch2-ReactElement-children-factory-function
#+CAPTION:Creating Children with a Factory Function
[[file:img/ch2-ReactElement-children-factory-function-50.png]]

#+CINDEX:@code{React.createFactory()} method
In the preceding example, we're first called the ~React.createFactory()~
function and passing a ~li~ tag name as a =type= parameter.  Then, the
~React.createFactory()~ function returns a new function that we can use as a
convenient shorthand to create elements of type ~li~.  We store a reference to
this function in a variable called ~createListItemElement~.  Then we call this
function three times, and each time we only pass the =props= and =childre=
parameters, which are unique for each element.  Notice that
~React.createElement()~ and ~React.createFactory()~ both expect the HTML tag
name string (such as ~li~) or the ~ReactClass~ object as a type parameter.

*** React's Built-in Factory Functions

#+CINDEX:factory functions, built-in to React
#+CINDEX:@code{React.DOM.#} methods
React provides a number of built-in factory functions to create the common HTML
tags.  You can call them from the ~React.DOM~ object; for example:
- ~React.DOM.ul()~
- ~React.DOM.li()~
- ~React.DOM.div()~


and so on.  Using them, we can simplify our previous example even further:

#+NAME:built-in-factory-function-app.js
#+CAPTION:Creating a DOM Structure Using Built-in Factory Functions
#+BEGIN_SRC js :eval never :tangle snapterest/source/app.js
var React = require('react');
var ReactDOM = require('react-dom');

var listItemElement1 = React.DOM.li({ className: 'itemDOM-1', key: 'item-1' }, 'Item 1');
var listItemElement2 = React.DOM.li({ className: 'itemDOM-2', key: 'item-2' }, 'Item 2');
var listItemElement3 = React.DOM.li({ className: 'itemDOM-3', key: 'item-3' }, 'Item 3');

var reactFragment = [ listItemElement1, listItemElement2, listItemElement3 ];
var listOfItems = React.DOM.ul({ className: 'list-of-items' }, reactFragment);

ReactDOM.render(listOfItems, document.getElementById('react-application'));
#+END_SRC

#+CINDEX:tree of @code{ReactNode}s
Now we know how to create a tree of ~ReactNode~'s.  However, there is one
important line of code that we need to discuss before we can progress further:

: ReactDOM.render(listOfItems, document.getElementById('react-application'));

It renders our ~ReactNode~ tree to the DOM.  Let's take a closer look at how it
works.

** Rendering React Elements

{{{subheading(Parameters to ~ReactDOM.render()~)}}}

#+CINDEX:@code{ReactDOM.render()} method, parameters
The ~ReactDOM.render()~ method takes three parameters:

   #+CINDEX:@code{ReactElement}
1. ~ReactElement : A root element in the tree of ~ReactNodes~ that you have
   created
   #+CINDEX:@code{DOMElement}
2. ~DOMElement~ : A container DOM node for that tree.
   #+CINDEX:callback function
3. callback function : A function executed after the tree is rendered or
   updated.


: ReactDOM.render(ReactElement, DOMElement, callback);

#+CINDEX:@code{ReactElement}
It is important to note that if this ~ReactElement~ was previously rendered to
a parent DOM ~Element~, then ~ReactDOM.render()~ will perform an /update/ on
the already rendered DOM tree and only /mutate/ the DOM as it is necessary to
reflect the latest version of the ~ReactElement~.  This is why a virtual DOM
requires fewer DOM mutations.

{{{heading(Creating Static Web Content on a Server)}}}

#+CINDEX:initial page load
Can you think of a case when rendering a user interface on a client would be
slow?  The initial page load.  The problem with the initial page load is the
one mentioned at the beginning of this chapter---we're not creating static web
pages anymore.  Instead, when a web browser loads our web application, it
receives only the bare minimum HTML markup that is usually used as a container
or a parent element for our web application.  Then, our JavaScript code creates
the rest of the DOM, but in order for it to do so it often needs to request
extra data from the server.  However, getting this data takes time.  Once this
data is received, our JavaScript code starts to mutate the DOM.  We know that
DOM mutations are slow.  How can we solve this problem?

#+CINDEX:static web pages
#+CINDEX:mutate DOM in a server
The solution is instead of mutating the DOM in a web browser, we mutate it on a
server, just like we would with our static web pages.  A web browser will then
receive an HTML that fully represents a user interface of our web application
at the time of the initial page load.  But we can't mutate the DOM on a server
because it doesn't exist outside a web browser.

#+CINDEX:virtual DOM on a server
#+CINDEX:@code{ReactNode} tree
We have a virtual DOM that is just a JavaScript, and as you know using Node.js,
we can run JavaScript on a server.  So technically, we can use the React
library on a server, and we can create our ~ReactNode~ tree on a server.  The
question is how can we render it to a string that we can send to a client?

{{{subheading(ReactDOMServer.renderToString())}}} Method

#+CINDEX:@code{ReactDOMServer.renderToString()} method
React has a method called ~ReactDOMServer.renderToString()~ for just this
purpose.

: var ReactDOMServer = require('react-dom/server');
: ReactDOMServer.renderToString(ReactElement);

It takes a ~ReactElement~ as a parameter and renders it to its initial HTML.
Not only is this faster than mutating a DOM on a client, but it also improves
the *Search Engine Optimization (SEO)* of your web application.

{{{subheading(ReactDOMServer.renderToStaticMarkup())}}} Method

#+CINDEX:@code{ReactDOMServer.renderToStaticMarkup()} method
React can also generate static web pages:

: var ReactDOMServer = require('react-dom/server');
: ReactDOMServer.renderToStaticMarkup(ReactElement);

Similar to ~ReactDOMServer.renderToString()~, this method also takes a
~ReactElement~ as a parameter and outputs an HTML string.  However, it doesn't
create the extra DOM attributes that React uses internally; rather, it produces
shorter HTML strings that we can transfer to the wire quickly.

Now you know not only how to create a virtual DOM tree using React Elements,
but you also know how to render it to a client and server.  Our next question
is whether we can do it quickly and in a more visual manner.

** Creating React Elements With JSX

When we build our virtual DOM by constantly calling the ~React.createElement()~
method, it becomes quite hard to visually translate these multiple function
calls into a hierarchy of HTML tags.  Don't forget that, even though we're
working with a virtual DOM, we're still creating a structure layout for our
content and user interface.  Wouldn't it be great to be able to visualize that
layout easily by simply looking at our React code?

#+CINDEX:JSX
{{{dfn(JSX)}}} is an optional HTML-like syntax that allows us to create a
virtual DOM tree without using the ~React.creatElement()~ method.

Let's [[built-in-factory-function-app.js]], which was created without using JSX.

Translate this to one using JSX:

#+NAME:jsx-app.js
#+CAPTION:Coding With JSX
#+BEGIN_SRC js :eval never :tangle snapterest/source/app.js
var React = require('react');
var ReactDOM = require('react-dom');

var listOfItems =
<ul className="list-of-items">
    <li className="jsx-item-1">Item 1</li>
    <li className="jsx-item-2">Item 2</li>
    <li className="jsx-item-3">Item 3</li>
</ul>;

ReactDOM.render(listOfItems, document.getElementById('react-application'));
#+END_SRC

JSX allows us to write HTML-like syntax in our JavaScript code.  More
importantly, we can now clearly see what our HTML layout will look like once
its rendered.  JSX is a convenience tool and it comes with a price in the form
of an additional transformation step.  Transformation of the JSX syntax into
valid JavaScript syntax must happen before our ``invalid'' JavaScript code is
interpreted.

#+CINDEX:@file{babelify} module
#+CINDEX:gulp default task
#+CINDEX:@file{gulpfile.js}
#+CINDEX:@command{.transform(babelify)} function call
In the previous chapter, we installed the ~babelify~ module that transforms our
JSX syntax into a JavaScript one.  This transformation happens every time we
run our =default= task from the {{{file(gulpfile.js)}}}
([[default-task-gulpfile.js]]).  The ~.transform(babelify)~ function call
transforms JSX into JavaScript before bundling it with the other JavaScript
code.

To test our transformation, run this command:
: $ gulp

Then navigate to the ~<dir>/snapterest/build/~ directory, and open ~index.html~
in a web browser.  You will see a list of three items.

#+NAME:children-using-jsx
#+CAPTION:Creating a List of Items Using JSX
[[file:img/ch2-ReactElement-children-jsx-50.png]]

{{{heading(Online JSX Compiler)}}}

The React team has built an online JSX Compiler that you can use to test your
understanding of how JSX works.[fn::This tool has been removed as
JSXTransformer has been deprecated.]

** Summary

We started this chapter by discussing the issues with single web page
applications and how they can be addressed.  Then, we learned what a virtual
DOM is and how React allows us to build it.  We also installed React and
created our first React element using only JavaScript.  Then we also learned
how to render React elements in a web browser and on a server.  Finally, we
looked at a simpler way of creating React elements with JSX.

In the next chapter we'll dive deeper into the world of React components.

* 3. Create Your First React Component
:PROPERTIES:
:CUSTOM_ID: Chapter 3
:END:


In the previous chapter, we learned how to create /React elements/ and how to
use them to render HTML markup.  We learned how easy it is to produce React
elements using /JSX/.  At this point, you know enough about React in order to
create the static web pages that we discussed in Chapter 2.  You want to build
interactive user interfaces that react to user and server events.  What does it
mean to react to an event?  How can a static HTML element /react/?   How can a
React element react?  In this chapter we'll answer these questions and many
other questions while introducing ourselves to /React components/.

** Stateless Versus Stateful

#+CINDEX:react
#+CINDEX:state, switch
#+CINDEX:virtual DOM elements
#+CINDEX:benefit of React library, easy to reason about
To {{{dfn(react)}}} means to switch from one state to another.  This means that
you need to have a state in the first place and the ability to change state.
Have we mentioned a state or the ability to change that state in React
elements?  No.  They are stateless.  Their sole purpose is to construct and
render virtual DOM elements.  In fact, we want them to render in the exact same
way, given that we provide them the exact same set of parameters.  We want them
to be consistent because it makes it easy for us to reason about them.  That's
one of the key benefits of using the React library---the ease of reasoning how
our web application works.

#+CINDEX:React Component
#+CINDEX:Component
#+CINDEX:state machine, component
How can we add a state to our stateless React elements?  If we can't
encapsulate a state in React elementsm, then *we should encapsulate React
elements in something that already has a state.*  Think of a simple state
machine that represents a user interface.  Every user action triggers a change
of a state in that state machine.  Every state is represented by a different
React element.  In the React library, this state machine is called a
{{{dfn(React Component)}}}.

** Creating Your First Stateless React Component

#+CINDEX:component, create
#+CINDEX:@code{React.createClass()} method
Let's take a look at the following example of how to create a React
/component/ (using the ~React.createClass()~ method):

#+NAME:stateless-component
#+CAPTION:A First Stateless React Component
#+BEGIN_SRC js :eval never
var React = require('react');
var ReactDOM = require('react-dom');

var ReactClass = React.createClass({			(ref:1 class)
    render: function () {
        return React.createElement('h1',
                                   { className: 'header' },
                                   'React Component');
    }
});

var reactComponentElement = React.createElement(ReactClass); (ref:2 element)
var reactComponent = ReactDOM.render(reactComponentElement,	 (ref:3 component)
                                     document.getElementById('react-application'));
#+END_SRC

The new portions of this code can be broken down into three steps:

1. Creating a React class. [[(1 class)]]
2. Creating a React component element (using the class). [[(2 element)]]
3. Creating a React component (using the element). [[(3 component)]]

{{{heading(How to Create a React Component)}}}

#+CINDEX:React component, create
Let's take a closer look at how to create a React component.

   #+CINDEX:@code{React.createClass()} function
   #+CINDEX:@code{ReactClass}
   #+CINDEX:specification object
1. Create a ~ReactClass~ by calling the ~React.createClass()~ method and
   providing a /specification object/ as its parameter.  In this chapter we'll
   focus on learning about the specification objects in more detail.

   #+CINDEX:@code{ReactComponentElement}
   #+CINDEX:@code{React.createElement()} method
   #+CINDEX:~ReactClass~ as @samp{type} parameterx
2. Create a ~ReactComponentElement~ by calling the ~React.createElement()~
   method and providing our ~ReactClass~ as its =type= parameter.  In Chapter
   2, we learned that the =type= parameter can be either a string or a
   ~ReactClass~ ([[#createElement type parameter][The ~type~ Parameter]]).  In this chapter, you'll learn more
   about the latter.

   #+CINDEX:@code{ReactComponent}
   #+CINDEX:@code{ReactDOM.render()} method
3. Create a ~ReactComponent~ by calling the ~ReactDOM.render()~ method and
   providing our ~ReactComponentElement~ as its =element= parameter.

*** The Specification Object

#+CINDEX:specification object
#+CINDEX:look and feel
The {{{dfn(specification object)}}} that you pass as a parameter to
~React.createClass()~ is where your component's ``look and feel'' is defined.
*Specification* is the definition of your React component.  From now on, in
this chapter, we'll refer to a /specification object/ as a React component, and
in the rest of the chapter we will learn about this very important concept.

#+CINDEX:state, specification object
#+CINDEX:rendered, component by specification object
#+CINDEX:@code{render()} method
The /specification object/:

1) encapsulates a component's /state/ and
2) describes how a component is /rendered/.

At the very minimum, the React component needs to have a ~render()~ method that
returns at least =null= or =false=.

Here is an example of a specification object in its simplest form:

#+NAME:simplest-specification-object
#+CAPTIONS:An Example of the Simplest Specification Object
#+BEGIN_SRC js :eval never
{
    render: function () {
        return null;
    }
}
#+END_SRC

    #+CINDEX:@code{render()} method
The ~render()~ method is responsible for telling React how to render your
React component.  It can return =null=, and nothing will be rendered.  Or it
can return a ~ReactElement~ that we learned how to create in Chapter 2.

#+NAME:simple-specification-object
#+CAPTION:A Simple Specification Object Returning a ~ReactElement~
#+BEGIN_SRC js :eval never
{
    render: function () {
        return React.createElement('h1',
                                   { className: 'header' },
                                   'React Component');
    }
}
#+END_SRC

This example shows how we can encapsulate our React element inside our React
component.  We create a ~ReactElement~ of type =h1= with a =properties= object
and a ~ReactText~ as its only child.  Then, we return it when the ~render()~
method of our React component is called.  The fact that we encapsulated our
React element inside a React component doesn't affect how it will be rendered.

: <h1 class="header" data-reactid=".0">React Component</h1>

The produced HTML markup is identical to the one we created in Chapter 2
without using the React component.  In this case, you might be wondering what's
the benefit of having a ~render()~ method if we can render the exact same
markup without it?  The advantage of having a ~render()~ method is that, as
with any other function, before it returns a value, it can choose what value to
return.

*** Adding State and Conditional to a Component

So far, you've seen two examples of the ~render()~ method: one that returns
=null= and one that returns a React element.  We can merge the two and add a
condition that decides what to render:

#+NAME:simple-component-with-state
#+CAPTION:A Simple Specification Object with State and a Conditional
#+BEGIN_SRC js :eval never
{
    render: function () {
        var elementState = {
            isHidden: true
        };
        if (elementState.isHidden) {
            return null;
        }
        return React.createElement('h1',
                                   { className: 'header' },
                                   'React Component');
    }
}
#+END_SRC

#+CINDEX:state object
In this example, we created  the ~elementState~ variable that references an
object with a single ~isHidden~ property.  This object acts as a state for our
React element.  If we want to hide our React element, then we need to set the
value of ~elementState.isHidden~ to =true=, and our ~render()~ method will
return =null=.  In this case, React will render nothing.  Logically, by setting
~elementState.isHidden~ to =false=, will return our React element and the
expected HTML markup will be rendered.  The question you might ask is: how do
we set the value of ~elementState.isHidden~ to =false=?  Of to =true=?  Or how
do we change it in general?

Let's think of scenarios in which we might want to change that state.  One of
them is when a user interacts with our user interface.  Another one is when a
server sends data.  Or when a certain amount of time passes and then we want to
render something else.  Our ~render()~ method is not aware of all these events
and it shouldn't be because its sole purpose is to return a React element based
on the data that we pass to it.  How do we pass data to it?

*** Passing Data to a Component

    #+CINDEX:data, passing to a component
There are two ways to pass data to a ~render()~ method using the React API:

       #+CINDEX:@code{this.props}
1. Using the =properties= object: ~this.props~
       #+CINDEX:@code{this.state}
2. Using the =state= object: ~this.state~

{{{subheading(The ~props~ Parameter)}}}

#+CINDEX:@samp{props} parameter
#+CINDEX:attributes to HTML elements
We learned that the ~React.createElement()~ method accepts the =props=
parameter ([[#props parameter][The =props= Parameter]]).  We used it to pass attributes to our HTML
elements, but we didn't discuss what happens behind the scenes and why
attributes passed to the =props= object get rendered.

#+CINDEX:@code{this.props}
#+CINDEX:data with @samp{props} parameter
    #+CINDEX:accessing data in a component, @code{this.props}
Any data that you put in the =props= object and pass to the
~React.createElement()~ method can be accessed inside the ~render()~ method of
~ReactComponent~ via the ~this.props~ reference.  Once you have accessed data
from ~this.props~, you can render it:

#+NAME:component-using-props
#+CAPTION:Passing Props to a Component
#+BEGIN_SRC js :eval never
{
    render: function () {
        var elementState = {
            isHidden: true
        };
        if (elementState.isHidden) {
            return null;
        }
        return React.createElement('h1',
                                   { className: 'header' },
                                   this.props.header);		(ref:props)
    }
}
#+END_SRC

In this example, we're using ~this.props~ insider our ~render()~ method
([[(props)]]) to access the =header= property.  We're then passing
~this.props.header~ directly to the ~React.createElement()~ method as a child
string element.

In the preceding example, we can pass the value of ~isHidden~ as another
property of the ~this.props~ object (see [[(props-isHidden)]] (instead of
hard-coding ~isHidden~):

#+NAME:passing-props-to-component
#+CAPTION:Example of Passing ~props~ to the ~render()~ Method
#+BEGIN_SRC js :eval never
{
    render: function () {
        if (this.props.isHidden) {			(ref:props-isHidden)
            return null;
        }
        return React.createElement('h1',
                                   { className: 'header' },
                                   this.props.header);
    }
}
#+END_SRC

We can also use ~this.props~ to compute data that needs to be rendered (see
[[(props-to-render)]]):

#+NAME:use-props-to-compute
#+CAPTION:Example of Using ~props~ to Compute a Value
#+BEGIN_SRC js :eval never
{
    render: function () {
        if (this.props.isHidden) {
            return null;
        }
        var header = this.props.tweets.length + ' Latest Tweets'; (ref:props-to-render)
        return React.createElement('h1',
                                   { className: 'header' },
                                   this.props.header);
    }
}
#+END_SRC

We are accessing an array of tweets via ~this.props.tweets~ and getting its
~length~ property.  Then, we're concatenating a string ' Latest Tweets' to it.
The resulting string is stored in a ~header~ variable, and this is our computed
child string element that we're passing to the ~React.createElement()~ method.

{{{subheading(Pure Functions)}}}

#+CINDEX:pure function
Notice that in our previous example, instead of storing ~isHidden~ in a
~render()~ method, we're passing it via ~this.props~.  We removed our
~elementState~ object from it because we don't need to worry about the state in
our ~render()~ method.  It's a {{{dfn(pure function)}}}, which means that it
shouldn't mutate the state or access the real DOM, or otherwise interact with a
web browser.  Remember that we might want to use React on a server, where we
have no web browser, and we should expect the ~render()~ method to produce the
same result regardless of the environment.

*** Managing State

    #+CINDEX:manage state
    #+CINDEX:state management
If our ~render()~ method doesn't manage the state, then how do we manage it?
How do we set the state, and how do we update it while handling user or browser
events in React?

#+CINDEX:types of React components
#+CINDEX:components, types
Earlier in this chapter, we learned that in React we can represent a user
interface with React components.  There are two types of React components:

1. With state
2. Without state


#+CINDEX:stateless React components
Hold on, didn't we say that React components are state machines?  Surely, every
state machine needs to have a state.  You're correct; however, it's a good
practice to keep as many React components stateless as possible.

{{{subheading(Composable Elements and Separation of Concerns)}}}

React components are /composable/.  As a result, we can have a hierarchy of
React components.  Imagine that we have a parent React component that has two
child components, and each of them in turn has another two child components.
All the components are stateful and they can manage their own state.

#+CINDEX:separation of concerns
#+CINDEX:user interface
#+CINDEX:render data
How easy will it be to figure out what the last child component in the
hierarchy will render if the top component in the hierarchy updates its state?
Not easy.  There is a design pattern that removes this unnecessary complexity.
The idea is to separate your components into two concerns:

- how to handle the user interface interaction logic and
- how to render data.


- The minority of your React components are stateful.  They should be at the
  top of your component's hierarchy.  They encapsulate all of the interaction
  logic, manage the user interface state, and pass that state down the
  hierarchy to stateless components, using ~props~.

- The majority of your React components are stateless.  They receive data via
  ~this.props~ and then render that data.  The component is stateless.


In our previous example, we received ~isHidden~ state data vie ~this.props~ and
then we rendered that data.  Our component was stateless.

Next, let's create our first stateful component.

** Creating Your First Stateful Component

#+CINDEX:stateful components
#+CINDEX:interaction logic
#+CINDEX:manage state
Stateful components arre the most appropriate place for you application to
handle the interaction logic and manage the state.  They make it easier for you
to reason out how your application works.  This reasoning plays a key role in
buidling maintainable web applications.

{{{subheading(Setting Initial State with ~getInitialState()~)}}}

#+CINDEX:@code{this.state} property
#+CINDEX:@code{getInitialState()} method
React stores the component's state in ~this.state~, and it sets the initial
value of ~this.state~ to the value returned by the ~getInitialState()~ method.
However, it's up to us to tell React what the ~getInitialState()~ method will
return.  Let's add this method to our React component:

#+NAME:component-getInitialState
#+CAPTION:Simple Component Using ~getInitialState()~ Method
#+BEGIN_SRC js :eval never
{
    getInitialState: function () {
        return {
            isHidden: false
        }
    },

    render: function () {
        if (this.state.isHidden) {
            return null;
        }
        return React.createElement('h1',
                                   { className: 'header' },
                                   'React Component');
    }
}
#+END_SRC

In this example, our ~getInitialState()~ method returns an object with a single
~isHidden~ property that is set to false.  This is the initial state of our
React component and our user interface.  Notice that in our ~render()~ method
we're now referring to ~this.state.isHidden~ instead of ~this.props.isHidden~.

{{{subheading(Difference Between ~this.props~ and ~this.state~)}}}

#+CINDEX:props vs. state, difference
#+CINDEX:state vs. props, difference
Earlier in this chapter, you learned that we can pass data to the component's
~render()~ method via ~this.props~.  So, what's the difference between the two?

- ~this.props~ stores /read-only/ data that is passed from the parent.  It
  belongs to the parent and cannot be changed by its children.  This data
  should be considered /immutable/.

- ~this.state~ stores data that is private to the component.  It can be changed
  by the component.  The component will rerender itself when the state is
  updated.


{{{subheading(Setting State with ~setState()~)}}}

#+CINDEX:@code{setState()} method
How do we update a component's state?  There is a common way of informing React
of a state change using ~setState(DATA, CALLBACK)~.  This method takes two
parameters:

  #+CINDEX:@code{data} object to @code{setState()}
- The ~data~ object that represents the next state

  #+CINDEX:@code{callback} function to @code{setState()}
- The ~callback~ function, which you will rarely need to use because React
  keeps your user interface up-to-date for you.


*** Keeping the Interface Up-To-Date

How does React keep your user interface up-to-date?  It calls the component's
~render()~ method every time you update the component's state, including any
child components which are rendered as well.  In fact, it rerenders the entire
virtual DOM every time our ~render()~ method is called.

#+CINDEX:merge state
When you call the ~this.setState()~ method and pass it a data object that
represents the next state, React will merge that next state with the current
state.  During the merge, React will overwrite the current state with the next
state.  The current state that is not overwritten by the next state will become
part of the next state.

Image that this is our current state:

#+BEGIN_SRC js :eval never
{
    isHidden: true,
    title: 'Stateful React Component'
}
#+END_SRC

We call ~this.setState(nextState)~, where ~nextState~ is as follows:

#+BEGIN_SRC js :eval never
{
    isHidden: false
}
#+END_SRC

React will merge the two states into a new one:

#+BEGIN_SRC js :eval never
{
    isHidden: false,
    title: 'Stateful React Component'
}
#+END_SRC

The ~isHidden~ property is updated and the ~title~ property is not deleted or
updated in any way.

*** Creating a Component That Reacts to User Events

#+CINDEX:stateful component
#+CINDEX:react to user event
#+CINDEX:user event, reacting to
Now that we know how to update our component's state, let's create a stateful
component that reacts to a user event:

#+NAME:component-reacts-to-user-event
#+CAPTION:A stateful component that reacts to a user event
#+BEGIN_SRC js :eval never
{
    getInitialState: function () {
        return {
            isHeaderHidden: false,
            title: 'Stateful React Component'
        }
    },

    handleClick: function () {
        this.setState({
            isHeaderHidden: !this.state.isHidden		(ref:setState)
        )};
    },

    render: function () {
        var headerElement = React.createElement('h1',
                                                { className: 'header', key: 'header' },
                                                this.state.title);
        var buttonElement = React.createElement('button',	(ref:createElement)
                                                { className: 'btn btn-default',
                                                  onClick: this.handleClick,		(ref:onClick)
                                                  key: 'button'},
                                                'Toggle header');
        if (this.state.isHeaderHidden) {
            return React.createElement('div', null, [ buttonElement ]);
        }
        return React.createElement('div', null, [ buttonElement, headerElement ]);
    }
}
#+END_SRC

In this example, we're creating a toggle button that shows and hides a header.
The first thing we do is set our initial state object by returning it from the
~getInitialState()~ method.  Our initial state has two properties:
~isHeaderHidden~ that is set to =false= and ~title~ that is set to =Stateful
React Component=.  Now we can access this state object in our ~render()~ method
via ~this.state~.  Inside our ~render()~ method, we create three React
elements: =hi=, =button=, and =div=.  Our =div= element acts as a parent
element for our =h1= and =button= elements.  However, in one case we create our
=div= element with two children, ~headerElement~ and ~buttonElement~, and in
another case we create it with only one child, ~buttonElement~.  The case we
choose depends on the value of ~this.state.isHeaderHidden~.  The current state
of our component directly affects what the ~render()~ method will render.
While this should look familiar to you, there is something new in this example
that we haven't seen before.

{{{subheading(Handling Events with Custom Component Properties)}}}

#+CINDEX:@code{handleClick()} method
#+CINDEX:@code{onClick} events
#+CINDEX:properties on component
Notice that we introduced a new property on our ~ReactComponent~ object, called
~handleClick()~, which is a method that has no special meaning to React.  It's
part of our application logic, and we use it to handle the ~onClick~ events.
You can add your own properties to the ~ReactComponent~ object.  All of these
will be available via a ~this~ reference, which you can access from any other
method that itself is a property of the component object.  For example, we
are accessing a state object via ~this.state~ in both the ~render()~ and
~handleClick()~ methods.

What does our ~handleClick()~ method do?  It updates our component's state by
setting the new value of this ~isHeaderHidden~ property to the opposite of the
existing one that it accesses via ~this.state.isHeaderHidden~ (see [[(setState)]]).

{{{subheading(Event Handlers in the =props= Parameter)}}}

#+CINDEX:event handler
#+CINDEX:attach event handler
Our ~handleClick()~ method reacts to a user interaction with our user
interface.  Our user interface is a =button= element that a user can click on,
and we can attach an event handler to.  In React, you can attach event handlers
to a React element by passing them to the ~props~ parameter in the
~createElement()~ method (see [[(onClick)]]).

#+CINDEX:CamelCase
#+CINDEX:events, list of supported
React uses the *CamelCase* naming convention for event handlers; for example,
~onClick~.  You can find a list of all the supported events at
https://reactjs.org/docs/events.html#supported-events.

#+CINDEX:bubble phase
#+CINDEX:capture phase
#+CINDEX:trigger event handlers
By default, React triggers the event handlers in the /bubble phase/, but you
can tell React to trigger them in the /capture phase/ by appending =Capture= to
the event name, for example, ~onClickCapture~.

#+CINDEX:@code{SyntheticEvent} object
React wraps a browser's native events into the ~SyntheticEvent~ object to
ensure that all the supported events behave identically in Internet Exploror 8
and above.

#+CINDEX:@code{nativeEvent} property
#+CINDEX:@code{initializeTouchEvents()} method
The ~SyntheticEvent~ object provides the same API as the native browser's
event, which means that you can use the ~stopPropogation()~ and
~preventDefault()~ methods as usual.  If for some reason, you need to access
the native browser's event, then you can do this via the ~nativeEvent~
property.  To enable touch-event handling, simply call
~React.initializeTouchEvents(TRUE)~.

#+CINDEX:inline event handler, none
Notice that passing the ~onClick~ property to our ~createElement()~ method in
the previous example does not create an inline event handler in the rendered
HTML markup.

: button class="btn btn-default" data-reactid=".0.$button">
:    Toggle header
: </button<>

#+CINDEX:listen for events, at top level
This is because React doesn't actually attach event handlers to the DOM nodes
themselves.  Instead, React listens for all the events at the top level using a
single event listener, and delegates them to their appropriate event handlers.

*** Keeping State Lean

In the previous example, you learned how to create a stateful React component
that a user can interact with and change its state.  We created and attached an
event handler to the ~onClick~ event that updates the value of the
~isHeaderHidden~ property.  But have you noticed that the user interaction does
not update the value of another property that we store in our state, ~title~?
Does thst seem odd to you?  We have data in our state that doesn't ever get
changed.  This observation raises an important question: what should we /not/
put in our state?

Ask yourself a question: what data can I remove from a component's state and
still keep its user interface always up to data?  Keep asking and keep removing
that data until you're absolutely certain that there is nothing left to remove
without breaking your user interface.

In our example, we have the ~title~ property in our state object that we can
move to our ~render()~ method without breaking the interactivity of our toggle
button.  The component will still work as expected:

#+NAME:stateful-component-no-title
#+CAPTION:A stateful component that reacts with minimal state
#+BEGIN_SRC js :eval never
{
    getInitialState: function () {
        return {
            isHeaderHidden: false
        }
    },

    handleClick: function () {
        this.setState({
            isHeaderHidden: !this.state.isHidden
        )};
    },

    render: function () {
        var title = 'Stateful React Component';

        var headerElement = React.createElement('h1',
                                                { className: 'header', key: 'header' },
                                                title);
        var buttonElement = React.createElement('button',	(ref:createElement)
                                                { className: 'btn btn-default',
                                                  onClick: this.handleClick,
                                                  key: 'button'},
                                                'Toggle header');
        if (this.state.isHeaderHidden) {
            return React.createElement('div', null, [ buttonElement ]);
        }
        return React.createElement('div', null, [ buttonElement, headerElement ]);
    }
}
#+END_SRC

On the other hand, if we move the ~isHeaderHidden~ property out of a state
object, then we'll break the interactivity of our component because our
~render()~ method will not be triggered automatically by React every time a
user clicks on our button.  This is an example of broken interactivity.

This is an anti-pattern.  Remember this rule of thumb:

#+BEGIN_cartouche
A component's state should store data that a component's event handlers may
change over time in order to rerender a component's user interface and keep it
up to date.  Keep the minimal possible representation of a component's state in
a ~state~ object, and compute the rest of the data based on what's in ~state~
and ~props~ inside a component's ~render()~ method.  Anything you put in
~state~, you'll need to update yourself.  Anything you put in ~render()~ will
automatically get updated by React.  Take advantage of React.
#+END_cartouche

** Summary

In this chapter we reached an important milestone: we learned how to
encapsulate a state and create interactive user interfaces by creating React
components.  We discussed stateless and stateful React components, and the
difference between them.  We talked about the browser events and how to handle
them in React.

In the next chapter, we'll be planning our Snapterest web application.  You'll
learn how to solve a problem with React and how to create composable React
components.

* 4. Make Your React Component Reactive

* 5. Use Your React Components With Another Library

* 6. Update Your React Components

* 7. Build Complex React Components

* 8. Test Your React Application With Jest

** TODO Install Jest 0.4

- See [[https://github.com/fedosejev/react-essentials/blob/master/updates.md#chapter-8-page-6][Errata]]
  : npm install --save-dev jest-cli@^0.4

* 9. Supercharge Your React Architecture With Flux

* 10. Prepare Your React Application for Painless Maintenance with Flux

** TODO Fix Tweet commands

- See [[https://github.com/fedosejev/react-essentials/blob/master/updates.md#chapter-10-page-29][Errata]]
  Use these:
  : <Tweet tweet={this.props.tweet} onImageClick={this.props.onAddTweetToCollection} />
  : <Tweet tweet={this.props.tweet} onImageClick={this.addTweetToCollection} />
* React.js
:PROPERTIES:
:APPENDIX: t
:END:

A JavaScript library for building user interfaces.

- [[https://reactjs.org/][React.js Home]]

* Flux
:PROPERTIES:
:APPENDIX: t
:END:

{{{heading(APPLICATION ARCHITECTURE FOR BUILDING USER INTERFACES)}}}

{{{subheading(An application architecture for React utilizing a unidirectional data flow.)}}}

Flux is the application architecture that Facebook uses for building
client-side web applications. It complements React's composable view components
by utilizing a unidirectional data flow. It's more of a pattern rather than a
formal framework, and you can start using Flux immediately without a lot of new
code.

- [[https://facebook.github.io/flux/][Flux Home]]
- [[https://github.com/facebook/flux][Flux Github Home]]
- [[https://facebook.github.io/flux/docs/overview.html][Flux Docs]]
- [[https://facebook.github.io/flux/docs/videos.html#content][Flux Videos]]

** Getting Started

Start by looking through the guides and examples on Github. For more resources
and API docs check out [[https://facebook.github.io/flux][facebook.github.io/flux]].

#+NAME:flux-diagram.png
#+CAPTION:Flux Diagram
[[file:img/flux-diagram-white-background-25.png]]

** How Flux works

For more information on how Flux works check out the [[https://github.com/facebook/flux/blob/master/examples/flux-concepts][Flux Concepts]] guide, or
the [[https://facebook.github.io/flux/docs/in-depth-overview.html#content][In Depth Overview]].

** Flux Concepts

#+CINDEX:Flux concepts
#+CINDEX:concepts of Flux
These are the important high-level concepts and principles you should know
about when writing applications that use Flux.

{{{heading(Overview)}}}

#+CINDEX:Flux overview
#+CINDEX:overview of Flux
Flux is a pattern for managing data flow in your application. The most
important concept is that /data flows in one direction/.  As we go through this
guide we'll talk about the different pieces of a Flux application and show how
they form /unidirectional cycles/ that data can flow through.

{{{subheading(Flux Parts)}}}

- Dispatcher

- Store

- Action

- View

*** Dispatcher

#+CINDEX:Dispatcher
#+CINDEX:actions
#+CINDEX:stores
#+CINDEX:register store with dispatcher
#+CINDEX:singleton dispatcher
The {{{dfn(dispatcher)}}} receives actions and dispatches them to stores that
have registered with the dispatcher.  Every store will receive every action.
There should be only one singleton dispatcher in each application.

Example:

1. User types in title for a todo and hits enter.
2. The view captures this event and dispatches an "add-todo" action containing
   the title of the todo.
3. *Every store* will then receive this action.

*** Store

#+CINDEX:store
#+CINDEX:store, register with dispatcher
#+CINDEX:register, store with dispatcher
#+CINDEX:action
#+CINDEX:mutate data
#+CINDEX:setters
#+CINDEX:getters
#+CINDEX:@samp{change} event
A store is what holds the data of an application. Stores will register with the
application's dispatcher so that they can receive actions.  The data in a store
must only be mutated by responding to an action. There should not be any public
setters on a store, only getters.  Stores decide what actions they want to
respond to.  Every time a store's data changes it must emit a
{{{samp(change)}}} event.  There should be many stores in each application.

Examples:

1. Store receives an "add-todo" action.
2. It decides it is relevant and adds the todo to the list of things that need
   to be done today.
3. The store updates its data and then emits a "change" event.

*** Actions

#+CINDEX:actions
#+CINDEX:@samp{type} field
Actions define the internal API of your application.  They capture the ways in
which anything might interact with your application.  They are simple objects
that have a {{{samp(type)}}} field and some data.

Actions should be semantic and descriptive of the action taking place.  They
should not describe implementation details of that action. Use
{{{samp(delete-user)}}} rather than breaking it up into
{{{samp(delete-user-id)}}}, {{{samp(clear-user-data)}}},
{{{samp(refresh-credentials)}}} (or however the process works).  Remember that
all stores will receive the action and can know they need to clear the data or
refresh credentials by handling the same {{{samp(delete-user)}}} action.

Examples:

1. When a user clicks "delete" on a completed todo a single "delete-todo"
   action is dispatched:

   #+BEGIN_SRC js :eval never
  {
    type: 'delete-todo',
    todoID: '1234',
  }
   #+END_SRC

*** Views

#+CINDEX:views
#+CINDEX:subscribe to change events, view
#+CINDEX:actions, dispatched from views
Data from stores is displayed in views.  Views can use whatever framework you
want (In most examples here we will use React).  When a view uses data from a
store it must also subscribe to change events from that store.  Then when the
store emits a change the view can get the new data and re-render.  If a
component ever uses a store and does not subscribe to it then there is likely a
subtle bug waiting to be found.  Actions are typically dispatched from views as
the user interacts with parts of the application's interface.

Example:

1. The main view subscribes to the TodoStore.
2. It accesses a list of the Todos and renders them in a readable format for
   the user to interact with.
3. When a user types in the title of a new Todo and hits enter the view tells
   the Dispatcher to dispatch an action.
4. All stores receive the dispatched action.
5. The TodoStore handles the action and adds another Todo to its internal data
   structure, then emits a "change" event.
6. The main view is listening for the "change" event. It gets the event, gets
   new data from the TodoStore, and then re-renders the list of Todos in the
   user interface.

*** Flow of data

We can piece the parts of Flux above into a diagram describing how data flows
through the system.

1. Views send actions to the dispatcher.
2. The dispatcher sends actions to every store.
3. Stores send data to the views.

#+NAME:flow.png
#+CAPTION:Views get data from the stores.
[[file:img/flux-simple-f8-diagram-with-client-action-1300w-50.png]]

*** Next steps

You can start coding with the [[todo-example][flux-todomvc]] example, or head back to check out
the full list of [[*Examples][example topics]].
** Requirements

{{{subheading{EventEmitter}

#+CINDEX:EventEmitter, Flux
Flux is more of a pattern than a framework, and does not have any hard
dependencies.  However, we often use [[https://nodejs.org/api/events.html#events_class_events_eventemitter][EventEmitter]] as a basis for Stores and
[[https://github.com/facebook/react][React]] for our Views.

{{{subheading(Dispatcher)}}}

#+CINDEX:Dispatcher, Flux
The one piece of Flux not readily available elsewhere is the =Dispatcher=.
This module, along with some other utilities, is available here to complete
your Flux toolbox.

** Installing Flux

#+CINDEX:Flux, install
#+CINDEX:install Flux
#+CINDEX:@code{Flux.Dispatcher}
Flux is available as an [[https://www.npmjs.org/package/flux][npm module]], so you can add it to your ~package.json~
file or run {{{command(npm install flux)}}}. The dispatcher will be available
as ~Flux.Dispatcher~ and can be required like this:
: const Dispatcher = require('flux').Dispatcher;

  #+CINDEX:dispatcher API
- Take a look at the [[https://facebook.github.io/flux/docs/dispatcher.html#content][dispatcher API and some examples]].

** Building Flux from a Cloned Repo

Clone the repo and navigate into the resulting flux directory. Then run
{{{command(npm install)}}}.

#+CINDEX:Gulp, Flux
#+CINDEX:build process, Flux
This will run Gulp-based build tasks automatically and produce the file
~Flux.js~, which you can then require as a module.

#+CINDEX:Dispatcher
You could then require the Dispatcher like so:
: const Dispatcher = require('path/to/this/directory/Flux').Dispatcher;

The build process also produces de-sugared versions of the =Dispatcher= and
=invariant= modules in a ~lib~ directory, and you can require those modules
directly, copying them into whatever directory is most convenient for you. The
flux-todomvc and flux-chat example applications both do this.

** Examples

https://github.com/facebook/flux/tree/master/examples

This directory contains examples that should help get you started with
Flux. They are listed in the order you should complete them.

- [[https://github.com/facebook/flux/blob/master/examples/flux-concepts][Basic concepts (no code)]]

  These are the important high-level concepts and principles you should know
  about when writing applications that use Flux.

- [[https://github.com/facebook/flux/blob/master/examples/flux-todomvc][Start coding here]]

  <<todo-example>>This example is where you should start. It walks you through
  creating the classic TodoMVC application using a simple Flux implementation.

- [[https://github.com/facebook/flux/blob/master/examples/flux-jest][Unit Testing Stores]]

  Being able to unit test stores is critical. This example shows you how to
  write tests for the TodoMVC stores we created in an earlier example.

- [[https://github.com/facebook/flux/blob/master/examples/flux-flow][Static typing]]

  This is a very simple example that highlights how to set up Flux and Flow in
  the same project. Flow is a static-type checking tool that will help catch
  errors in your code statically. It complements Flux well since it supports
  refining the action based on a type string.

- [[https://github.com/facebook/flux/blob/master/examples/flux-logging][Add logging to Flux apps]]

  Taking advantage of the fact that a store gets every action makes it easy to
  add logging to a Flux application. Check out this quick example where we add
  a logger store to the TodoMVC app we created in an earlier example.

- [[https://github.com/facebook/flux/blob/master/examples/flux-jest-container][Unit Testing Containers]]

  Testing the container logic that connects stores to views can be tricky. This
  example shows you how to create some utilities to help mock out store data in
  order to write these kinds of tests effectively.

- [[https://github.com/facebook/flux/blob/master/examples/flux-async][Flux with async requests]]

  This is an advanced example. It pulls a lot of the concepts from previous
  examples into a single application. This implements TodoMVC where the data is
  persisted and requested through a simple server. The server simulates delays
  and errors. In the example we will handle things like optimistic updates,
  loading states, and failing API requests.

** In-Depth Overview

- [[https://facebook.github.io/flux/docs/in-depth-overview.html#content][Link]]
- [[https://youtu.be/nYkdrAPrdcw?list=PLb0IAmt7-GS188xDYE-u1ShQmFFGbrk0v][Video]]

** Reference

*** Disptacher Docs

#+CINDEX:Dispatcher
Dispatcher is used to broadcast payloads to registered callbacks. This is
different from generic pub-sub systems in two ways:

- Callbacks are not subscribed to particular events. Every payload is
  dispatched to every registered callback.
- Callbacks can be deferred in whole or part until other callbacks have been
  executed.


Check out [[https://github.com/facebook/flux/blob/master/src/Dispatcher.js][Dispatcher.js]] for the source code.

  #+CINDEX:Dispatcher API
**** Dispatcher API

  #+CINDEX:@code{register()}
- ~register(function callback)~: string ::

     Registers a callback to be invoked with every dispatched payload. Returns
     a token that can be used with ~waitFor()~.

  #+CINDEX:@code{unregister()}
- ~unregister(string id)~: void ::

     Removes a callback based on its token.

  #+CINDEX:@code{waitFor()}
- ~waitFor(array<string> ids)~: void ::

     Waits for the callbacks specified to be invoked before continuing
     execution of the current callback. This method should only be used by a
     callback in response to a dispatched payload.

  #+CINDEX:@code{dispatch()}
- ~dispatch(object payload)~: void ::

     Dispatches a payload to all registered callbacks.

  #+CINDEX:@code{isDispatching()}
- ~isDispatching()~: boolean ::

      Is this Dispatcher currently dispatching.

**** Example

#+CINDEX:flight destination form
For example, consider this hypothetical flight destination form, which selects
a default city when a country is selected:

#+BEGIN_SRC js -n :eval never
var flightDispatcher = new Dispatcher();

// Keeps track of which country is selected
var CountryStore = {country: null};

// Keeps track of which city is selected
var CityStore = {city: null};

// Keeps track of the base flight price of the selected city
var FlightPriceStore = {price: null};
#+END_SRC

When a user changes the selected city, we dispatch the payload:

#+BEGIN_SRC js +n :eval never
flightDispatcher.dispatch({
  actionType: 'city-update',
  selectedCity: 'paris'
});
#+END_SRC

This payload is digested by CityStore:

#+BEGIN_SRC js +n :eval never
flightDispatcher.register(function(payload) {
  if (payload.actionType === 'city-update') {
    CityStore.city = payload.selectedCity;
  }
});
#+END_SRC

When the user selects a country, we dispatch the payload:

#+BEGIN_SRC js +n :eval never
flightDispatcher.dispatch({
  actionType: 'country-update',
  selectedCountry: 'australia'
});
#+END_SRC

This payload is digested by both stores:

#+BEGIN_SRC js +n :eval never
CountryStore.dispatchToken = flightDispatcher.register(function(payload) {
  if (payload.actionType === 'country-update') {
    CountryStore.country = payload.selectedCountry;
  }
});
#+END_SRC

When the callback to update ~CountryStore~ is registered, we save a reference
to the returned token. Using this token with ~waitFor()~, we can guarantee that
~CountryStore~ is updated before the callback that updates ~CityStore~ needs to
query its data.

#+BEGIN_SRC js +n :eval never
CityStore.dispatchToken = flightDispatcher.register(function(payload) {
  if (payload.actionType === 'country-update') {
    // `CountryStore.country` may not be updated.
    flightDispatcher.waitFor([CountryStore.dispatchToken]);
    // `CountryStore.country` is now guaranteed to be updated.

    // Select the default city for the new country
    CityStore.city = getDefaultCityForCountry(CountryStore.country);
  }
});
#+END_SRC

The usage of ~waitFor()~ can be chained, for example:

#+BEGIN_SRC js +n :eval never
FlightPriceStore.dispatchToken =
  flightDispatcher.register(function(payload) {
    switch (payload.actionType) {
      case 'country-update':
      case 'city-update':
        flightDispatcher.waitFor([CityStore.dispatchToken]);
        FlightPriceStore.price =
          getFlightPriceStore(CountryStore.country, CityStore.city);
        break;
  }
});
#+END_SRC

The ~country-update~ payload will be guaranteed to invoke the stores' registered
callbacks in order: ~CountryStore~, ~CityStore~, then ~FlightPriceStore~.

*** Flux Utils

#+CINDEX:Flux utils
#+CINDEX:utility classes, Flux
#+CINDEX:class, Flux utility
We have also provided some basic utility classes to help get you started with
Flux.  These base classes are a solid foundation for a simple Flux application,
but they are *not* a feature-complete framework that will handle all use cases.
There are many other great Flux frameworks out there if these utilities do not
fulfill your needs.

{{{heading(Usage)}}}

There are four[sic] main classes exposed in Flux Utils:

1. Store
2. ReduceStore
3. Container

These base classes can be imported from ~flux/utils~ like this:

#+NAME:flux-utils.js
#+CAPTION:Importing base classes from ~flux/utils~
#+BEGIN_SRC js :eval never
import {ReduceStore} from 'flux/utils';

class CounterStore extends ReduceStore<number> {
  getInitialState(): number {
    return 0;
  }

  reduce(state: number, action: Object): number {
    switch (action.type) {
      case 'increment':
        return state + 1;

      case 'square':
        return state * state;

      default:
        return state;
    }
  }
}
#+END_SRC

* Twitter and Snapkite

** Twitter Docs

- [[https://developer.twitter.com/en/docs.html][Twitter Docs]]

** Twitter Tutorial on Consuming Streaming Data

- [[https://developer.twitter.com/en/docs/tutorials/consuming-streaming-data][Consuming streaming data]]

** Snapkite Engine

Snapkite Engine gives you filtered stream of photos posted publicly on Twitter.

- [[https://github.com/Snapkite][Snapkite on Github]]
- [[https://github.com/snapkite/snapkite-engine][Snapkite Engine on Github]]

It can do 2 (either or both) things with those photos:

1. Send them to a socket connection and allow all your clients to receive them
   in real-time.
2. Store them in MongoDB and retrieve later with [[https://github.com/snapkite/snapkite-api-server.git][Snapkite API Server]] or your
   own application.

{{{heading(Examples)}}}

- [[http://snapterest.com/][Snapterest.com]]
- [[http://map.snapkite.com/][Map.Snapkite.com]]

*** Installation Instructions

- https://github.com/snapkite/snapkite-engine#install


1. git clone https://github.com/Snapkite/snapkite-engine.git
2. cd snapkite-engine
3. npm install
4. cp example.config.json config.json
5. Add your Twitter API keys to config.json
6. Change default MongoDB config in config.json

*** Configure Instructions

- https://github.com/snapkite/snapkite-engine#configure


You can configure Snapkite Engine by editing config.json.

- ~application.pushTweets~ :: Send tweets to client?  Expects true or false.

- ~application.storeTweets~ :: Store tweets in a MongoDB collection?  Expects
     true or false.

- ~application.pushKeywords~ :: Send keyword stats to client?  Expects true or
     false.

- ~application.trackKeywords~ ::
     Which keywords should we ask Twitter to track for us?  Expects a string of
     keywords separated by a single whitespace or comma, e.g.: =selfie london= or
     =selfie,london=

     Read this for more details:
     https://dev.twitter.com/streaming/overview/request-parameters#track

- ~application.excludeKeywords~ ::
     Which keywords should be ignored?  Expects a string of keywords separated
     by a comma, e.g.: =exclude,these,keywords=

- ~application.filters~ ::
     List of Snapkite filters that this application should use. You can find
     the list of all available filters [[https://github.com/snapkite/snapkite-engine/tree/master/filters/README.md][here]].

- ~application.twitter.api~ ::
     Twitter API keys that Twitter provides you with. You can find them [[https://apps.twitter.com/][here]].

- ~application.database~ : :MongoDB connection configuration.

- ~application.socket~ :: Socket configuration.

*** Snapkite Filters

[[https://github.com/snapkite/snapkite-filters/blob/master/README.md][Everything you need to know]] about Snapkite filters.

*** MongoDB

https://github.com/snapkite/snapkite-engine#mongodb

* Babelify
:PROPERTIES:
:APPENDIX: t
:END:

[[https://github.com/babel/babel][Babel browserify]] transform.

- [[https://www.npmjs.com/package/babelify][Babelify on npm]]
- [[https://babeljs.io/][Babel]]
- [[https://github.com/babel/babel][Babel on Github]]

Babel is a compiler for writing next generation JavaScript. 

** Installation

{{{heading(Babel 7)}}}

: $ npm install --save-dev babelify @babel/core

{{{heading(Babel 6)}}}

: $ npm install --save-dev babelify@6 babel-core

** Usage

{{{heading(Presets and Plugins)}}}

NOTE: Presets and plugins need to be installed as separate modules. For the
examples to work, you'd need to also install ~@babel/preset-env~ and
~@babel/preset-react~:

{{{subheading(CLI)}}}

: $ browserify script.js -o bundle.js -t [ babelify \
: --presets [ @babel/preset-env @babel/preset-react ] \
: --plugins [ @babel/plugin-transform-class-properties ] ]

{{{subheading(Node)}}}

#+BEGIN_SRC js :eval never
var fs = require("fs");
var browserify = require("browserify");
browserify("./script.js")
  .transform("babelify", {presets: ["@babel/preset-env", "@babel/preset-react"]})
  .bundle()
  .pipe(fs.createWriteStream("bundle.js"));
#+END_SRC

{{{subheading(Options)}}}

See the babel docs for the complete list of [[http://babeljs.io/docs/usage/options/][options]].

* Listings
:PROPERTIES:
:APPENDIX: t
:END:
#+TEXINFO:@listoffloats Listing

* Figures
:PROPERTIES:
:APPENDIX: t
:END:
#+TEXINFO:@listoffloats Figure
* Index
  :PROPERTIES:
  :INDEX:    cp
  :END:
* COPYING
  :PROPERTIES:
  :COPYING:  t
  :END:
  {{{TITLE}}} by {{{AUTHOR}}}
  \copy 2015 Packt Publishing

#+BEGIN_QUOTE
A fast-paced guide to designing and building scalable and maintainable web apps
with React.js
#+END_QUOTE

Outline prepared by WLHarvey \copy {{{date(%F)}}}
* MACROS                                                           :noexport:
#+MACRO:heading @@texinfo:@heading @@$1
#+MACRO:subheading @@texinfo:@subheading @@$1
#+MACRO:tiauthor @@texinfo:@author @@$1
#+MACRO:key @@texinfo:@key{@@$1@@texinfo:}@@
#+MACRO:file @@texinfo:@file{@@$1@@texinfo:}@@
#+MACRO:command @@texinfo:@command{@@$1@@texinfo:}@@
#+MACRO:samp @@texinfo:@samp{@@$1@@texinfo:}@@
#+MACRO:cite @@texinfo:@cite{@@$1@@texinfo:}@@
#+MACRO:noindent @@texinfo:@noindent @@
#+MACRO:dfn @@texinfo:@dfn{@@$1@@texinfo:}@@
* EXPORT SETTINGS                                                  :noexport:
#+OPTIONS: h:4
#+TEXINFO_CLASS: info
#+TEXINFO_HEADER:
#+TEXINFO_POST_HEADER:
#+TEXINFO_DIR_CATEGORY: React
#+TEXINFO_DIR_TITLE: React.js Essentials
#+TEXINFO_DIR_DESC:Fast-paced guide to designing web apps with React.js
