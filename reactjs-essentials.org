# -*- mode: org; fill-column: 79; -*-

#+TITLE: React.js Essentials
#+SUBTITLE: A fast-paced guide to designing and building scalable and maintainable web apps with React.js
#+AUTHOR: Artemij Fedosejev
#+DATE: <2019-03-03 Sun 11:34>

#+TEXINFO: @insertcopying

* Preface
:PROPERTIES:
:UNNUMBERED: t
:END:

#+CINDEX:imperative code
#+CINDEX:declarative code
#+CINDEX:jQuery
#+CINDEX:modular
#+CINDEX:scalable
The Web is different.  The way we build for the Web is different.  Faced by the
challenges of dealing with unmaintainable /imperative code/ produced by jQuery
we had to look for new ways of managing the complexity of modern user
interfaces.  We needed a new user interface library that would help us build
/declarative/, /modular/, fast and /scalable/ frontend applications.

{{{subheading(React.js --- User Interface Library)}}}

#+CINDEX:user interface library
#+CINDEX:Facebook
#+CINDEX:DOM
#+CINDEX:data flow, organize
Meet React.js --- a JavaScript user interface library developed by Facebook.
It brings profound ideas on how to work with the DOM, organize your
application's data flow, and think about user interface elements as individual
components.  And yet, it's only a user interface library that makes no
assumptions about the rest of your technology stack.

{{{subheading(With Flux)}}}

#+CINDEX:Flux
#+CINDEX:frontend architecture
Combined with Flux, we get a powerful frontend architecture that makes sense
not only to experienced developers, but also those who are just starting their
frontend journey.

** From the Author

  #+CINDEX:Fedosejev, Artemij
- [[https://github.com/fedosejev][Artemij Fedosejev]]

  #+CINDEX:tutorials, React
- [[https://react.tips][React Tutorials]]

- [[https://react.tips/from-react-to-flux-to-redux/][From React.js To Flux To Redux]]

  If you want to really understand what's the difference between building web
  apps with React only, or with React and Flux, or with React and Redux, then
  check the four examples that I've prepared for you.

  #+CINDEX:shopping list app examples
  #+CINDEX:examples, shopping list app
  They all implement exactly the same Shopping List app, but most importantly -
  they highlight the difference in how you approach building web apps using
  different tools.

    #+CINDEX:ES5 JavaScript
    #+CINDEX:JavaScript ES5
  - Built with React.js and JavaScript ES5

    In this [[https://github.com/fedosejev/shopping-list-react][example]], I am using only React.js without Flux or Redux to build
    the entire app. And I am using the good old JavaScript that all know and
    love (or hate?): version ECMAScript 5.

    This example is the best place for you to start if you're not familiar with
    Flux or Redux at all. It helps you to understand why we need Flux or
    Redux. You will feel strange when storing application state (the shopping
    list itself) in React components, knowing that React should only be
    responsible for knowing how to render the user interface.

    #+CINDEX:ES2015, JavaScript
    #+CINDEX:JavaScript ES2015
  - Built with React.js and JavaScript ES2015

    The industry uses a newer version of JavaScript today: ECMAScript 2015. It
    brings new syntax and React takes advantage of that syntax.

    If you want to see how to transition from tradition ES5 syntax to newer
    ES2015 syntax in the context of React app, then this [[https://github.com/fedosejev/shopping-list-react-es2015][example]] is perfect for
    you. Feel free to compare it with the the previous one (ES5 version).

    #+CINDEX:Flux with ES5
    #+CINDEX:ES5 and Flux
  - Built with React.js and Flux and JavaScript ES5

    If React feels familiar to you and you can build simple apps with it then
    you most likely faced a problem of accessing application state from
    different React components. It's not a straight forward task! And it feels
    awkward, because we know that React is a UI library, and if we follow the
    separation of concerns principle, then it's clear to us that we shouldn't
    store application state in React components!

    Where do we store it then? That's why you might need to introduce Flux
    architecture to your React application.

    This [[https://github.com/fedosejev/shopping-list-react-flux][example]] is a perfect introduction to the Flux architecture, because
    you're building exactly the same app, but now you're clearly separating
    your UI logic from your application state logic.

    #+CINDEX:Redux with ES2015
    #+CINDEX:ES2015 and Redux
  - Built with React.js and Redux and JavaScript ES2015

    Flux is a great start for understanding how data flows in your React
    application. Redux takes it to the next level by building on top of ideas
    from Flux and introducing new important concepts that allow you to build
    really scalable and robust React apps.  See [[https://github.com/fedosejev/shopping-list-react-redux][example]].

** What this Book Covers

*** Chapter 1 Installing Powerful Tools

- Goals
- Tools
- Structure for project

*** Chapter 2 Create Your First React Element

- Install React
- Virtual DOM
- React Element
- Create and render a React element
- with native JavaScript
- JSX syntax
- Create React Elements using JSX

*** Chapter 3 Create Your First React Component

- React components
- Difference between stateless and stateful React components
- Creates both kinds

*** Chapter 4 Make Your React Components Reactive

- How to solve problems with React
- Plan a React application
- Create a React component that encapsulates entire app
- Relationship between parent and child React components

*** Chapter 5 Use Your React Components with Another Library

- How to use third party JavaScript libraries
- React component's lifecycle
- How to use mounting methods
- Create new components for project

*** Chapter 6 Update Your React Components

- React component lifecycle's updating mnethods
- CSS styles in JavaScript
- Validate and set default component properties

*** Chapter 7 Build Complex React Components

- Building more complex React components
- Implement different React components
- Put them together into one coherent and functional app

*** Chapter 8 Test Your React Application with Jest

- Unit testing
- Write and run unit tests with Jest
- Test React components
- Test suites, specs, expectations, and matchers

*** Chapter 9 Supercharge Your React Architecture with Flux

- Improve the architecture of React application
- Flux architecture
- Role of dispatcher, stores, and and action creators

*** Chapter 10 Prepare Your React Application for Painless Maintenance with Flux

- Decouple concerns in a React app with Flux
- Refactor React app to allow painless maintainability

** What You Need for this Book

1. Latest version of a modern web browser, e.g.,
   - [[https://www.google.com/chrome/browser][Google Chrome]]
   - [[https://www.mozilla.org/en-US/firefox/new/][Mozilla Firefox]]

2. Git

3. Node.js

4. npm

5. Code editor, e.g.
   - [[http://www.sublimetext.com][Sublime Text]]
   - [[https://atom.io][Atom]]
   - [[http://brackets.io][Brackets]]
   - [[https://code.visualstudio.com][Visual Studio Code]]
   - Your choice

** Who this Book is For

This book is intended for frontend developers who want to build scalable and
maintainable user interfaces for the Web.  Some core knowledge of JavaScript,
HTML, and CSS is the only thing you need to know to start benefiting.  If you
have previous experience with jQuery or Angular.js, then you will benefit from
understanding how React.js is different and how to take advantage of
integrating different libraries with it.

** Conventions

** Reader Feedback

** Downloading the Example Code

https://github.com/fedosejev/react-essentials

** Errata

https://wwwpacktpub.com/books/content/support

enter the name of the book in the search field.

* Installing Powerful Tools for your Project

#+CINDEX:Kettering, Charles
#+BEGIN_QUOTE
My interest is in the future because I am going to spend the rest of my life
there.
{{{tiauthor(Charles F. Kettering)}}}
#+END_QUOTE

#+CINDEX:spaghetti code
#+CINDEX:mental model, spaghetti
This brilliant inventor has left software engineers with the single most
important piece of advice way before we even started thinking about how to
write software.  Yet, half a century later, we're still figuring out why we end
up with spaghetti code or the ``spaghetti mental model.''

{{{heading(Writing Softward for the Future)}}}

#+CINDEX:mental model
#+CINDEX:complexity remains the same
What does it mean to ``write software for the future, today''?  It boils down
to creating a simple mental model that doesn't change, no matter how big your
project becomes over time.  When the size of your project grows, the complexity
always stays the same.  This mental model is your blueprint, and once you
understand it you will understand how your whole piece of software works.

{{{heading(Facebook Releases React in 2013)}}}

#+CINDEX:Facebook
#+CINDEX:Occhino, Tom
In 2013, Facebook released React---an open source JavaScript library for
building user interfaces.  You can read more about it at
http://facebook.github.io/react/.  In early 2015, Tom Occhino from Facebook
summarized what makes React so powerful:

{{{heading(Declarative vs Imperative Programming)}}}

#+BEGIN_QUOTE
React wraps an imperative API with a declarative one.  React's real power lies
in how it makes you to write code.
{{{tiauthor(Tom Occhino)}}}
#+END_QUOTE

#+CINDEX:declarative style
#+CINDEX:imperative style
#+CINDEX:DOM API
#+CINDEX:jQuery
A declarative style of programming results in less code.  It tells a computer
what to do without specifying how, while an imperative style of programming
describes how to do it.  JavaScript's call to the DOM API is an example of
imperative programming.  jQuery is another such example.

{{{heading(React is Good for Small Projects)}}}

#+CINDEX:small React project
#+CINDEX:shopping list
It works for small projects too; here is an example of a [[http://fedosejev.github.io/shopping-list-react][shopping list]] build
with React.  React is one of the best JavaScript libraries used for building
user interfaces that is available for developers today.

{{{heading(The Goal of this Book)}}}

#+CINDEX:goal
#+CINDEX:fundamental principles of React
#+CINDEX:React's fundamental principles
#+CINDEX:principles, fundamental
#+CINDEX:project, real-time web application
Goal is for you to understand the fundamental principles of React.  To achieve
this, you will be introduced to one React component at a time, explained it,
and shown how you can apply it.  Step by step, you'll build a real-time web
application, raise important questions along the way, and discuss solutions
that React provides us with.

{{{heading(Flux)}}}

#+CINDEX:Flux
#+CINDEX:mental model
You will learn about [[*Flux][Flux]], which implements a unidirectional flow of data.
Together with Flux and React, you'll create a predictable and manageable code
base that you will be able to expand by adding new features, without scaling
its complexity.  The mental model of how your web application works will stay
the same, no matter how many new features you add later.

** Approaching our Project

The best motivation for learning new technology is a project that excites you
and that you can't wait to build.  In this book the author wants you to build a
project that feels like a breath of fresh air.  A project which you most likely
wouldn't build in your day-to-day work.  It has to be a fun endeavor, which not
only educates you but also satisfies your curiosity and stretches your
imagination.  This project shouldn't be a time consuming long-term commitment
for you either.

#+CINDEX:Snapterest
#+CINDEX:project Snapterest
#+CINDEX:Twitter
#+CINDEX:Pinterest
#+CINDEX:website functionality
Enter *Snapterest*---a web application that allows you to discover and collect
public photos posted on Twitter.  Think of it as Pinterest with the only source
of pictures being Twitter.  We will implement a fully functional website with
the following core functionalities:

- Receiving and displaying tweets in real time

- Adding and removing tweets to / from a collection

- Reviewing collected tweets

- Exporting a collection of tweets as an HTML snippet that you can share


#+CINDEX:tools
When you start working on a new project, the very first thing that you do is
get your tools ready.  For this project, we will be using a number of tools.

** DONE Installing Node.js and npm
:todo:
:task: Check for Jest and Node.js compatibility currently
:end:

  #+CINDEX:Node.js, installation
- [[https://nodejs.org][Node.js]] ::

     #+CINDEX:JavaScript
     #+CINDEX:Node.js benefits
     #+CINDEX:event-driven
     #+CINDEX:non-blocking
     #+CINDEX:real-time
     is a platform that allows us to write server-side applications with a
     client-side language: JavaScript.  The real benefit of Node.js is that it
     uses an /event-driven/, /non-blocking I-O/ model, which is perfect for
     building /data-intensive/, /real-time/ applications.  It means that, with
     Node.js, we should be able to handle an incoming stream of tweets and
     process them as soon as they arrive.


- [[https://nodejs.org/en/][Node.js Home]]

<<install-node.js>>{{{heading(Install Node.js)}}}

#+CINDEX:install Node.js
#+CINDEX:Jest
Install Node.js.  We'll be using version =v0.10.40= because, at the time
of writing this book, that's the latest version of Node.js that Jest
supports.[fn::The current versions of Node.js as of the publication of
this document ({{{date}}}) are =10.15.2 LTS= and =11.10.1 Current=.  The
current version of Jest is =24.1=, which appears to work with the current
version of Node.js and React.]

#+CINDEX:distribution, Node.js
#+CINDEX:installation package, Node.js
- Go to http://nodejs.org/dist/v0.10.40/ and download the installation package
  for your OS:

    #+CINDEX:OS X
  - [[http://nodejs.org/dist/v0.10.40/node-v0.10.40-darwin-x64.tar.gz][OS X]]:[fn::Created 09-Jul-2015 21:30] ::

      Run it and follow the installation steps that Node.js will prompt you with.
      Test for successful installation:
      : $ node -v
      : v0.10.40


{{{subheading(npm Should Be Installed with Node.js)}}}
  #+CINDEX:npm, installation
- [[http://www.npmjs.com][npm]][fn::Current npm version is =6.8.0= as of {{{date}}}] ::

  #+CINDEX:package manager, npm
  is a package manager that manages Node.js modules.  It is shipped with
     Node.js, so it was installed by the previous step.  To test:
     : $ npm -v
     : 1.4.28

** Installing Git

#+CINDEX:Git
#+CINDEX:install Git
#+CINDEX:getting started with Git
<<install-git>>We'll be using Git to install Node.js modules.  Visit:
- [[https://git-scm.com/book/en/v2/Getting-Started-Installing-Git][{{{cite(1.5 Getting Started - Installing Git)}}}]]

{{{noindent}}}and follow the installation instructions for your OS.

** Getting Data from the Twitter Streaming API

#+CINDEX:Twitter Streaming API
#+CINDEX:Streaming API, Twitter
#+CINDEX:tweets, receive public
#+CINDEX:JSON format, tweets
<<twitter-streaming>>The data for our React application will come from Twitter.
Twitter has the *Streaming API* that anyone can plug into to start receiving an
endless flow of public tweets in the JSON format.

To start using the Twitter Streaming API, you'll need to perform the following
steps:

{{{subheading(Create a Twitter Account and App)}}}

   #+CINDEX:Twitter account, create
1. <<create-twitter-account>>Create a Twitter account.  For this, go to
   https://twitter.com and sign up; or sign in if you already have an account.

   #+CINDEX:Twitter app, create
2. <<create-twitter-app>>Create a new Twitter App by navigating to
   https://apps.twitter.com and click on {{{key(Create New App)}}}.  You will
   need to fill in the *Application Details* form, agree with the *Developer
   Agreement*, and click on *Create your Twitter application*.  Now you should
   see your application's page.


{{{subheading(Get Twitter Keys)}}}

<<twitter-keys>>Switch to the *Keys and Access Tokens* tab.  In the
*Applications Settings* section of this page, you'll find two vital pieces of
information:

   #+CINDEX:Twitter API keys
   #+CINDEX:keys, Twiter API
1. Consumer Key (API Key)

2. Consumer Secret (API Secret)


Take a note of them.

{{{subheading(Create a Twitter Access Token)}}}

#+CINDEX:access token, Twiter API
<<twitter-token>>Now generate an /access token/.  On the same page, you'll see
*Your Access Token* section that is empty.  Click on {{{key(Create my access
token)}}}.  It creates two pieces of information:

1. Access Token

2. Access Token Secret


Take a note of them too.  An access token is unique to you and you should not
share it with anyone.  Keep it private.

** Filtering Data with Snapkite Engine
:PROPERTIES:
:CUSTOM_ID: Snapkite Engine
:END:

#+CINDEX:filter
We need to filter the stream of data from the Twitter Streaming API into a
meaningful set of tweets that we can display and interact with.

#+CINDEX:Twitter Streaming API documentation
You should first take a quick look at the [[https://dev.twitter.com/streaming][Twitter Streaming API documentation]].
In particular take a look at the page that describes how to [[https://dev.twitter.com/streaming/reference/post/statuses/filter][filter]] an incoming
stream.  Twitter provides very few filters that we can apply, so we need to
find a way to filter that stream of data even further.

{{{heading(Snapkite Engine)}}}

#+CINDEX:Snapkite Engine Node.js application
#+CINDEX:Twitter Streaming API, filter engine for
#+CINDEX:tweets, filtered
#+CINDEX:web socket connection for filtered tweets
There is a Node.js application just for this.  It's called [[https://github.com/snapkite/snapkite-engine][Snapkite Engine]].
It connects to the Twitter Streaming API, filters it using the available
filters and according to the rules that you define, and outputs the filtered
tweets to a web socket connection.  Our React app can listen to the events on
that socket connection and process tweets as they arrive.

*** Install the Snapkite Engine
:PROPERTIES:
:CUSTOM_ID: install Snapkite Engine
:END:

   #+CINDEX:Snapkite Engine, install
1. Clone the Snapkite Engine repository into a directory of your choice:
   : cd <dir>
   : git clone https://github.com/snapkite/snapkite-engine.git
   This should create the ~<dir>/snapkite-engine~ folder.

   #+CINDEX:Node-Gyp module
2. <<install-node-gyp>>Now install the other node modules that
   ~snapkite-engine~ depends on.  One of them is the ~node-gyp~ module.  Also
   install other tools that are listed on [[https://github.com/TooTallNate/node-gyp#installation][node-gyp installation]].

3. Once you install them, you're ready to install the ~node-gyp~ command:
   : npm install --global node-gyp

4. Navigate to the ~<dir>/snapkite-engine~ directory to install the Node.js
   modules that Snapkite Engine depends on:
   : cd <dir>/snapkite-engine/
   : npm install

   #+CINDEX:Snapkite Engine, configure
   #+CINDEX:configure Snapkite Engine
5. <<configure-Snapkite>>Configure Snapkite Engine.  Assuming you are in the
   ~<dir>/snapkite-engine/~ directory, copy the ~./example.config.json~ file to
   ~./config.json~ by the following command:
   : cp example.config.json config.json

   #+CINDEX:@file{config.json}
6. <<config.json>>Open ~config.json~ in your editor to edit the configuration
   properties.

      #+CINDEX:@code{trackKeywords}
   - <<trackKeywords>>~trackKeywords~ ::
        This is where we will tell what keywords we want to track.  If we want
        to track the keyword =my=, then set it as follows:
        : "trackKeywords": "my"

   #+CINDEX:Twitter Streaming API keys, access token
   #+CINDEX:keys, Twitter Streaming API
   #+CINDEX:access token, Twitter Streaming API
7. <<Twitter-keys-and-token>>Set our Twitter Streaming API keys.  Set:
   - ~consumerKey~
   - ~consumerSecret~
   - ~accessTokenKey~
   - ~accessTokenSecret~
     #+CINDEX:Snapkite Engine documentation
     #+CINDEX:documentation, Snapkite Engine
   - other properties can be set to their defaults[fn::check out the Snapkite
     Engine [[https://github.com/snapkite/snapkite-engine][documentation]]]

   #+CINDEX:Snapkite Filter module
   #+CINDEX:Snapkite Filters, list
8. <<install-Snapkite-filters>>Install Snapkite Filters.  =Snapkite Filter= is
   a Node.js module that validates tweets according to a set of rules.  There
   are a number of Snapkite Filters out there, and we can use any combination
   of them to filter our stream of tweets as we like.  You can find a list of
   all available Snapkite Filters at
   https://github.com/snapkite/snapkite-filters.

   #+CINDEX:Snapkite Filters, used in project
   In our application, we'll use the following Snapkite Filters:

     #+CINDEX:@code{is-possibly-sensitive} Snapkite filter
   - <<is-possibly-sensitive-filter>>Is Possibly Sensitive ::
        https://github.com/snapkite/snapkite-filter-is-possibly-sensitive

     #+CINDEX:@code{has-mobile-photo} Snapkite filter
   - <<has-mobile-photo-filter>>Has Mobile Photo ::
        https://github.com/snapkite/snapkite-filter-has-mobile-photo

     #+CINDEX:@code{is-retweet} Snapkite filter
   - <<is-retweet-filter>>Is Retweet ::
        https://github.com/snapkite/snapkite-filter-is-retweet

     #+CINDEX:@code{has-text} Snapkite filter
   - <<has-text-filter>>Has Text ::
        https://github.com/snapkite/snapkite-filter-has-text


   #+CINDEX:install Snapkite filters
   #+CINDEX:Snapkite filters, install
   Install them.  Navigate to the ~<dir>/snapkite-engine/filters/~ directory:
   : cd <dir>/snapkite-engine/filters/
   Clone all Snapkite Filters by running these commands:
   : git clone https://github.com/snapkite/snapkite-filter-is-possibly-sensitive
   : git clone https://github.com/snapkite/snapkite-filter-has-mobile-photo
   : git clone https://github.com/snapkite/snapkite-filter-is-retweet
   : git clone https://github.com/snapkite/snapkite-filter-has-text

   #+CINDEX:Snapkite filters, configure
   #+CINDEX:configure Snapkite filters
9. <<configure-Snapkite-filters>>Configure them.  In order to do so, you need
   to create a configuration file for each Snapkite Filter in JSON format and
   define some properties in it.  Each Snapkite Filter comes with an example
   configuration file that we can duplicate and edit as needed.

   While in the ~<dir>/snapkite-engine/filters/~ directory, run the following
   commands:

   : cp snapkite-filter-is-possibly-sensitive/example.config.json
   : snapkite-filter-is-possibly-sensitive/config.json

   : cp snapkite-filter-has-mobile-photo/example.config.json
   : snapkite/snapkite-filter-has-mobile-photo/config.json

   : cp snapkite-filter-is-retweet/example.config.json
   : snapkite-filter-is-retweet/config.json

   : cp snapkite-filter-has-text/example.config.json
   : snapkite-filter-has-text/config.json

   We don't need to change any of the default settings in these ~config.json~
   files, as they are already configured to fit our purposes.

10. <<Snapkite-config.json>>Tell Snapkite Engine which Snapkite Filters it
    should use.  Open the ~<dir>/snapkite-engine/config.json~ file in a text
    editor and look for this:
    : "filters" : []

    Now replace that with the following:

    #+NAME:config.json
    #+CAPTION:Snapkite Engine ~config.json~
    #+BEGIN_SRC js :eval never
    "filters": [
        "snapkite-filter-is-possibly-sensitive",
        "snapkite-filter-has-mobile-photo",
        "snapkit-filter-is-retweet",
        "snapkite-filter-has-text"
    ]
    #+END_SRC


#+CINDEX:Snapkite Engine, test run
<<test-Snapkite-Engine>>With that you have successfully installed Snapkite
Engine with a number of Snapkite Filters.  Now let's check if we can run it.
Navigate to ~<dir>/snapkite-engine~ and run:
: npm start


You should see no error messages.  If you do and you are not sure how to fix
them, go to https://github.com/fedosejev/react-essentias/issues, create a new
issue and copy/paste the error message that you get.

** Creating the Project Structure

#+CINDEX:project structure, create
#+CINDEX:structure organization
#+CINDEX:organization of project
#+CINDEX:architecture of project
Now create our project structure.  Organizing source files is not a simple
task.  A well-thought-out project structure organization helps us understand
the underlying architecture of our application.

{{{subheading(Root Project Directory)}}}

#+CINDEX:root project directory
#+CINDEX:@file{snapterest} directory
<<create-root-project-directory>>Start by creating a /root project directory/
named {{{file(snapterest/)}}} inside a directory of your choice:
{{{file(<dir>/snapterest/)}}}.  Inside it create two other directories:

  #+CINDEX:@file{source} directory
  #+CINDEX:@file{components} directory
  #+CINDEX:directories, @file{source}, @file{components}
- <<source-directory>>{{{file(<dir>/snapterest/source/)}}} ::
     store our source JavaScript files
     - {{{file(components/)}}} ::
       create this directory inside the {{{file(source/)}}} directory

  #+CINDEX:@file{build} directory
  #+CINDEX:directory, @file{build}
- <<build-directory>>{{{file(<dir>/snapterest/build/)}}} ::
     store compiled JavaScript files and an HTML file


{{{subheading(Populate the project structure with an application file)}}}

   #+CINDEX:@file{app.js}
   #+CINDEX:application file, @file{app.js}
- <<application-file>>{{{file(app.js)}}} ::

     place the main application file in the ~source/~ directory.  This file
     will be the entry point to our application.  Leave it empty for now.

** Building the Project

   #+CINDEX:DRY
   #+CINDEX:code reuse
- *DRY*: *Don't Repeat Yourself* ::

     One of the core principles in software development --- code reuse: The
     best code is the one that you don't need to write.  One of the goals in
     this project is to write as little code as possible.  React helps us
     achieve this goal.

#+CINDEX:declarative programming style
#+CINDEX:programming style, declarative
#+CINDEX:code reuse
When it comes to not writing code, we can apply the following strategies:

- Writing our code in a /declarative/ programming style
- Reusing the code written by someone else


#+CINDEX:jQuery
We'll be using both these techniques.  The first one is covered by React
itself.  React leaves us no choice but to write our JavaScript code in a
/declarative/ style.  This means that instead of telling our web browser how to
do what we want (like we do in jQuery), we just tell it what we want it to do
and the how part is explained by React.

#+CINDEX:npm
Node.js and npm cover the second technique.  There are over a hundred thousand
different Node.js applications available for us to use.  This means that most
likely someone has already implemented the functionality that our application
depends on.

#+CINDEX:@command{npm install}
#+CINDEX:@file{package.json}
#+CINDEX:metadata, project
#+CINDEX:project metadata
The question is how do we know from where to get all these Node.js applications
that we want to reuse.  We can install them via the ~npm install
<package-name>~ command.  In the npm context, a Node.js application is called a
*package*, and each *npm package* has a ~package.json~ file that describes the
metadata associated with that package.[fn::[[https://docs.npmjs.com/files/package.json][package.json docs]]]

*** Create ~package.json~
:PROPERTIES:
:CUSTOM_ID: create package.json
:END:

#+CINDEX:package initialization
#+CINDEX:initialize a package
#+CINDEX:metadata file
#+CINDEX:@file{package.json}
#+CINDEX:@command{npm install}
Before we install our /dependency packages/, we will /initialize/ a *package*
for our own project.  Normally, ~package.json~ is only required when you want
to submit your package to the npm registry so that others can reuse your
Node.js application.  We're not going to build a Node.js application, and we're
not going to submit our project to npm.  ~package.json~ is technically only a
metadata file that the ~npm~ command understands, and as such, we can use it to
store a list of dependencies that our application requires.  Once we store a
list of dependencies in ~package.json~, we can easily install them anytime with
the ~npm install~ command; npm will figure out from where to get them
automatically.

#+CINDEX:@file{package.json} create
#+CINDEX:create @file{package.json}
How do we create the ~package.json~ file for our own application?  npm comes
with an interactive tool that asks us a bunch of questions and then, based on
our answers, creates ~package.json~ for our project.

#+CINDEX:@command{npm init}
#+CINDEX:initialize @file{package.json}
<<run-npm-init>>From the ~<dir>/snapterest/~ directory, run:
: npm init
Accept all the defaults.

#+CINDEX:modular application
#+CINDEX:modules
#+CINDEX:Node.js modules
Now we are ready to install other Node.js applications that we are going to
reuse.  An application that is built of multiple individual applications is
called /modular/ whereas individual applications are called /modules/.  This is
what we will call our Node.js dependencies from now on: *Node.js modules*

*** About Reusing Node.js Modules

#+CINDEX:build development process
#+CINDEX:build script
#+CINDEX:packaging
<<building>>There will be a step in our development process called /building/.
During this step, our build script will take our source files and all our
Node.js dependency packages, and transform them into a single file that web
browsers can successfully execute.  The most important part of this building
process is called /packaging/.  But what do we need to package and why?  We're
not creating a Node.js application, but yet we're talking about reusing Node.js
modules.  Does this mean that we'll be reusing Node.js modules in a non-Node.js
application?  Is that even possible?  Yes, there is a way of doing that.

**** Installing Browserify

#+CINDEX:Browserify
#+CINDEX:bundling, Browserify
<<Browserify>>*Browserify* is a tool used for bundling all your dependency
files together in such a way that you can reuse Node.js modules in client-side
JavaScript applications.  You can learn more about it at [[http://browserify.org][Browserify]].

#+CINDEX:install Browserify
To install Browserify, run the following command from inside the
~<dir>/snapterest/~ directory:
: npm install --save-dev browserify

Browserify will allow us to use Node.js modules in our client-side JavaScript
applications.  It will be a part of our build process.

*** Building with Gulp.js

#+CINDEX:Gulp.js
<<Gulp.js>>Today, any modern client-side application represents a mix of many
concerns that are addressed individually by various technologies.  Addressing
each concern individually simplifies the overall process of managing the
project's complexity.  The downside of this approach is that at some point in
your project, you need to put together all the individual parts into one
coherent application.  Developers have something called build-tools that
assemble their projects from individual modules.  This process is called the
/build/ process and, depending on the size and complexity of your project, it
can take anywhere from milliseconds to hours to build.

{{{subheading(Installing Gulp.js and ~gulpfile.js~)}}}

The Node.js ecosystem has a great tool for automating our build process,
*Gulp.js*.  You can learn more about it at [[http://gulpjs.com][Gulp]].

#+CINDEX:install Gulp.js
#+CINDEX:Gulp.js installation
Let's install it.
: npm install --save-dev gulp
: npm install --global gulp

{{{subheading(An Example ~gulpfile.js~)}}}

#+CINDEX:gulpfile
#+CINDEX:@file{gulpfile.js}
<<example-gulpfile.js>>What is a /gulpfile/?  It's a file where we describe our
build process.  Create ~gulpfile.js~ in your ~<dir>/snapterest/~ directory and
add the following content to it:

#+NAME:example-gulpfile.js
#+CAPTION:Example of a ~gulpfile.js~
#+BEGIN_SRC js :eval never
var gulp = require('gulp');

gulp.task('default', function() {
    console.log('I am about to learn the essentials of React.js');
});
#+END_SRC

#+CINDEX:@command{gulp} command
<<gulp-command>>Now if you run the ~gulp~ command, you will see output that
looks like this:

#+BEGIN_EXAMPLE
Using gulpfile ~/<dir>/snapterest/gulpfile.js
Starting 'default'...
I am about to learn the essentials of React.js
Finished 'default' after 62 us
#+END_EXAMPLE

{{{subheading(Creating a Default Gulp Task)}}}

#+CINDEX:@samp{default} task
#+CINDEX:Gulp.js build system
#+CINDEX:Browserify
<<default-gulp-task>>By default, when you run ~gulp~, it executes a task called
=default=.  You now have a working Gulp.js build system.  Let's create a task
tht will package our source and dependency modules using Browserify.

#+CINDEX:@file{gulpfile.js}
<<default-gulpfile.js>>Replace the contents of your ~gulpfile.js~ with the
following code:

#+NAME:default-gulp-task
#+CAPTION:A default ~gulpfile.js~ that will package source and dependency modules using Browserify
#+BEGIN_SRC js :eval never
var gulp = require('gulp');
var browserify = require('browserify');
var babelify = require('babelify');
var source = require('vinyl-source-stream');

gulp.task('default', function() {
    return browserify('./source/app.js')
        .transform(babelify)
        .bundle()
        .pipe(source('snapterest.js'))
        .pipe(gulp.dest('./build/'));
});
#+END_SRC

**** Install Babelify

#+CINDEX:Babelify
#+CINDEX:install @file{babelify} module
<<install-Browserify>>We have already installed the ~browserify~ module, so now
let's install the ~babelify~ module:
: npm install --save-dev babelify

#+CINDEX:JSX
The ~babelify~ module allows us to write the JSX syntax that we'll introduce in
the next chapter.

**** Install Vinyl-Source-Stream Module

#+CINDEX:Vinyl Source Stream module
#+CINDEX:Browserify and Gulp
<<install-Vinyl-Source-Stream>>Why do we need the ~vinyl-source-stream~ module?
It allows us to use Browserify and Gulp together.  For more details on why this
works, go to [[https://www.npmjs.com/package/vinyl-source-stream][Vinyl-Source-Stream]].  Let's install the ~vinyl-source-stream~
dependency module:
: npm install --save-dev vinyl-source-stream

**** Test Default Gulp Task

#+CINDEX:gulp default task
<<test-gulp-default-task>>Now we're ready to test our ~default~ task.  Run:
: gulp

The output should look something like:

#+BEGIN_EXAMPLE
Using gulpfile <dir>/snapterest/gulpfile.js
Starting 'default'...
Finished 'default' after 48 ms
#+END_EXAMPLE

#+CINDEX:@file{build} directory
#+CINDEX:@file{snapterest.js} file
The project's ~<dir>/snapterest/build/~ directory now has the ~snapterest.js~
file with some code already inside it---that's our (empty) JavaScript
application with some Node.js modules that are ready to run in a web browser.

*** Creating a Web Page
:PROPERTIES:
:CUSTOM_ID: create web page
:END:

#+CINDEX:@file{index.html} file
<<create-index.html>>All that is left to do is to create the ~index.html~ file
with a link to our ~snapterest.js~ script.  Create the ~index.html~ file in the
~<dir>/snapterest/build/~ directory.  Add the following HTML markup to it:

#+NAME:index.html
#+CAPTION:Project Snapterest ~index.html~
#+BEGIN_SRC html :eval never
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="x-ua-compatible" content="ie-edge, chrome=1" />
    <title>Snapterest</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
  </head>
  <body>
    <div id="react-application">
      I am about to learn the essentials of React.js.
    </div>
    <script src="./snapterest.js"></script>
  </body>
</html>
#+END_SRC

<<open-index.html>>Open ~<dir>/snapterest/build/index.html~ in a web browser.
You should see the following text: ``I am about to learn the essentials of
React.js.''

** Summary

- We learned why we should use React to build user interfaces for modern web
  applications.

- We discussed the project that we'll be building in this book.

- We installed all the right tools

- We created the project's structure.

*** Installation and Configuration Steps

- [[install-node.js][Node.js and npm]]
- [[install-git][Git]]
- [[twitter-streaming][Twitter Streaming API]]
  + [[create-twitter-account][Create a Twitter Account]]
  + [[create-twitter-app][Twitter App]]
    - [[twitter-keys][Keys]]
    - [[twitter-token][Token]]
- [[#Snapkite Engine][Snapkite Engine]]
  + [[#install Snapkite Engine][Install Snapkite Engine]]
  + [[install-node-gyp][Install =node-gyp= module and command]]
  + [[configure-Snapkite][Configure Snapkite Engine]]
    - [[config.json][~config.json~]]
    - [[trackKeywords][~trackKeywords~]]
    - [[Twitter-keys-and-token%0A][configure Twitter keys and access token]]
  + [[install-Snapkite-filters][Install Snapkite Filters]]
    - [[is-possibly-sensitive-filter][is possibly sensitive]]
    - [[has-mobile-photo-filter][has mobile photo]]
    - [[is-retweet-filter][is retweet]]
    - [[has-text-filter][has text]]
  + [[configure-Snapkite-filters][Configure Snapkite Filters]]
    - [[Snapkite-config.json][~config.json~]]
  + [[test-Snapkite-Engine][Test Snapkite Engine]]
- [[*Creating the Project Structure][Create Snapterest Project Structure]]
  - [[create-root-project-directory][create root project directory]]
    + [[source-directory][~source~ directory]]
    + [[build-directory][~build~ directory]]
    + [[application-file][~app.js~ file]]
    + [[#create package.json][~package.json~ file]]
      - [[run-npm-init][{{{command(npm init)}}}]]
- [[building][The Building Process]]
  + [[Browserify][Install Browserify]]
  + [[Gulp.js][Install Gulp.js]]
    - [[example-gulpfile.js][example ~gulpfile.js~]]
  + [[gulp-command][Run ~gulp~ command]]
    - [[default-gulp-task][default gulp task]]
    - [[default-gulpfile.js][default ~gulpfile.js~]]
  + [[install-Browserify][Install Browserify]]
  + [[install-Vinyl-Source-Stream][Install Vinyl-Source-Stream]]
  + [[test-gulp-default-task][Test Gulp Default Task]]
- [[#create web page][Create a Web Page]]
  + [[create-index.html][Create ~index.html~]]
  + [[open-index.html][Open ~index.html~]]

* Create Your First React Element

* Create Your First React Component

* Make Your React Component Reactive

* Use Your React Components With Another Library

* Update Your React Components

* Build Complex React Components

* Test Your React Application With Jest

* Supercharge Your React Architecture With Flux

* Prepare Your React Application for Painless Maintenance with Flux

* React.js
:PROPERTIES:
:APPENDIX: t
:END:

A JavaScript library for building user interfaces.

- [[https://reactjs.org/][React.js Home]]

* Flux
:PROPERTIES:
:APPENDIX: t
:END:

{{{heading(APPLICATION ARCHITECTURE FOR BUILDING USER INTERFACES)}}}

{{{subheading(An application architecture for React utilizing a unidirectional data flow.)}}}

Flux is the application architecture that Facebook uses for building
client-side web applications. It complements React's composable view components
by utilizing a unidirectional data flow. It's more of a pattern rather than a
formal framework, and you can start using Flux immediately without a lot of new
code.

- [[https://facebook.github.io/flux/][Flux Home]]
- [[https://github.com/facebook/flux][Flux Github Home]]
- [[https://facebook.github.io/flux/docs/overview.html][Flux Docs]]
- [[https://facebook.github.io/flux/docs/videos.html#content][Flux Videos]]

** Getting Started

Start by looking through the guides and examples on Github. For more resources
and API docs check out [[https://facebook.github.io/flux][facebook.github.io/flux]].

#+NAME:flux-diagram.png
#+CAPTION:Flux Diagram
[[file:img/flux-diagram-white-background-25.png]]

** How Flux works

For more information on how Flux works check out the [[https://github.com/facebook/flux/blob/master/examples/flux-concepts][Flux Concepts]] guide, or
the [[https://facebook.github.io/flux/docs/in-depth-overview.html#content][In Depth Overview]].

** Flux Concepts

#+CINDEX:Flux concepts
#+CINDEX:concepts of Flux
These are the important high-level concepts and principles you should know
about when writing applications that use Flux.

{{{heading(Overview)}}}

#+CINDEX:Flux overview
#+CINDEX:overview of Flux
Flux is a pattern for managing data flow in your application. The most
important concept is that /data flows in one direction/.  As we go through this
guide we'll talk about the different pieces of a Flux application and show how
they form /unidirectional cycles/ that data can flow through.

{{{subheading(Flux Parts)}}}

- Dispatcher

- Store

- Action

- View

*** Dispatcher

#+CINDEX:Dispatcher
#+CINDEX:actions
#+CINDEX:stores
#+CINDEX:register store with dispatcher
#+CINDEX:singleton dispatcher
The {{{dfn(dispatcher)}}} receives actions and dispatches them to stores that
have registered with the dispatcher.  Every store will receive every action.
There should be only one singleton dispatcher in each application.

Example:

1. User types in title for a todo and hits enter.
2. The view captures this event and dispatches an "add-todo" action containing
   the title of the todo.
3. *Every store* will then receive this action.

*** Store

#+CINDEX:store
#+CINDEX:store, register with dispatcher
#+CINDEX:register, store with dispatcher
#+CINDEX:action
#+CINDEX:mutate data
#+CINDEX:setters
#+CINDEX:getters
#+CINDEX:@samp{change} event
A store is what holds the data of an application. Stores will register with the
application's dispatcher so that they can receive actions.  The data in a store
must only be mutated by responding to an action. There should not be any public
setters on a store, only getters.  Stores decide what actions they want to
respond to.  Every time a store's data changes it must emit a
{{{samp(change)}}} event.  There should be many stores in each application.

Examples:

1. Store receives an "add-todo" action.
2. It decides it is relevant and adds the todo to the list of things that need
   to be done today.
3. The store updates its data and then emits a "change" event.

*** Actions

#+CINDEX:actions
#+CINDEX:@samp{type} field
Actions define the internal API of your application.  They capture the ways in
which anything might interact with your application.  They are simple objects
that have a {{{samp(type)}}} field and some data.

Actions should be semantic and descriptive of the action taking place.  They
should not describe implementation details of that action. Use
{{{samp(delete-user)}}} rather than breaking it up into
{{{samp(delete-user-id)}}}, {{{samp(clear-user-data)}}},
{{{samp(refresh-credentials)}}} (or however the process works).  Remember that
all stores will receive the action and can know they need to clear the data or
refresh credentials by handling the same {{{samp(delete-user)}}} action.

Examples:

1. When a user clicks "delete" on a completed todo a single "delete-todo"
   action is dispatched:

   #+BEGIN_SRC js :eval never
  {
    type: 'delete-todo',
    todoID: '1234',
  }
   #+END_SRC

*** Views

#+CINDEX:views
#+CINDEX:subscribe to change events, view
#+CINDEX:actions, dispatched from views
Data from stores is displayed in views.  Views can use whatever framework you
want (In most examples here we will use React).  When a view uses data from a
store it must also subscribe to change events from that store.  Then when the
store emits a change the view can get the new data and re-render.  If a
component ever uses a store and does not subscribe to it then there is likely a
subtle bug waiting to be found.  Actions are typically dispatched from views as
the user interacts with parts of the application's interface.

Example:

1. The main view subscribes to the TodoStore.
2. It accesses a list of the Todos and renders them in a readable format for
   the user to interact with.
3. When a user types in the title of a new Todo and hits enter the view tells
   the Dispatcher to dispatch an action.
4. All stores receive the dispatched action.
5. The TodoStore handles the action and adds another Todo to its internal data
   structure, then emits a "change" event.
6. The main view is listening for the "change" event. It gets the event, gets
   new data from the TodoStore, and then re-renders the list of Todos in the
   user interface.

*** Flow of data

We can piece the parts of Flux above into a diagram describing how data flows
through the system.

1. Views send actions to the dispatcher.
2. The dispatcher sends actions to every store.
3. Stores send data to the views.

#+NAME:flow.png
#+CAPTION:Views get data from the stores.
[[file:img/flux-simple-f8-diagram-with-client-action-1300w-50.png]]

*** Next steps

You can start coding with the [[todo-example][flux-todomvc]] example, or head back to check out
the full list of [[*Examples][example topics]].
** Requirements

{{{subheading{EventEmitter}

#+CINDEX:EventEmitter, Flux
Flux is more of a pattern than a framework, and does not have any hard
dependencies.  However, we often use [[https://nodejs.org/api/events.html#events_class_events_eventemitter][EventEmitter]] as a basis for Stores and
[[https://github.com/facebook/react][React]] for our Views.

{{{subheading(Dispatcher)}}}

#+CINDEX:Dispatcher, Flux
The one piece of Flux not readily available elsewhere is the =Dispatcher=.
This module, along with some other utilities, is available here to complete
your Flux toolbox.

** Installing Flux

#+CINDEX:Flux, install
#+CINDEX:install Flux
#+CINDEX:@code{Flux.Dispatcher}
Flux is available as an [[https://www.npmjs.org/package/flux][npm module]], so you can add it to your ~package.json~
file or run {{{command(npm install flux)}}}. The dispatcher will be available
as ~Flux.Dispatcher~ and can be required like this:
: const Dispatcher = require('flux').Dispatcher;

  #+CINDEX:dispatcher API
- Take a look at the [[https://facebook.github.io/flux/docs/dispatcher.html#content][dispatcher API and some examples]].

** Building Flux from a Cloned Repo

Clone the repo and navigate into the resulting flux directory. Then run
{{{command(npm install)}}}.

#+CINDEX:Gulp, Flux
#+CINDEX:build process, Flux
This will run Gulp-based build tasks automatically and produce the file
~Flux.js~, which you can then require as a module.

#+CINDEX:Dispatcher
You could then require the Dispatcher like so:
: const Dispatcher = require('path/to/this/directory/Flux').Dispatcher;

The build process also produces de-sugared versions of the =Dispatcher= and
=invariant= modules in a ~lib~ directory, and you can require those modules
directly, copying them into whatever directory is most convenient for you. The
flux-todomvc and flux-chat example applications both do this.

** Examples

https://github.com/facebook/flux/tree/master/examples

This directory contains examples that should help get you started with
Flux. They are listed in the order you should complete them.

- [[https://github.com/facebook/flux/blob/master/examples/flux-concepts][Basic concepts (no code)]]

  These are the important high-level concepts and principles you should know
  about when writing applications that use Flux.

- [[https://github.com/facebook/flux/blob/master/examples/flux-todomvc][Start coding here]]

  <<todo-example>>This example is where you should start. It walks you through
  creating the classic TodoMVC application using a simple Flux implementation.

- [[https://github.com/facebook/flux/blob/master/examples/flux-jest][Unit Testing Stores]]

  Being able to unit test stores is critical. This example shows you how to
  write tests for the TodoMVC stores we created in an earlier example.

- [[https://github.com/facebook/flux/blob/master/examples/flux-flow][Static typing]]

  This is a very simple example that highlights how to set up Flux and Flow in
  the same project. Flow is a static-type checking tool that will help catch
  errors in your code statically. It complements Flux well since it supports
  refining the action based on a type string.

- [[https://github.com/facebook/flux/blob/master/examples/flux-logging][Add logging to Flux apps]]

  Taking advantage of the fact that a store gets every action makes it easy to
  add logging to a Flux application. Check out this quick example where we add
  a logger store to the TodoMVC app we created in an earlier example.

- [[https://github.com/facebook/flux/blob/master/examples/flux-jest-container][Unit Testing Containers]]

  Testing the container logic that connects stores to views can be tricky. This
  example shows you how to create some utilities to help mock out store data in
  order to write these kinds of tests effectively.

- [[https://github.com/facebook/flux/blob/master/examples/flux-async][Flux with async requests]]

  This is an advanced example. It pulls a lot of the concepts from previous
  examples into a single application. This implements TodoMVC where the data is
  persisted and requested through a simple server. The server simulates delays
  and errors. In the example we will handle things like optimistic updates,
  loading states, and failing API requests.

** In-Depth Overview

- [[https://facebook.github.io/flux/docs/in-depth-overview.html#content][Link]]
- [[https://youtu.be/nYkdrAPrdcw?list=PLb0IAmt7-GS188xDYE-u1ShQmFFGbrk0v][Video]]

** Reference

*** Disptacher Docs

#+CINDEX:Dispatcher
Dispatcher is used to broadcast payloads to registered callbacks. This is
different from generic pub-sub systems in two ways:

- Callbacks are not subscribed to particular events. Every payload is
  dispatched to every registered callback.
- Callbacks can be deferred in whole or part until other callbacks have been
  executed.


Check out [[https://github.com/facebook/flux/blob/master/src/Dispatcher.js][Dispatcher.js]] for the source code.

  #+CINDEX:Dispatcher API
**** Dispatcher API

  #+CINDEX:@code{register()}
- ~register(function callback)~: string ::

     Registers a callback to be invoked with every dispatched payload. Returns
     a token that can be used with ~waitFor()~.

  #+CINDEX:@code{unregister()}
- ~unregister(string id)~: void ::

     Removes a callback based on its token.

  #+CINDEX:@code{waitFor()}
- ~waitFor(array<string> ids)~: void ::

     Waits for the callbacks specified to be invoked before continuing
     execution of the current callback. This method should only be used by a
     callback in response to a dispatched payload.

  #+CINDEX:@code{dispatch()}
- ~dispatch(object payload)~: void ::

     Dispatches a payload to all registered callbacks.

  #+CINDEX:@code{isDispatching()}
- ~isDispatching()~: boolean ::

      Is this Dispatcher currently dispatching.

**** Example

#+CINDEX:flight destination form
For example, consider this hypothetical flight destination form, which selects
a default city when a country is selected:

#+BEGIN_SRC js -n :eval never
var flightDispatcher = new Dispatcher();

// Keeps track of which country is selected
var CountryStore = {country: null};

// Keeps track of which city is selected
var CityStore = {city: null};

// Keeps track of the base flight price of the selected city
var FlightPriceStore = {price: null};
#+END_SRC

When a user changes the selected city, we dispatch the payload:

#+BEGIN_SRC js +n :eval never
flightDispatcher.dispatch({
  actionType: 'city-update',
  selectedCity: 'paris'
});
#+END_SRC

This payload is digested by CityStore:

#+BEGIN_SRC js +n :eval never
flightDispatcher.register(function(payload) {
  if (payload.actionType === 'city-update') {
    CityStore.city = payload.selectedCity;
  }
});
#+END_SRC

When the user selects a country, we dispatch the payload:

#+BEGIN_SRC js +n :eval never
flightDispatcher.dispatch({
  actionType: 'country-update',
  selectedCountry: 'australia'
});
#+END_SRC

This payload is digested by both stores:

#+BEGIN_SRC js +n :eval never
CountryStore.dispatchToken = flightDispatcher.register(function(payload) {
  if (payload.actionType === 'country-update') {
    CountryStore.country = payload.selectedCountry;
  }
});
#+END_SRC

When the callback to update ~CountryStore~ is registered, we save a reference
to the returned token. Using this token with ~waitFor()~, we can guarantee that
~CountryStore~ is updated before the callback that updates ~CityStore~ needs to
query its data.

#+BEGIN_SRC js +n :eval never
CityStore.dispatchToken = flightDispatcher.register(function(payload) {
  if (payload.actionType === 'country-update') {
    // `CountryStore.country` may not be updated.
    flightDispatcher.waitFor([CountryStore.dispatchToken]);
    // `CountryStore.country` is now guaranteed to be updated.

    // Select the default city for the new country
    CityStore.city = getDefaultCityForCountry(CountryStore.country);
  }
});
#+END_SRC

The usage of ~waitFor()~ can be chained, for example:

#+BEGIN_SRC js +n :eval never
FlightPriceStore.dispatchToken =
  flightDispatcher.register(function(payload) {
    switch (payload.actionType) {
      case 'country-update':
      case 'city-update':
        flightDispatcher.waitFor([CityStore.dispatchToken]);
        FlightPriceStore.price =
          getFlightPriceStore(CountryStore.country, CityStore.city);
        break;
  }
});
#+END_SRC

The ~country-update~ payload will be guaranteed to invoke the stores' registered
callbacks in order: ~CountryStore~, ~CityStore~, then ~FlightPriceStore~.

*** Flux Utils

#+CINDEX:Flux utils
#+CINDEX:utility classes, Flux
#+CINDEX:class, Flux utility
We have also provided some basic utility classes to help get you started with
Flux.  These base classes are a solid foundation for a simple Flux application,
but they are *not* a feature-complete framework that will handle all use cases.
There are many other great Flux frameworks out there if these utilities do not
fulfill your needs.

{{{heading(Usage)}}}

There are four[sic] main classes exposed in Flux Utils:

1. Store
2. ReduceStore
3. Container

These base classes can be imported from ~flux/utils~ like this:

#+NAME:flux-utils.js
#+CAPTION:Importing base classes from ~flux/utils~
#+BEGIN_SRC js :eval never
import {ReduceStore} from 'flux/utils';

class CounterStore extends ReduceStore<number> {
  getInitialState(): number {
    return 0;
  }

  reduce(state: number, action: Object): number {
    switch (action.type) {
      case 'increment':
        return state + 1;

      case 'square':
        return state * state;

      default:
        return state;
    }
  }
}
#+END_SRC

* Twitter and Snapkite

** Twitter Docs

- [[https://developer.twitter.com/en/docs.html][Twitter Docs]]

** Twitter Tutorial on Consuming Streaming Data

- [[https://developer.twitter.com/en/docs/tutorials/consuming-streaming-data][Consuming streaming data]]

** Snapkite Engine

Snapkite Engine gives you filtered stream of photos posted publicly on Twitter.

- [[https://github.com/Snapkite][Snapkite on Github]]
- [[https://github.com/snapkite/snapkite-engine][Snapkite Engine on Github]]

It can do 2 (either or both) things with those photos:

1. Send them to a socket connection and allow all your clients to receive them
   in real-time.
2. Store them in MongoDB and retrieve later with [[https://github.com/snapkite/snapkite-api-server.git][Snapkite API Server]] or your
   own application.

{{{heading(Examples)}}}

- [[http://snapterest.com/][Snapterest.com]]
- [[http://map.snapkite.com/][Map.Snapkite.com]]

*** Installation Instructions

- https://github.com/snapkite/snapkite-engine#install


1. git clone https://github.com/Snapkite/snapkite-engine.git
2. cd snapkite-engine
3. npm install
4. cp example.config.json config.json
5. Add your Twitter API keys to config.json
6. Change default MongoDB config in config.json

*** Configure Instructions

- https://github.com/snapkite/snapkite-engine#configure


You can configure Snapkite Engine by editing config.json.

- ~application.pushTweets~ :: Send tweets to client?  Expects true or false.

- ~application.storeTweets~ :: Store tweets in a MongoDB collection?  Expects
     true or false.

- ~application.pushKeywords~ :: Send keyword stats to client?  Expects true or
     false.

- ~application.trackKeywords~ ::
     Which keywords should we ask Twitter to track for us?  Expects a string of
     keywords separated by a single whitespace or comma, e.g.: =selfie london= or
     =selfie,london=

     Read this for more details:
     https://dev.twitter.com/streaming/overview/request-parameters#track

- ~application.excludeKeywords~ ::
     Which keywords should be ignored?  Expects a string of keywords separated
     by a comma, e.g.: =exclude,these,keywords=

- ~application.filters~ ::
     List of Snapkite filters that this application should use. You can find
     the list of all available filters [[https://github.com/snapkite/snapkite-engine/tree/master/filters/README.md][here]].

- ~application.twitter.api~ ::
     Twitter API keys that Twitter provides you with. You can find them [[https://apps.twitter.com/][here]].

- ~application.database~ : :MongoDB connection configuration.

- ~application.socket~ :: Socket configuration.

*** Snapkite Filters

[[https://github.com/snapkite/snapkite-filters/blob/master/README.md][Everything you need to know]] about Snapkite filters.

*** MongoDB

https://github.com/snapkite/snapkite-engine#mongodb

* Listings
:PROPERTIES:
:APPENDIX: t
:END:
#+TEXINFO:@listoffloats Listing

* Figures
:PROPERTIES:
:APPENDIX: t
:END:
#+TEXINFO:@listoffloats Figure
* Index
  :PROPERTIES:
  :INDEX:    cp
  :END:
* COPYING
  :PROPERTIES:
  :COPYING:  t
  :END:
  {{{TITLE}}} by {{{AUTHOR}}}
  \copy 2015 Packt Publishing

#+BEGIN_QUOTE
A fast-paced guide to designing and building scalable and maintainable web apps
with React.js
#+END_QUOTE

Outline prepared by WLHarvey \copy {{{date(%F)}}}
* MACROS                                                           :noexport:
#+MACRO:heading @@texinfo:@heading @@$1
#+MACRO:subheading @@texinfo:@subheading @@$1
#+MACRO:tiauthor @@texinfo:@author @@$1
#+MACRO:key @@texinfo:@key{@@$1@@texinfo:}@@
#+MACRO:file @@texinfo:@file{@@$1@@texinfo:}@@
#+MACRO:command @@texinfo:@command{@@$1@@texinfo:}@@
#+MACRO:samp @@texinfo:@samp{@@$1@@texinfo:}@@
#+MACRO:cite @@texinfo:@cite{@@$1@@texinfo:}@@
#+MACRO:noindent @@texinfo:@noindent @@
#+MACRO:dfn @@texinfo:@dfn{@@$1@@texinfo:}@@
* EXPORT SETTINGS                                                  :noexport:
#+OPTIONS: h:4
#+TEXINFO_CLASS: info
#+TEXINFO_HEADER:
#+TEXINFO_POST_HEADER:
#+TEXINFO_DIR_CATEGORY: React
#+TEXINFO_DIR_TITLE: React.js Essentials
#+TEXINFO_DIR_DESC:Fast-paced guide to designing web apps with React.js
