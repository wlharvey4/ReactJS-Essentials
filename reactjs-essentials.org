# -*- mode: org; fill-column: 79; buffer-read-only: t -*-

#+TITLE: React.js Essentials
#+SUBTITLE: A fast-paced guide to designing and building scalable and maintainable web apps with React.js
#+AUTHOR: Artemij Fedosejev
#+DATE: <2019-04-19 Fri 17:06>

#+TEXINFO: @insertcopying

* Preface
:PROPERTIES:
:UNNUMBERED: t
:END:

#+CINDEX:imperative code
#+CINDEX:declarative code
#+CINDEX:jQuery
#+CINDEX:modular
#+CINDEX:scalable
The Web is different.  The way we build for the Web is different.  Faced by the
challenges of dealing with unmaintainable /imperative code/ produced by jQuery
we had to look for new ways of managing the complexity of modern user
interfaces.  We needed a new user interface library that would help us build
/declarative/, /modular/, fast and /scalable/ frontend applications.

{{{subheading(React.js --- User Interface Library)}}}

#+CINDEX:user interface library
#+CINDEX:Facebook
#+CINDEX:DOM
#+CINDEX:data flow, organize
Meet React.js --- a JavaScript user interface library developed by Facebook.
It brings profound ideas on how to work with the DOM, organize your
application's data flow, and think about user interface elements as individual
components.  And yet, it's only a user interface library that makes no
assumptions about the rest of your technology stack.

{{{subheading(With Flux)}}}

#+CINDEX:Flux
#+CINDEX:frontend architecture
Combined with Flux, we get a powerful frontend architecture that makes sense
not only to experienced developers, but also those who are just starting their
frontend journey.

** From the Author

  #+CINDEX:Fedosejev, Artemij
- [[https://github.com/fedosejev][Artemij Fedosejev]]

  #+CINDEX:React Essentials Github
- [[https://github.com/fedosejev/react-essentials][Author's React Essentials Github Page]]

  #+CINDEX:tutorials, React
- [[https://react.tips][React Tutorials]]

- [[https://react.tips/from-react-to-flux-to-redux/][From React.js To Flux To Redux]]

  If you want to really understand what's the difference between building web
  apps with React only, or with React and Flux, or with React and Redux, then
  check the four examples that I've prepared for you.

  #+CINDEX:shopping list app examples
  #+CINDEX:examples, shopping list app
  They all implement exactly the same Shopping List app, but most importantly -
  they highlight the difference in how you approach building web apps using
  different tools.

    #+CINDEX:ES5 JavaScript
    #+CINDEX:JavaScript ES5
  - Built with React.js and JavaScript ES5

    In this [[https://github.com/fedosejev/shopping-list-react][example]], I am using only React.js without Flux or Redux to build
    the entire app. And I am using the good old JavaScript that all know and
    love (or hate?): version ECMAScript 5.

    This example is the best place for you to start if you're not familiar with
    Flux or Redux at all. It helps you to understand why we need Flux or
    Redux. You will feel strange when storing application state (the shopping
    list itself) in React components, knowing that React should only be
    responsible for knowing how to render the user interface.

    #+CINDEX:ES2015, JavaScript
    #+CINDEX:JavaScript ES2015
  - Built with React.js and JavaScript ES2015

    The industry uses a newer version of JavaScript today: ECMAScript 2015. It
    brings new syntax and React takes advantage of that syntax.

    If you want to see how to transition from tradition ES5 syntax to newer
    ES2015 syntax in the context of React app, then this [[https://github.com/fedosejev/shopping-list-react-es2015][example]] is perfect for
    you. Feel free to compare it with the the previous one (ES5 version).

    #+CINDEX:Flux with ES5
    #+CINDEX:ES5 and Flux
  - Built with React.js and Flux and JavaScript ES5

    If React feels familiar to you and you can build simple apps with it then
    you most likely faced a problem of accessing application state from
    different React components. It's not a straight forward task! And it feels
    awkward, because we know that React is a UI library, and if we follow the
    separation of concerns principle, then it's clear to us that we shouldn't
    store application state in React components!

    Where do we store it then? That's why you might need to introduce Flux
    architecture to your React application.

    This [[https://github.com/fedosejev/shopping-list-react-flux][example]] is a perfect introduction to the Flux architecture, because
    you're building exactly the same app, but now you're clearly separating
    your UI logic from your application state logic.

    #+CINDEX:Redux with ES2015
    #+CINDEX:ES2015 and Redux
  - Built with React.js and Redux and JavaScript ES2015

    Flux is a great start for understanding how data flows in your React
    application. Redux takes it to the next level by building on top of ideas
    from Flux and introducing new important concepts that allow you to build
    really scalable and robust React apps.  See [[https://github.com/fedosejev/shopping-list-react-redux][example]].

** What this Book Covers

*** Chapter 1 Installing Powerful Tools

- Goals
- Tools
- Structure for project

*** Chapter 2 Create Your First React Element

- Install React
- Virtual DOM
- React Element
- Create and render a React element
- with native JavaScript
- JSX syntax
- Create React Elements using JSX

*** Chapter 3 Create Your First React Component

- React components
- Difference between stateless and stateful React components
- Creates both kinds

*** Chapter 4 Make Your React Components Reactive

- How to solve problems with React
- Plan a React application
- Create a React component that encapsulates entire app
- Relationship between parent and child React components

*** Chapter 5 Use Your React Components with Another Library

- How to use third party JavaScript libraries
- React component's lifecycle
- How to use mounting methods
- Create new components for project

*** Chapter 6 Update Your React Components

- React component lifecycle's updating mnethods
- CSS styles in JavaScript
- Validate and set default component properties

*** Chapter 7 Build Complex React Components

- Building more complex React components
- Implement different React components
- Put them together into one coherent and functional app

*** Chapter 8 Test Your React Application with Jest

- Unit testing
- Write and run unit tests with Jest
- Test React components
- Test suites, specs, expectations, and matchers

*** Chapter 9 Supercharge Your React Architecture with Flux

- Improve the architecture of React application
- Flux architecture
- Role of dispatcher, stores, and and action creators

*** Chapter 10 Prepare Your React Application for Painless Maintenance with Flux

- Decouple concerns in a React app with Flux
- Refactor React app to allow painless maintainability

** What You Need for this Book

1. Latest version of a modern web browser, e.g.,
   - [[https://www.google.com/chrome/browser][Google Chrome]]
   - [[https://www.mozilla.org/en-US/firefox/new/][Mozilla Firefox]]

2. Git

3. Node.js

4. npm

5. Code editor, e.g.
   - [[http://www.sublimetext.com][Sublime Text]]
   - [[https://atom.io][Atom]]
   - [[http://brackets.io][Brackets]]
   - [[https://code.visualstudio.com][Visual Studio Code]]
   - Your choice

** Who this Book is For

This book is intended for frontend developers who want to build scalable and
maintainable user interfaces for the Web.  Some core knowledge of JavaScript,
HTML, and CSS is the only thing you need to know to start benefiting.  If you
have previous experience with jQuery or Angular.js, then you will benefit from
understanding how React.js is different and how to take advantage of
integrating different libraries with it.

** Conventions

** Reader Feedback

** Downloading the Example Code

https://github.com/fedosejev/react-essentials

** Errata

https://wwwpacktpub.com/books/content/support

enter the name of the book in the search field.

** ES6 Version

A refactoring of the project described in "React.js Essentials" using ES6
rather than just ES5.  This is merely a refactoring of the project described in
"React.js Essentials" (by Artemij Fedosejev) that uses ES6 features (e.g.,
class, import, etc.) rather than just ES5. (It also leaves out the console.log
spam.)

- From [[https://github.com/jmrog/react-essentials-es6-version][Jason Roger]]

** Set Variables

This source file is set up to export as a Texinfo file (using the
{{{command(org-export-dispatch (C-c C-e i))}}} command) and to produce
documentation in the following formats:
- Info
- Pdf
- Html

During the export process, numerous scripts are evaluated (run for their side
effects, i.e., to produce the directory structure, clone git modules, install
Node modules, set up configuration variables, etc.).  To allow this evaluation
process to work properly and without intervention, two Emacs variables must be
set up properly.

- ~org-confirm-babel-evaluate~ ::
     This variable should be set to =nil= in order to allow all of the scripts
     to process automatically without user intervention, which would quickly
     get tedious otherwise.  If this variable is set to =t= when the source
     file is exported, therefore, the first script will ask for your permission
     to run, and if you confirm 'yes', then this script will toggle this
     variable to =nil= and proceed to process the remainder of the source file
     without further user intervention.

#+NAME:setup org confirm babel evaluate variable
#+BEGIN_SRC emacs-lisp :exports both :results output
(if org-confirm-babel-evaluate
  (progn
    (print "org-confirm-babel-evaluate is 'true'; setting to 'nil'...")
    (setq org-confirm-babel-evaluate nil))
  (print "org-confirm-babel-evaluate is 'nil'; proceeding..."))
#+END_SRC

- ~org-babel-load-languages~ ::
     This variable must have the following languages enabled:
  - Elisp ~emacs-lisp~ (enabled by default)
  - JavaScript ~js~
  - Shell ~sh~

    After the preceding code runs, the second script will check whether
    JavaScript and Shell code evaluation are enabled.  If any of the required
    languages are not enabled, then it will enable them as necessary and then
    continue processing the remainder of the file.

#+NAME:setup org babel load languages variable
#+BEGIN_SRC emacs-lisp :exports both :results output
(if (assq 'js org-babel-load-languages)
    (print "JavaScript already enabled.")
    (and (require 'ob-js) (print "JavaScript enabled.")))
(if (assq 'shell org-babel-load-languages)
    (print "Shell already enabled.")
    (and (require 'ob-shell) (print "Shell enabled.")))
#+END_SRC

#+NAME:use quick and dirty
#+HEADER: :exports results
#+HEADER: :results silent
#+BEGIN_SRC elisp
(setq org-babel-use-quick-and-dirty-noweb-expansion t)
#+END_SRC

* Installing Powerful Tools for your Project

#+CINDEX:Kettering, Charles
#+BEGIN_QUOTE
My interest is in the future because I am going to spend the rest of my life
there.
{{{tiauthor(Charles F. Kettering)}}}
#+END_QUOTE

#+CINDEX:spaghetti code
#+CINDEX:mental model, spaghetti
This brilliant inventor has left software engineers with the single most
important piece of advice way before we even started thinking about how to
write software.  Yet, half a century later, we're still figuring out why we end
up with spaghetti code or the ``spaghetti mental model.''

{{{heading(Writing Software for the Future)}}}
{{{subheading(Create a Simple Mental Model that Does Not Change)}}}

#+CINDEX:mental model
#+CINDEX:complexity remains the same
What does it mean to ``write software for the future, today''?  It boils down
to creating a simple mental model that doesn't change, no matter how big your
project becomes over time.  When the size of your project grows, the complexity
always stays the same.  This mental model is your blueprint, and once you
understand it you will understand how your whole piece of software works.

{{{subheading(Programming with React is Programming Declaratively)}}}

#+CINDEX:Facebook
#+CINDEX:Occhino, Tom
In 2013, Facebook released React---an open source JavaScript library for
building user interfaces.  You can read more about it at
http://facebook.github.io/react/.  In early 2015, Tom Occhino from Facebook
summarized what makes React so powerful:

#+BEGIN_QUOTE
React wraps an imperative API with a declarative one.  React's real power lies
in how it makes you to write code.
{{{tiauthor(Tom Occhino)}}}
#+END_QUOTE

#+CINDEX:declarative style
#+CINDEX:imperative style
#+CINDEX:DOM API
#+CINDEX:jQuery
A declarative style of programming results in less code.  It tells a computer
what to do without specifying how, while an imperative style of programming
describes how to do it.  JavaScript's call to the DOM API is an example of
imperative programming.  jQuery is another such example.

{{{subheading(React is Good for Small Projects)}}}

#+CINDEX:small React project
#+CINDEX:shopping list
It works for small projects too; here is an example of a [[http://fedosejev.github.io/shopping-list-react][shopping list]] built
with React.  React is one of the best JavaScript libraries used for building
user interfaces that is available for developers today.

** The Goal of this Book---Understand React

#+CINDEX:goal
#+CINDEX:fundamental principles of React
#+CINDEX:React's fundamental principles
#+CINDEX:principles, fundamental
#+CINDEX:project, real-time web application
The goal of this book is for you to understand the fundamental principles of
React.  To achieve this, you will be introduced to one React component at a
time, shown how it works, and shown how you can apply it.  Step by step, you'll
build a real-time web application, discuss important questions along the way,
and look at solutions that React provides.

{{{heading(And Understand Flux)}}}

#+CINDEX:Flux
#+CINDEX:mental model
You will learn about Flux, ([[*Flux][Flux)]], which implements a /unidirectional flow of
data/.  Together with Flux and React, you'll create a predictable and
manageable code base that you will be able to expand upon by adding new
features /without scaling its complexity/.  The mental model of how your web
application works will stay the same, no matter how many new features you add
later.

** Approaching the Project

The best motivation for learning new technology is a project that excites you
and that you can't wait to build.  In this book the author helps you build a
project that feels like a breath of fresh air---a project which you most likely
wouldn't build in your day-to-day work.  It will be a fun endeavor, which not
only educates you but also satisfies your curiosity and stretches your
imagination.  This project won't be a time consuming, long-term commitment for
you either.

{{{heading(Snapterest---A Web App to Collect Twitter Photos)}}}

#+CINDEX:Snapterest
#+CINDEX:project Snapterest
#+CINDEX:Twitter
#+CINDEX:Pinterest
#+CINDEX:website functionality
Enter *Snapterest*---a web application that allows you to discover and collect
public photos posted on Twitter.  Think of it as Pinterest with the only source
of pictures being Twitter.  We will implement a fully functional website with
the following core functionalities:

- Receiving and displaying tweets in real time

- Adding and removing tweets to / from a collection

- Reviewing collected tweets

- Exporting a collection of tweets as an HTML snippet that you can share

** Gathering Tools
#+CINDEX:tools
When you start working on a new project, the very first thing that you do is
get your tools ready.  For this project, we will be using a number of tools.

- *Node.js* and *{{{command(npm)}}}* (or *{{{command(yarn)}}}*) for installing
  and running React

- *Git* for installing tools

- The *Twitter Streaming API* for obtaining data
  + Twitter account
  + Twitter app

- The *Snapkite Engine* for filtering data

*** Node.js and npm

  #+CINDEX:Node.js, installation
- [[https://nodejs.org][Node.js]] ::

     #+CINDEX:JavaScript
     #+CINDEX:Node.js benefits
     #+CINDEX:event-driven
     #+CINDEX:non-blocking
     #+CINDEX:real-time
     is a platform that allows us to write server-side applications with a
     client-side language: JavaScript.  The real benefit of Node.js is that it
     uses an /event-driven/, /non-blocking I-O/ model, which is perfect for
     building /data-intensive/, /real-time/ applications.  It means that, with
     Node.js, we should be able to handle an incoming stream of tweets and
     process them as soon as they arrive.


- [[https://nodejs.org/en/][Node.js Home]]

<<install-node.js>>{{{heading(Install Node.js)}}}

#+CINDEX:install Node.js
#+CINDEX:Jest
At the time the book was written, the version of Node.js that was used was
=v0.10.40=[fn::For this project , the version of Node.js installed on
{{{date}}} was src_sh[:exports results]{node -v}.]  because, at that time that
was the latest version of Node.js that Jest supported.[fn::The currently
available versions of Node.js as of the publication of this document
({{{date}}}) are =10.15.3 LTS= and =11.14.0 Current=.  The current version of
Jest is =24.6=, which appears to work with the current version of Node.js and
React.]

#+CINDEX:distribution, Node.js
#+CINDEX:installation package, Node.js
- If you do not have Node.js installed, go to http://nodejs.org/dist/v0.10.40/
  and download the installation package for your OS[fn::One can also use NVM
  (Node Version Manager) to install a particular Node.js version. ([[https://github.com/creationix/nvm][NVM on
  Github]])]:

    #+CINDEX:OS X
  - [[http://nodejs.org/dist/v0.10.40/node-v0.10.40-darwin-x64.tar.gz][OS X]]:[fn::Created 09-Jul-2015 21:30] ::

      Run it and follow the installation steps that Node.js will prompt you with.
      Test for successful installation with ~node -v~, which will print the
       installed version if all went well:

      #+begin_src sh :exports both :results output
      node -v
      #+end_src


{{{subheading(npm Should Be Installed with Node.js)}}}

#+CINDEX:npm, installation
#+CINDEX:package manager, npm
[[http://www.npmjs.com][npm]] is a package manager that manages Node.js modules.  It is shipped with
Node.js, so it was installed by the previous step.  To test:
     : $ npm -v
     : 1.4.28
     [fn::Currently installed npm version as of {{{date}}} is src_sh[:exports
     results]{npm -v}]

*** Git

#+CINDEX:Git
#+CINDEX:install Git
#+CINDEX:getting started with Git
<<install-git>>We'll be using Git to install Node.js modules.  Visit:
- [[https://git-scm.com/book/en/v2/Getting-Started-Installing-Git][{{{cite(1.5 Getting Started - Installing Git)}}}]]

{{{noindent}}}and follow the installation instructions for your OS.  [fn::Git
can also be installed using Homebrew or from the
{{{command(git-osx-installer)}}} found at
[[https://sourceforge.net/projects/git-osx-installer/]].  The current version of
git installed is src_sh[:exports results]{git --version} using the
{{{command(git-osx-installer)}}}.]

*** The Twitter Streaming API

#+CINDEX:Twitter Streaming API
#+CINDEX:Streaming API, Twitter
#+CINDEX:tweets, receive public
#+CINDEX:JSON format, tweets
<<twitter-streaming>>The data for our React application will come from Twitter.
Twitter has the *Streaming API*[fn::The =User Stream= and =Site Stream= have
been discontinued in favor of =Activity Stream=.  See [[https://twittercommunity.com/t/details-and-what-to-expect-from-the-api-deprecations-this-week-on-august-16-2018/110746][Details and what to
expect from the API deprecations this week on August 16 2018]].] that anyone can
plug into to start receiving an endless flow of public tweets in the JSON
format.

{{{heading(Using the Twitter Streaming API)}}}

To start using the Twitter Streaming API, you'll need to perform the following
steps:

{{{subheading(Create a Twitter Account and App)}}}

   #+CINDEX:Twitter account, create
1. <<create-twitter-account>>Create a Twitter account.  For this, go to
   https://twitter.com and sign up; or sign in if you already have an account.

   #+CINDEX:Twitter app, create
2. <<create-twitter-app>>Create a new Twitter App by navigating to
   https://developer.twitter.com/en/apps[fn::https://apps.twitter.com has been
   sunsetted] and click on {{{key(Create New App)}}}.  You will need to fill in
   the *Application Details* form, agree with the *Developer Agreement*, and
   click on *Create your Twitter application*.  Now you should see your
   application's page.


{{{subheading(Get Twitter Keys)}}}

<<twitter-keys>>Switch to the *Keys and Access Tokens* tab.  In the
*Applications Settings* section of this page, you'll find two vital pieces of
information:

   #+CINDEX:Twitter API keys
   #+CINDEX:keys, Twiter API
1. Consumer Key (API Key)

2. Consumer Secret (API Secret)


Take a note of them.

{{{subheading(Create a Twitter Access Token)}}}

#+CINDEX:access token, Twiter API
<<twitter-token>>Now generate an /access token/.  On the same page, you'll see
*Your Access Token* section that is empty.  Click on {{{key(Create my access
token)}}}.  It creates two pieces of information:

1. Access Token

2. Access Token Secret


Take a note of them too.  An access token is unique to you and you should not
share it with anyone.  Keep it private.

*** Snapkite Engine
:PROPERTIES:
:CUSTOM_ID: Snapkite Engine
:END:

#+CINDEX:filter
We need to filter the stream of data from the Twitter Streaming API into a
meaningful set of tweets that we can display and interact with.

#+CINDEX:Twitter Streaming API documentation
You should first take a quick look at the [[https://dev.twitter.com/streaming][Twitter Streaming API]] [fn::no longer
exists.] documentation[fn::See [[my-notes][My Notes]] for some current documentation.].  In
particular take a look at the page that describes how to [[https://dev.twitter.com/streaming/reference/post/statuses/filter][filter]] [fn::no longer
exists.] an incoming stream.  Twitter provides very few filters that we can
apply, so we need to find a way to filter that stream of data even further.

{{{heading(Snapkite Engine)}}}

#+CINDEX:Snapkite Engine Node.js application
#+CINDEX:Twitter Streaming API, filter engine for
#+CINDEX:tweets, filtered
#+CINDEX:web socket connection for filtered tweets
There is a Node.js application just for this.  It's called [[https://github.com/snapkite/snapkite-engine][Snapkite Engine]].
It connects to the Twitter Streaming API, filters it using the available
filters and according to the rules that you define, and outputs the filtered
tweets to a web socket connection.  Our React app can listen to the events on
that socket connection and process tweets as they arrive.

<<my-notes>>My Notes [0/13]
- [ ] [[https://developer.twitter.com][Developer on Twitter]]
- [ ] [[https://developer.twitter.com/en/docs][Developer Docs]]
- [ ] [[https://developer.twitter.com/en/docs/tutorials][Tutorials]]
- [ ] [[https://developer.twitter.com/en/docs/tweets/filter-realtime/overview][Filter realtime Tweets]]
- [ ] [[https://developer.twitter.com/en/docs/tutorials/consuming-streaming-data][Consuming streaming data]]
- [ ] [[https://developer.twitter.com/en/docs/api-reference-index][API reference index]]
- [ ] [[https://twitter.com/TwitterDev/status/1067094924124872705][Video on building with Twitter apps]]
- [ ] [[https://twittercommunity.com][Forums]]
- [ ] [[https://streamdata.io/blog/understand-twitter-streaming-api/][Understanding The Current State of The Twitter Streaming API]]
- [ ] [[https://streamdata.io/blog/tag/twitter/][Posts Tagged with Twitter]]
- [ ] [[https://streamdata.io/blog/twitter-api-deprecations/][Preparing For Latest Rounds Of Twitter API Deprecations]]
- [ ] [[https://streamdata.io/blog/deprecated-event-types/][Upcoming Deprecated Event Types With The Twitter API]]
- [ ] [[https://github.com/KyleAMathews/reactjs-twitter-stream-example][reactjs-twitter-stream-example]]
- [ ] [[https://dzone.com/articles/how-to-use-twitter-api-using-nodejs][How to Use Twitter API With Node.js]] A step-by-step tutorial of using
  Node.js to communicate with Twitter via the Twit NPM package, including
  setup.

{{{heading(Install the Snapkite Engine)}}}
<<install Snapkite Engine>>

Installation of the Snapkite Engine involves the following steps:

1. Cloning the Snapkite Engine repository into a directory structure;
2. Adding the dependency module Node-Gyp to {{{file(package.json)}}}
3. Installing the {{{command(node-gyp)}}} command (either globally or locally)
4. Installing the modules required by {{{file(package.json)}}}
5. Creating a configuration file for Snapkite Engine
6. Adding tracking keywords to the configuration file
7. Adding Twitter consumer and access token keys to the configuration file
8. Installing filters to the Snapkite Engine
9. Configuring the installed filters
10. Configuring Snapkite Engine to use the installed filters


**** Clone the Snapkite Engine Repository

#+CINDEX:Snapkite Engine, install
Clone the Snapkite Engine repository into a directory of your choice[fn::For
this project, ~<dir>~ will be set to ~snapkite/~ and Snapkite-Engine cloned
into it.]:
: cd <dir> (i.e. snapkite/)
: git clone https://github.com/snapkite/snapkite-engine.git

This will create the ~<dir>/snapkite-engine/~
folder.

#+NAME:mkdir snapkite
#+BEGIN_SRC sh :results output :exports both
[ -d snapkite ] && echo snapkite dir exists || mkdir -v snapkite
cd snapkite
[ -d snapkite-engine ] && echo snapkite-engine exists || { \
  echo Now cloning snapkite-engine...
  git clone https://github.com/snapkite/snapkite-engine.git;
  echo
  cd ..
  tree snapkite
}
#+END_SRC

**** Install Node-Gyp

#+CINDEX:Node-Gyp module
<<install-node-gyp>>Now install the other node modules that ~snapkite-engine~
depends on.  One of them is the ~node-gyp~ module.  Also install other tools
that are listed on [[https://github.com/TooTallNate/node-gyp#installation][node-gyp installation]].

#+NAME:install Node-Gyp
#+BEGIN_SRC sh :results output :exports both :dir snapkite/snapkite-engine
[ -d node_modules/node-gyp ] && echo node-gyp already installed || yarn add node-gyp
#+END_SRC

**** Install the {{{command(node-gyp)}}} Command
Once you install them, you're ready to install the ~node-gyp~ command:
: npm install --global node-gyp

**** Install the Dependency Modules for Snapkite Engine

Navigate to the ~<dir>/snapkite-engine~ directory to install the Node.js
modules that Snapkite Engine depends on:
: cd <dir>/snapkite-engine/
: npm install

#+NAME:install snapkite-engine modules
#+BEGIN_SRC sh :results output :exports both :dir snapkite/snapkite-engine
yarn
cd ../..
echo
tree -I node_modules snapkite
#+END_SRC
*Note* that the {{{file(node_modules)}}} directory is not shown in the tree
display.


**** Configure the Snapkite-Engine

#+CINDEX:Snapkite-Engine, configure
#+CINDEX:configure Snapkite-Engine
The =README= file inside ~<dir>/snapkite-engine/~ provides some instructions on
how to configure the Snapkite-Engine:

{{{heading(Snapkite-Engine README)}}}

#+BEGIN_SRC sh :dir snapkite/snapkite-engine/ :results output :exports results
echo ========================================
echo Snapkite-Engine README
echo ========================================
cat README.md
echo ========================================
echo
#+END_SRC

{{{heading(Configure the Snapkite-Engine)}}}

<<configure-Snapkite>>To configure the Snapkite Engine, assuming you are in the
~<dir>/snapkite-engine/~ directory, copy the ~./example.config.json~ file to
~./config.json~ by the following command:
: cp example.config.json config.json

{{{subheading(The Snapkite-Engine ~config.json~ File)}}}

#+NAME:configure Snapkite-Engine
#+BEGIN_SRC sh :dir snapkite/snapkite-engine :results output :exports results
[ -e config.json ] && echo config.json already copied || cp -v example.config.json config.json
cat config.json
#+END_SRC

**** Add Tracking Keywords

#+CINDEX:@file{config.json}
#+CINDEX:@code{trackKeywords}
<<config.json>>Open ~config.json~ in your editor to edit the configuration
properties and look for the <<trackKeywords>> =trackKeywords= key (marked by
=<<<<=).  This is where we will tell what keywords we want to track.  If we
want to track the keyword =my=, then set it as follows:
  : "trackKeywords": "my"

#+NAME:show-config-with-secrets
#+BEGIN_SRC sh :dir snapkite/snapkite-engine :results output :exports results
echo CONFIG.JSON
echo =========================================
cat config.json | sed -E \
  -e '/^.*trackKeywords.*$/s//&  <<<</' \
  -e '/("consumerKey": |"consumerSecret": |"accessTokenKey": |"accessTokenSecret": ).*$/s//\1SECRET/'
echo =========================================
#+END_SRC

Note: This step is combined with the next step; see line [[(add-my-keyword)]].

**** Add Consumer and Access Token Keys to Configuration

#+CINDEX:Twitter Streaming API keys, access token
#+CINDEX:keys, Twitter Streaming API
#+CINDEX:access token, Twitter Streaming API
<<Twitter-keys-and-token>>Set our Twitter Streaming API keys.  Set:
   - ~consumerKey~
   - ~consumerSecret~
   - ~accessTokenKey~
   - ~accessTokenSecret~
     #+CINDEX:Snapkite Engine documentation
     #+CINDEX:documentation, Snapkite Engine
   - other properties can be set to their defaults[fn::check out the Snapkite
     Engine [[https://github.com/snapkite/snapkite-engine][documentation]]]


#+NAME:check-config-keys
#+BEGIN_SRC sh :dir snapkite/snapkite-engine :results value :exports none
grep --silent '"consumerKey": ""' config.json && echo 1 || echo 0
#+END_SRC

#+NAME: add-keys-to-config.json
#+HEADER: :noweb eval :results output :exports both
#+HEADER: :dir snapkite/snapkite-engine
#+BEGIN_SRC js -n
if (<<check-config-keys()>> === 1) {
  var fs = require('fs');
  fs.copyFileSync('config.json','config.json.bak',fs.constants.COPYFILE_EXCL);

  console.log("Configuring 'config.json' with secret keys.");
  var cjson = JSON.parse(fs.readFileSync('config.json', 'utf8'));
  cjson.application.trackKeywords = "my";	(ref:add-my-keyword)
  cjson.twitter.api = {
      "consumerKey": process.env.TWITTER_CONSUMER_KEY,
      "consumerSecret": process.env.TWITTER_CONSUMER_SECRET,
      "accessTokenKey": process.env.TWITTER_ACCESS_TOKEN_KEY,
      "accessTokenSecret": process.env.TWITTER_ACCESS_TOKEN_SECRET
  }
  cjson = JSON.stringify(cjson,null,2);

  fs.writeFileSync('config.json', cjson);
  console.log("keys installed");
} else {
  console.log("Not configuring 'config.json'; keys already installed.");
}
#+END_SRC

#+CALL:show-config-with-secrets()

**** Install Snapkite Filters

#+CINDEX:Snapkite Filter module
#+CINDEX:Snapkite Filters, list
<<install-Snapkite-filters>>Install Snapkite Filters.  =Snapkite Filter= is a
Node.js module that validates tweets according to a set of rules.  There are a
number of Snapkite Filters out there, and we can use any combination of them to
filter our stream of tweets as we like.  You can find a list of all available
Snapkite Filters at https://github.com/snapkite/snapkite-filters.

#+CINDEX:Snapkite Filters, used in project
In our application, we'll use the following Snapkite Filters:

     #+CINDEX:@code{is-possibly-sensitive} Snapkite filter
   - <<is-possibly-sensitive-filter>>Is Possibly Sensitive ::
        https://github.com/snapkite/snapkite-filter-is-possibly-sensitive

     #+CINDEX:@code{has-mobile-photo} Snapkite filter
   - <<has-mobile-photo-filter>>Has Mobile Photo ::
        https://github.com/snapkite/snapkite-filter-has-mobile-photo

     #+CINDEX:@code{is-retweet} Snapkite filter
   - <<is-retweet-filter>>Is Retweet ::
        https://github.com/snapkite/snapkite-filter-is-retweet

     #+CINDEX:@code{has-text} Snapkite filter
   - <<has-text-filter>>Has Text ::
        https://github.com/snapkite/snapkite-filter-has-text


#+CINDEX:install Snapkite filters
#+CINDEX:Snapkite filters, install
{{{heading(Install the Snapkite Filters)}}}
Navigate to the ~<dir>/snapkite-engine/filters/~ directory:
: cd <dir>/snapkite-engine/filters/

Clone all Snapkite Filters by running these commands:

#+NAME:install Snapkite filters
#+HEADER: :results output silent :exports both
#+BEGIN_SRC sh :dir snapkite/snapkite-engine/filters
[ -d snapkite-filter-is-possibly-sensitive ] && echo filters already added || { \
  git clone https://github.com/snapkite/snapkite-filter-is-possibly-sensitive
  git clone https://github.com/snapkite/snapkite-filter-has-mobile-photo
  git clone https://github.com/snapkite/snapkite-filter-is-retweet
  git clone https://github.com/snapkite/snapkite-filter-has-text
}
#+END_SRC

#+CINDEX:Snapkite filters, configure
#+CINDEX:configure Snapkite filters
{{{heading(Configure the Snapkite Filters)}}}

<<configure-Snapkite-filters>>In order to do so, you need to create a
configuration file for each Snapkite Filter in JSON format and define some
properties in it.  Each Snapkite Filter comes with an example configuration
file that we can duplicate and edit as needed.

While in the ~<dir>/snapkite-engine/filters/~ directory, run the following
commands:

: cp snapkite-filter-is-possibly-sensitive/example.config.json
: snapkite-filter-is-possibly-sensitive/config.json

: cp snapkite-filter-has-mobile-photo/example.config.json
: snapkite/snapkite-filter-has-mobile-photo/config.json

: cp snapkite-filter-is-retweet/example.config.json
: snapkite-filter-is-retweet/config.json

: cp snapkite-filter-has-text/example.config.json
: snapkite-filter-has-text/config.json

We don't need to change any of the default settings in these ~config.json~
files, as they are already configured to fit our purposes.

#+NAME:configure Snapkite Filters
#+HEADER: :dir snapkite/snapkite-engine/filters
#+HEADER: :results output :exports both
#+BEGIN_SRC sh
[ -e snapkite-filter-is-possibly-sensitive/config.json ] && echo filters already configured || { \
  for filter in *
  do
    cp -v $filter/example.config.json $filter/config.json
  done
}
#+END_SRC

**** Configure Snapkite Engine to Use Filters

<<Snapkite-config.json>>Tell Snapkite Engine which Snapkite Filters it should
use.  Open the ~<dir>/snapkite-engine/config.json~ file in a text editor and
look for this:
: "filters" : []

Now replace that with the following:

#+BEGIN_EXAMPLE
"filters": [
      "snapkite-filter-is-possibly-sensitive",
      "snapkite-filter-has-mobile-photo",
      "snapkite-filter-is-retweet",
      "snapkite-filter-has-text"
]
#+END_EXAMPLE

#+NAME:check-filters-config
#+BEGIN_SRC sh :dir snapkite/snapkite-engine :results value :exports none
grep --silent '"filters": \[\]' config.json && echo 1 || echo 0
#+END_SRC

{{{heading(Add the Snapkite Filters)}}}

#+NAME:Add filters to Snapkite Engine config
#+HEADER: :noweb eval
#+HEADER: :dir snapkite/snapkite-engine :results output :exports both
#+BEGIN_SRC js
if (<<check-filters-config()>> === 1) {
  var fs = require('fs');
  fs.copyFileSync('config.json', 'config.json.bak2', fs.constants.COPYFILE_EXCL);
  var cjson = JSON.parse(fs.readFileSync('config.json', 'utf8'));
  cjson.application.filters = [
      "snapkite-filter-is-possibly-sensitive",
      "snapkite-filter-has-mobile-photo",
      "snapkite-filter-is-retweet",
      "snapkite-filter-has-text"
  ];
  fs.writeFileSync('config.json', JSON.stringify(cjson,null,2));
  console.log("Snapkite filters installed");
} else {
  console.log("Snapkite filters already installed");
}
#+END_SRC

**** Run the Snapkite Engine

#+CINDEX:Snapkite Engine, test run
<<test-Snapkite-Engine>>With that you have successfully installed Snapkite
Engine with a number of Snapkite Filters.  Now let's check if we can run it.
Navigate to ~<dir>/snapkite-engine~ and run:
: $ npm start
: [Snapkite][Socket] Listening on port 3000

#+NAME: start-snapkite-engine
#+HEADER: :dir snapkite/snapkite-engine :exports both :results value
#+BEGIN_SRC elisp
(start-process "snapkite-engine" "start-snapkite-engine" "yarn" "start")
#+END_SRC

You should see no error messages.  If you do and you are not sure how to fix
them, go to https://github.com/fedosejev/react-essentials/issues, create a new
issue and copy/paste the error message that you get.

** Creating the Project Structure

#+CINDEX:project structure, create
#+CINDEX:structure organization
#+CINDEX:organization of project
#+CINDEX:architecture of project
Now create our project structure.  Organizing source files is not a simple
task.  A well-thought-out project structure organization helps us understand
the underlying architecture of our application.

{{{subheading(Root Project Directory)}}}

#+CINDEX:root project directory
#+CINDEX:@file{snapterest} directory
<<create-root-project-directory>>Start by creating a /root project directory/
named {{{file(snapterest/)}}} inside a directory of your choice:
{{{file(<dir>/snapterest/)}}}.  Inside it create two other directories:

  #+CINDEX:@file{source} directory
  #+CINDEX:@file{components} directory
  #+CINDEX:directories, @file{source}, @file{components}
- <<source-directory>>{{{file(<dir>/snapterest/source/)}}} ::
     store our source JavaScript files
     - {{{file(components/)}}} ::
       create this directory inside the {{{file(source/)}}} directory

  #+CINDEX:@file{build} directory
  #+CINDEX:directory, @file{build}
- <<build-directory>>{{{file(<dir>/snapterest/build/)}}} ::
     store compiled JavaScript files and an HTML file


{{{subheading(Populate the project structure with an application file)}}}

   #+CINDEX:@file{app.js}
   #+CINDEX:application file, @file{app.js}
- <<application-file>>{{{file(app.js)}}} ::

     place the main application file in the ~source/~ directory.  This file
     will be the entry point to our application.  Leave it empty for now.

{{{subheading(Shell Script to Create Project Structure)}}}

#+NAME:shell script to create project structure
#+CAPTION:Shell script to create the project structure
#+BEGIN_SRC sh :results output :exports both
echo Creating the project structure...
[ -d snapterest ]        || mkdir -v snapterest
[ -d snapterest/build ]  || mkdir -v snapterest/build
[ -d snapterest/source ] || mkdir -v snapterest/source
[ -e snapterest/app.js ] || touch snapterest/source/app.js
echo
tree snapterest -I node_modules
#+END_SRC

** Building the Project

{{{heading(DRY---Don't Repeat Yourself)}}}

#+CINDEX:DRY
#+CINDEX:code reuse
#+BEGIN_QUOTE
One of the core principles in software development --- code reuse: The best
code is the one that you don't need to write.  One of the goals in this project
is to write as little code as possible.  React helps us achieve this goal.
#+END_QUOTE

#+CINDEX:declarative programming style
#+CINDEX:programming style, declarative
#+CINDEX:code reuse
When it comes to not writing code, we can apply the following strategies:

- Writing our code in a /declarative/ programming style
- Reusing the code written by someone else


{{{subheading(Coding Declaratively)}}}

#+CINDEX:jQuery
We'll be using both these techniques.  The first one is covered by React
itself.  React leaves us no choice but to write our JavaScript code in a
/declarative/ style.  This means that instead of telling our web browser how to
do what we want (like we do in jQuery), we just tell it =what= we want it to do
and the =how= part is explained by React.

{{{subheading(Reusing Code Already Written)}}}

#+CINDEX:npm
Node.js and npm cover the second technique.  There are over a hundred thousand
different Node.js applications available for us to use.  This means that most
likely someone has already implemented the functionality that our application
depends on.

#+CINDEX:@command{npm install}
#+CINDEX:@file{package.json}
#+CINDEX:metadata, project
#+CINDEX:project metadata
The question is how do we know from where to get all these Node.js applications
that we want to reuse.  We can install them via the ~npm install
<package-name>~ command.  In the npm context, a Node.js application is called a
*package*, and each *npm package* has a ~package.json~ file that describes the
metadata associated with that package.[fn::[[https://docs.npmjs.com/files/package.json][package.json docs]]]

*** Code Reuse using Node.js Module Packages
:PROPERTIES:
:CUSTOM_ID: create package.json
:END:

#+CINDEX:package, initialize
#+CINDEX:Node package, initialize
#+CINDEX:initialize a Node package
#+CINDEX:metadata file
#+CINDEX:@file{package.json}
#+CINDEX:@command{npm install}
Before we install our /dependency packages/, we will /initialize/ a *package*
for our own project.  Normally, ~package.json~ is only required when you want
to submit your package to the npm registry so that others can reuse your
Node.js application.  While we're not going to build a Node.js application, and we're
not going to submit our project to npm, we can use the Node.js Package system
to keep track of project dependencies.

**** Creating The {{{file(package.json)}}} File

The ~package.json~ file is technically only a metadata file that the ~npm~
command understands, and as such, we can use it to store a list of dependencies
that our application requires.  Once we store a list of dependencies in
~package.json~, we can easily install them anytime with the ~npm install~
command; npm will figure out from where to get them automatically.

{{{subheading(Initialize a {{{file(package.json)}}} File)}}}

#+CINDEX:@file{package.json} create
#+CINDEX:create @file{package.json}
How do we create the ~package.json~ file for our own application?
{{{command(npm)}}} comes with an interactive tool that asks us a bunch of
questions and then, based on our answers, creates a new ~package.json~ for our
project.

#+CINDEX:@command{npm init} command
#+CINDEX:initialize @file{package.json}
<<run-npm-init>>From the ~<dir>/snapterest/~ directory, run:
: npm init
or
: yarn init

{{{noindent}}}Accept all the defaults.

{{{subheading(Shell Script to Create a Project ~package.json~)}}}

#+NAME:run yarn init
#+HEADER: :exports results :results output
#+BEGIN_SRC sh :dir snapterest
[ -e package.json ] || yarn init --yes
echo
echo Package.json
echo ============
cat package.json
#+END_SRC

**** Node Modules and Modular Programming

#+CINDEX:modular application
#+CINDEX:modules
#+CINDEX:Node.js modules
After creating your package using {{{command(npm init)}}}, you are now ready to
install other Node.js applications that you can reuse.  An application that is
built of multiple individual applications is called {{{dfn(modular)}}} whereas
individual applications are called {{{dfn(modules)}}} This is what we will call
our Node.js dependencies from now on: *Node.js modules*

{{{subheading(Packaging using the Build Process)}}}

#+CINDEX:build development process
#+CINDEX:build script
#+CINDEX:packaging
#+CINDEX:building
<<building>>There will be a step in your development process called /building/.
During this step, your build script will take your source files and all your
Node.js dependency packages, and transform them into a single file that web
browsers can successfully execute.  The most important part of this building
process is called {{{dfn(packaging)}}}.  But what do you need to package and
why?  You're not creating a Node.js application, but yet you're talking about
reusing Node.js modules.  Does this mean that you'll be reusing Node.js modules
in a non-Node.js application?  Is that even possible?  Yes, there is a way of
doing that.

*** Bundling Dependency Node Modules using Browserify

#+CINDEX:Browserify, dfn
#+CINDEX:bundling, using Browserify
#+CINDEX:build process, using Browserify
<<Browserify>>{{{dfn(Browserify)}}} ([[*Browserify][Browserify]] in the Appendix) is a tool used
for {{{dfn(bundling)}}} all your dependency files together in such a way that
you can use Node.js modules in client-side JavaScript applications in the
browser.  Learn more about it at the home page of [[http://browserify.org][Browserify]] on the web.

In other words, Browserify enables you to use Node.js modules in your
client-side JavaScript applications in the browser using the =module=,
=module.exports=, and ~require()~ functionality of Node.js.  Browserify will be
a part of your build process.

{{{subheading(Installing Browserify in your Project)}}}

#+CINDEX:install Browserify
#+CINDEX:Browserify, install
To use Browserify, you must install it into your project.  To install
Browserify in your project, run the following command from inside the
~<dir>/snapterest/~ directory:
: npm install --save-dev browserify
or
: yarn add --dev browserify

#+NAME:install Browserify
#+HEADER: :exports both :results output
#+BEGIN_SRC sh :dir snapterest
yarn add --dev browserify
#+END_SRC

*** Transpiling JSX Code using Babelify

#+CINDEX:Babelify
#+CINDEX:JSX syntax
Babelify transpiles code written in the JSX syntax into JavaScript code, which
will be introduced in the next chapter.

#+CINDEX:install @file{babelify} module
<<install-Browserify>>We have already installed the ~browserify~ module, so now
let's install the [[https://www.npmjs.com/package/babelify][~babelify~ module]] ([[*Babelify][Babelify]] in the Appendix) [fn::See [[https://github.com/fedosejev/react-essentials/blob/master/updates.md#chapter-1-page-14][errata]];
The book uses babelify version 6.  Version 7 introduced some [[https://github.com/fedosejev/react-essentials#i-get-syntaxerror-appjs-unexpected-token-when-i-run-gulp-command-what-should-i-do][breaking changes]];
to use Version 7, see [[https://github.com/fedosejev/react-essentials/issues/21#issuecomment-160316774][this comment]].][fn::The current version is now =10.0.0=.]:

#+NAME:install Babelify
#+HEADER: :exports both :results output
#+BEGIN_SRC sh :dir snapterest
yarn add --dev babelify @babel/core @babel/preset-env @babel/preset-react
#+END_SRC

*** Building the Project with Gulp.js

#+CINDEX:Gulp.js
#+CINDEX:build tools
#+CINDEX:build process
<<Gulp.js>>Today, any modern client-side application represents a mix of many
concerns that are addressed individually by various technologies.  Addressing
each concern individually simplifies the overall process of managing the
project's complexity.  The downside of this approach is that at some point in
your project, you need to put together all the individual parts into one
coherent application.  Developers use {{{dfn(build-tools)}}} to assemble their
projects from individual modules.  This process is called the {{{dfn(build)}}}
process and, depending on the size and complexity of your project, it can take
anywhere from milliseconds to hours to build.

{{{heading(Gulp.js Build Tool)}}}

The Node.js ecosystem has a great tool for automating your build process,
{{{file(Gulp.js)}}}.  You can learn more about it at [[http://gulpjs.com][Gulp]].

**** Installing Gulp

#+CINDEX:install Gulp.js
#+CINDEX:Gulp.js installation
Let's install Gulp using {{{command(npm)}}} or {{{command(yarn)}}}:
: npm install --save-dev gulp
or
: yarn add --dev gulp

#+NAME:install Gulp
#+HEADER: :exports results :results output
#+BEGIN_SRC sh :dir snapterest
yarn add --dev gulp
#+END_SRC

**** Installing the Vinyl-Source-Stream Module in Gulp

#+CINDEX:Vinyl Source Stream module
#+CINDEX:Browserify and Gulp
<<install-Vinyl-Source-Stream>>Why do we need to install the
[[https://www.npmjs.com/package/vinyl-source-stream][~vinyl-source-stream~ module]]?  It allows us to use Browserify and Gulp
together.  For more details on why this works, go to [[https://www.npmjs.com/package/vinyl-source-stream][Vinyl-Source-Stream]].
Let's install the ~vinyl-source-stream~ dependency module:

#+NAME:install vinyl-source-stream module
#+HEADER: :exports both :results output
#+BEGIN_SRC sh :dir snapterest
yarn add --dev vinyl-source-stream
#+END_SRC

**** Creating an Example Gulp File

#+CINDEX:gulpfile
#+CINDEX:@file{gulpfile.js}
<<example-gulpfile.js>>What is a /gulpfile/?  It's a file in which we describe
the build process.

Create a small example ~gulpfile.js~ in the ~<dir>/snapterest/~ directory and
add the following content to it: [fn::from
https://gulpjs.com/docs/en/getting-started/quick-start#create-a-gulpfile]

#+CAPTION:Example ~gulpfile.js~
#+NAME:example-gulpfile.js
#+BEGIN_SRC js :eval no
function defaultTask(cb) {
  console.log("I am about to learn the essentials of React.js");
  cb();
}

exports.default = defaultTask;
#+END_SRC

#+CINDEX:@command{gulp} command
<<gulp-command>>Now if you run the ~gulp~ command from inside this directory:
: yarn run gulp

{{{noindent}}} you will see output that looks like this:

#+CAPTION:Example Gulp Output
#+BEGIN_EXAMPLE
Using gulpfile ~/<dir>/snapterest/gulpfile.js
Starting 'default'...
I am about to learn the essentials of React.js
Finished 'default' after 62 us
#+END_EXAMPLE

**** Creating a Default Gulp Task to Build the Project

#+CINDEX:@samp{default} task
#+CINDEX:Gulp task
#+CINDEX:Gulp.js build system
#+CINDEX:Browserify
<<default-gulp-task>>By default when ~gulp~ is run, it executes a task called
=default=.  You now have a working Gulp build system.  Create a =default= task
that will package your source and dependency modules using Browserify
([[Browserify][Browserify]], above).

#+CINDEX:@file{gulpfile.js}
<<default-gulpfile.js>>Create a ~gulpfile.js~ in ~<dir>/snapterest~ with the
following code:

#+CAPTION:A default ~gulpfile.js~ that will package source and dependency modules using Browserify
#+NAME:default gulpfile
#+BEGIN_SRC js :tangle snapterest/gulpfile.js :eval no
var gulp = require('gulp');
var browserify = require('browserify');
var source = require('vinyl-source-stream');

gulp.task('default', function(cb) {
    return browserify('./source/app.js')
        .transform('babelify', {presets: ['@babel/preset-env', '@babel/preset-react']})
        .bundle()
        .pipe(source('snapterest.js'))
        .pipe(gulp.dest('./build/'));
        cb();
});
#+END_SRC

**** Test the Default Gulp Task

#+CINDEX:gulp default task
<<test-gulp-default-task>>Now we're ready to test our ~default~ task.  Run:

#+BEGIN_EXAMPLE
$ yarn run gulp
[19:06:03] Using gulpfile ~/Dev/Programming/WebDev/React/ReactJS-Essentials/snapterest/gulpfile.js
[19:06:03] Starting 'default'...
[19:06:03] Finished 'default' after 40 ms
#+END_EXAMPLE

#+NAME:run gulp
#+HEADER: :eval query-export
#+BEGIN_SRC sh :exports none
yarn run gulp
#+END_SRC

#+CINDEX:@file{build} directory
#+CINDEX:@file{snapterest.js} file
The project's ~<dir>/snapterest/build/~ directory now has the ~snapterest.js~
file with some code already inside it---that's our (empty) JavaScript
application with some Node.js modules that are ready to run in a web browser.

*** Creating a Web Page
:PROPERTIES:
:CUSTOM_ID: create web page
:END:

#+CINDEX:@file{index.html} file
#+CINDEX:@file{snapterest.js} file
#+CINDEX:@file{snapterest/build} directory
<<create-index.html>>All that is left to do is to create the ~index.html~ file
with a script link to our ~snapterest.js~ bundled file.

Create an ~index.html~ file in the ~<dir>/snapterest/build/~ directory and add
the following HTML markup to it:

#+CAPTION:Project Snapterest ~index.html~
#+NAME:index.html
#+BEGIN_SRC html :tangle snapterest/build/index.html :mkdirp yes :eval no
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="x-ua-compatible" content="ie-edge, chrome=1" />
    <title>Snapterest</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
  </head>
  <body>
    <div id="react-application">
      I am about to learn the essentials of React.js.
    </div>
    <script src="./snapterest.js"></script>
  </body>
</html>
#+END_SRC

Notice the ~<script src="./snapterest.js">~ tag just before the closing
=</body>= tag.  This links to the bundled file created by running the Gulp
default task.

<<open-index.html>>Now open ~<dir>/snapterest/build/index.html~ in a web browser.
You should see the following text: {{{samp(I am about to learn the essentials of
React.js)}}}.

** Summary

- We learned why we should use React to build user interfaces for modern web
  applications.

- We discussed the project that we'll be building in this book.

- We installed all the right tools

- We created the project's structure.

*** Installation and Configuration Steps

- [[install-node.js][Node.js and npm]]
- [[install-git][Git]]
- [[twitter-streaming][Twitter Streaming API]]
  + [[create-twitter-account][Create a Twitter Account]]
  + [[create-twitter-app][Twitter App]]
    - [[twitter-keys][Keys]]
    - [[twitter-token][Token]]
- [[#Snapkite Engine][Snapkite Engine]]
  + [[install Snapkite Engine][Install Snapkite Engine]]
  + [[install-node-gyp][Install =node-gyp= module and command]]
  + [[configure-Snapkite][Configure Snapkite Engine]]
    - [[config.json][~config.json~]]
    - [[trackKeywords][~trackKeywords~]]
    - [[Twitter-keys-and-token%0A][configure Twitter keys and access token]]
  + [[install-Snapkite-filters][Install Snapkite Filters]]
    - [[is-possibly-sensitive-filter][is possibly sensitive]]
    - [[has-mobile-photo-filter][has mobile photo]]
    - [[is-retweet-filter][is retweet]]
    - [[has-text-filter][has text]]
  + [[configure-Snapkite-filters][Configure Snapkite Filters]]
    - [[Snapkite-config.json][~config.json~]]
  + [[test-Snapkite-Engine][Test Snapkite Engine]]
- [[*Creating the Project Structure][Create Snapterest Project Structure]]
  - [[create-root-project-directory][create root project directory]]
    + [[source-directory][~source~ directory]]
    + [[build-directory][~build~ directory]]
    + [[application-file][~app.js~ file]]
    + [[#create package.json][~package.json~ file]]
      - [[run-npm-init][{{{command(npm init)}}}]]
- [[building][The Building Process]]
  + [[Browserify][Install Browserify]]
  + [[Gulp.js][Install Gulp.js]]
    - [[example-gulpfile.js][example ~gulpfile.js~]]
  + [[gulp-command][Run ~gulp~ command]]
    - [[default-gulp-task][default gulp task]]
    - [[default-gulpfile.js][default ~gulpfile.js~]]
  + [[install-Browserify][Install Browserify]]
  + [[install-Vinyl-Source-Stream][Install Vinyl-Source-Stream]]
  + [[test-gulp-default-task][Test Gulp Default Task]]
- [[#create web page][Create a Web Page]]
  + [[create-index.html][Create ~index.html~]]
  + [[open-index.html][Open ~index.html~]]

* Create Your First React Element

Creating a simple web application today involves writing the HTML, CSS, and
JavaScript code.  The reason we use three different technologies is because we
want to separate three different concerns:

- Content (HTML)
- Styling (CSS)
- Logic (JavaScript)


#+CINDEX:Single Page Application (SPA)
#+CINDEX:SPA, Single Page Application
We don't think of a website as a collection of web pages anymore.  Instead, we
build web applications that might have only one web page, and that web page
does not represent the layout for out content---it represents a /container/ for
our web application.  Such a web application with a single web page is called a
{{{dfn(Single Page Application (SPA))}}}.

How do we represent the rest of the content in a SPA?  Surely, we need to
create an additional layout using HTML tags.  Otherwise, how does a web browser
know what to render?

These are valid questions.  Let's take a look at how it works.

  #+CINDEX:Document Object Model (DOM)
  #+CINDEX:DOM, Document Object Model
- Once you load your web page in a web browser, it creates a {{{dfn(Document
  Object Model (DOM))}}} of that web page.  A DOM represents your web page in a
  tree structure, and at this point, it reflects the structure of the layout
  that you created with only HTML tags.  This is what happens regardless of
  whether you're building a traditional web page or an SPA.  The difference
  between the two is what happens next.

- If you are building a traditional web page then you would finish creating
  your web page's layout.

  #+CINDEX:JavaScript DOM API
  #+CINDEX:DOM API, JavaScript
- On the other hand, if you are building a SPA, then you would need to start
  creating additional elements by manipulating the DOM with JavaScript.  A web
  browser provides you with the {{{dfn(JavaScript DOM API)}}} to do this.  You
  can learn more about it at:
  - [[https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model][Document Object Model]]

- However, manipulating (or mutating) the DOM with JavaScript has two issues:

     #+CINDEX:imperative programming style
     #+CINDEX:programming style, imperative
     #+CINDEX:style, imperative programming
  1. Your programming style will be /imperative/ if you decide to use the
     JavaScript DOM API directly.  This programming style leads to a code base
     that is harder to maintain.

     #+CINDEX:DOM mutations
  2. DOM mutations are slow because they cannot be optimized for speed, unlike
     other JavaScript code.

  React solves both these problems for us.

** Understanding the Virtual DOM

Why do we need to manipulate the DOM in the first place?  Because our web
applications are not static.  They have /state/ represented by the {{{dfn(user
interface (UI))}}} that a web browser renders, and that state can be changed
when an event occurs.  What kind of events are we talking about?  There are two
types of events that we're interested in:

#+ATTR_TEXINFO: :indic b
- User events :: When a user types, clicks, scrolls, resizes, and so on
- Server events :: When an application receives data or an error from the
                   server


#+CINDEX:syncing states
What happens while handling these events?  Usually, we update the data that our
application depends on, and that data represents a state of our data model.  In
turn, when a state of our data model changes, we might want to reflect this
change by updating a state of our UI.  Looks like what we want is a way of
syncing the two states: the UI state and the data model state.  We want one to
react to the changes in the other and vice versa.

#+CINDEX:two-way data binding
#+CINDEX:key-value observing (KVO)
#+CINDEX:KVO, key-value observing
#+CINDEX:Ember.js
#+CINDEX:Knockout
#+CINDEX:Backbone
#+CINDEX:iOS
#+CINDEX:Angular
#+CINDEX:dirty checking
One of the ways to sync your application's UI state with an underlying data
model's state is {{{dfn(two-way data binding)}}}.  There are different types of
two-way data binding.  One of them is {{{dfn(key-value observing (KVO))}}},
which is used in *Ember.js*, *Knockout*, *Backbone*, and *iOS*, among others.
Another one is dirty checking, which is used in *Angular*.

#+CINDEX:virtual DOM
#+CINDEX:reactive
Instead of two-way data binding, React offers a different solution called the
{{{dfn(virtual DOM)}}}.  The virtual DOM is a fast, in-memory representation of
the real DOM, and it's an abstraction that allows us to treat JavaScript and
DOM as if they were reactive.

Here is how it works:

1. Whenever the state of your data model changes, the virtual DOM and React
   will rerender your UI to a virtual DOM representation.

2. React then calculates the difference between the two virtual DOM
   representations: the previous virtual DOM representation that was computed
   before the data was changed and the current virtual DOM representation that
   was computed after the data was changed.  This difference between the two
   virtual DOM representations is what actually needs to be changed in the real
   DOM.

3. React updates only what needs to be updated in the real DOM.


The process of finding a difference between the two representations of the
virtual DOM and rerendering only the updated patches in a real DOM is fast.
Aslo, the best part is, as a React developer, that you don't need to worry
about what actually needs to be rerendered.,  React allows you to write your
code as if you were rerendering the entire DOM every time your application's
state changes.

You would like to learn more about the virtual DOM, the rationale behind it,
and how it can be compared to data binding, then watch this talk by Pete Hunt
from Facebook at https://www.youtube.com/watch?v=-DX3vJiqxm4.  See also [[https://www.youtube.com/watch?v=d7pyEDqBDeE][Tech
Talk: What is the Virtual DOM?]]

** Installing React

To start using the React library, we need to first install it.  I am going to
show you two ways of doing this: the simplest one and the one using the
{{{command(npm install)}}} command.

{{{heading(Using a <Script> Tag)}}}

The simplest way is to add the ~<script>~ tag to your
~/snapterest/build/index.html~ file.

- For the development version of React, add the following command:

  : <script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.0-beta3/react.js"></script>

- For the production version of React, add the following command:

  : script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.14.0-beta3/react.min.js"></script>


There is a difference between the two that we'll learn about in the later
chapters of this book.  For our project, we'll be using the development of
React.

At the time of this writing, the latest version of React library is
0.14.0-beta3.  Over time, React gets updated, so make sure you use the latest
version that is available to you, unless it introduces breaking changes that
are incompatible with the code samples provided in this book.  Visit
https://github.com/fedosejev/react-essentials to learn about any compatibility
issues between the codce samples and the latest version of React.

{{{heading(Importing React from npm)}}}

You learned about *Browserify* that allows us to import all the dependency
modules for our application using the ~require()~ function.  We'll be using
~require()~ to import the React library as well, which means that, instead of
adding a ~<script>~ tag to our ~index.html~, we'll be using the {{{command(npm
install)}}} to install React:

1. Navigate to the ~<dir>/snapterest/~ directory and run this command:

   : npm install --save react@0.14.8 react-dom@0.14.8

#+NAME:install React
#+HEADER: :results output :exports both
#+BEGIN_SRC sh :dir snapterest
yarn add react@0.14.8 react-dom@0.14.8
#+END_SRC

2. Then, open the ~<dir>/snapterest/source/app.js~ file in your text editor and
   import the React and ReactDOM libraries to the ~React~ and ~ReactDOM~
   variables, respectively:

   : var React = require('react');
   : var ReactDOM = require('react-dom');

   [[app.js creation][app.js creation]].

The ~react~ package contains methods that are concerned with the key idea
behind React, that is, describing what you want to render in a declarative way.
On the other hand, the ~react-dom~ package offers methods that are responsible
for rendering to the DOM.  You can read more about why developers at Facebook,
think it's a good idea to separate the React library into two packages at
https://facebook.github.io/react/blog/2015/07/03/react-v0.14-beta-1.html#two-packages.

Now we're ready to start using the React library in our project.  Next, let's
create our first React Element.

** Creating React Elements with JavaScript

We'll start by familiarizing ourselves with a fundamental React terminology.
It will help us build a clear picture of what the React library is made of.
This terminology will most likely update over time, so keep an eye on the
official documentation at https://reactjs.org/docs/glossary.html.

Just like the DOM is a tree of nodes, React's virtual DOM is a tree of React
nodes.  One of the core types in React is called =ReactNode=.  It's a building
block for a virtual DOM, and it can be any one of these core types:

- =ReactElement=: ::

     This is the primary type in React.  It's a light, stateless, immutable,
     virtual representation of a DOM =Element=.

- =ReactText=: ::
                  This is a string or a number.  It represents textual content
                  and it's a virtual representation of a Text Node in the DOM.


=ReactElement='s and =ReactText='s are =ReactNode='s.  An array of
=ReactNode='s is called a =ReactFragment=.  You will see examples of all these
in this chapter.

** Example =ReactElement=

Let's start with an example of a =ReactElement=:

1. Add the following code to your ~<dir>/snapterest/source/app.js~ file:

   #+BEGIN_SRC js :eval no
   var reactElement = React.createElement('h1');
   ReactDOM.render(reactElement, document.getElementById('react-application'));
   #+END_SRC

2. Now your ~app.js~ file should look exactly like this:

   #+BEGIN_SRC js :eval no
   var React = require('react');
   var ReactDOM = require('react-dom');

   var reactElement = React.createElement('h1');
   ReactDOM.render(reactElement, document.getElementById('react-application'));
   #+END_SRC

3. Navigate to the ~<dir>/snapterest/~ directory and run Gulp's =default= task:

   #+BEGIN_EXAMPLE
   $ gulp
   [20:28:44] Using gulpfile <dir>/snapterest/gulpfile.js
   [20:28:44] Starting 'default'...
   [20:28:45] Finished 'default' after 988 ms
   #+END_EXAMPLE

4. Navigate to the ~<dir>/build/~ directory, and open ~index.html~ in a web
   browser.  You will see a blank web page.  Open *Developer Tools* in your web
   browser and inspect the HTML markup for your blank web page.  You should see
   this line among others:
   : <h1 data-reactid=".0"></h1>

   #+BEGIN_SRC html :eval no
   <html lang="en">
     <head>
       <meta charset="utf-8">
       <meta http-equiv="x-ua-compatible" content="ie-edge, chrome=1">
       <title>Snapterest</title>
       <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
     </head>
     <body>
        <div id="react-application">
          <h1 data-reactid=".0"></h1>
        </div>
        <script src="./snapterest.js"></script>
      </body>
    </html>
    #+END_SRC


We've just created your first React element.

** The Three Parameters of ~React.createElement()~

#+CINDEX:React object
#+CINDEX:@code{React.createElement()} method
#+CINDEX:parameters to @code{React.createElement()}
#+CINDEX:@code{type} parameter
#+CINDEX:@code{props} parameter
#+CINDEX:@code{children} parameter
The entry point to the React library is the =React= object.  This object has a
method called ~createElement()~ that takes three parameters:

1. =type=
2. =props=
3. =children=

Let's take a look at each parameter in more detail.

#+CINDEX:type parameter
*** The =type= Parameter
:PROPERTIES:
:CUSTOM_ID: createElement type parameter
:END:

The =type= parameter can be either a string or a ~ReactClass~:

- A string could be an HTML tag name such as `div', `p', `h1', and so on.
  React supports all the common HTML tags and attributes.  For a complete list
  of HTML tags and attributes supported by React, refer to:
  - [[https://reactjs.org/docs/dom-elements.html][DOM Elements]]

- A ~ReactClass~ is created via the ~React.createClass()~ method.  This will be
  introduced in more detail in [[#Chapter 3][Chapter 3]].


The =type= parameter describes how an HTML tag or a ~ReactClass~ is going to be
rendered.  In our example, we're rendering the ~h1~ HTML tag.

#+CINDEX:@code{props} parameter
*** The =props= Parameter
:PROPERTIES:
:CUSTOM_ID: props parameter
:END:

The =props= parameter is a JavaScript object passed from a parent element to a
child element (and not the other way around) with some properties that are
considered immutable, that is, those that should not be changed.

#+CINDEX:HTML attributes as @code{props}
While creating DOM elements with React, we can pass the =props= object with
properties that represent HTML attributes such as =class=, =style=, and so on.
For example, run the following commands:

#+BEGIN_SRC js :eval no
var React = require ('react');
var ReactDOM = require('react-dom');
var reactElement = React.createElement('h1', { className: 'header' });
ReactDOM.render(reactElement, document.getElementById('react-application');
#+END_SRC

The preceding code will create an ~h1~ HTML element with a =class= attribute
set to =header=:

#+CINDEX:@code{className} attribute
Notice that we name our property =className= rather than =class=.  The reason
is that the =class= keyword is reserved in JavaScript.  If you use =class= as a
property name, it will be ignored by React, and a helpful warning message will
be printed on the web browser's console.:

#+CINDEX:@code{data-reactid=".0"} attribute
What is this =data-reactid=".0" attribute doing in the ~h1~ tag?  It is added
and used by React to track the DOM nodes; it might be removed in a future
version of React.[fn::It has been.]

#+CINDEX:@code{children} parameter
*** The =children= Parameter

#+CINDEX:child elements
#+CINDEX:@code{ReactNode}
The =children= parameter describes what child elements this element should
have, if any.  A child element can be any type of ~ReactNode~: a virtual DOM
element represented by a ~ReactElement~, a string or a number represented by
~ReactText~, or an array of other ~ReactNode~'s which is also called a
~ReactFragment~.

Here is an example:

#+BEGIN_SRC js snapterest/source/app.js :eval no
var React = require('react');
var ReactDOM = require('react-dom');
var reactElement = React.createElement('h1', { className: 'header' }, 'This is React.');
ReactDOM.render(reactElement, document.getElementById('react-application'));
#+END_SRC

#+CAPTION:Example of ~children~ Parameter with a ~ReactText~ Element
#+NAME:ch2-ReactElement-children-param
[[file:img/ch2-ReactElement-children-param-50.png]]

This code will create an ~h1~ HTML element with a =class= attribute and a text
node, {{{samp(This is React.)}}}:

The ~h1~ tag is represented by a ~ReactElement~, while the {{{samp(This is
React.)}}} string is represented by a ~ReactText~.

*** The =children= Parameter with Multiple React Elements as Children

Next, create a React element with a number of other React elements as it's
children:

#+BEGIN_SRC js snapterest/source/app.js :eval no
var React = require('react');
var ReactDOM = require('react-dom');

var h1 = React.createElement('h1', { className: 'header', key: 'header' }, 'This is React.');
var p = React.createElement('p', { className: 'content', key: 'content' }, "And that's how it works.");
var reactFragment = [h1, p];
var section = React.createElement('section', { className: 'container' }, reactFragment);

ReactDOM.render(section, document.getElementById('react-application'));
#+END_SRC

#+CAPTION:The ~children~ Parameter with an Array of ReactElements
#+NAME:ch2-ReactElement-children-param-section
[[file:img/ch2-ReactElement-children-param-section-50.png]]

We've created three React elements: ~h1~, ~p~, and ~section~.  ~h1~ and ~p~
both have child text nodes, {{{samp(This is React.)}}} and {{{samp(And that's
how it works.)}}}, respectively.  The ~section~ has a child that is an array of
two ~ReactElement~'s, ~h1~ and ~p~, called ~reactFragment~.  This is also an
array of ~ReactNode~'s.  Each ~ReactElement~ in the ~reactFragment~ array must
have a =key= property that helps React to identify that ~ReactElement~.  As a
result, we get the following HTML markup:

#+BEGIN_SRC html :eval no
<section class="container" data-reactid=".0">
  <h1 class="header" data-reactid=".0.$header">This is React.</h1>
  <p class="content" data-reactid=".0.$content">And that's how it works.</p>
</section>
#+END_SRC

*** React's Factory Function ~React.CreateFactory()~

#+CINDEX:factory function
#+CINDEX:@code{React.createFactory()} method
Now we understand how to create React elements.  What if we wanted to create a
number of React elements of the same type?  Does it mean that we need to call
~React.createElement('type') over and over again for each element of the same
type?  We can, but we don't need to because React provides us with a factory
function called ~React.createFactory()~.  A {{{dfn(factory function)}}} is a
function that creates other functions.  This is exactly what
~React.createFactory('type')~ does: it creates a function that produces a
~ReactElement~ of a given type.

Consider the following example:

#+BEGIN_SRC js snapterest/source/app.js :eval no
var React = require('react');
var ReactDOM = require('react-dom');

var listItemElement1 = React.createElement('li', { className: 'item-1', key: 'item-1' }, 'Item 1');
var listItemElement2 = React.createElement('li', { className: 'item-2', key: 'item-2' }, 'Item 2');
var listItemElement3 = React.createElement('li', { className: 'item-3', key: 'item-3' }, 'Item 3');

var reactFragment = [ listItemElement1, listItemElement2, listItemElement3 ];
var listOfItems = React.createElement('u1', { className: 'list-of-items' }, reactFragment);

ReactDOM.render(listOfItems, document.getElementById('react-application'));
#+END_SRC

The preceeding example produces this HTML:

#+BEGIN_SRC html :eval no
<ul class="list-of-items" data-reactid=".0">
  <li class="item-1" data-reactid=".0.$item-1">Item 1</li>
  <li class="item-2" data-reactid=".0.$item-2">Item 1</li>
  <li class="item-3" data-reactid=".0.$item-3">Item 1</li>
</ul>
#+END_SRC

#+CINDEX:factory function
We can simplify it by first creating a factory function:

#+BEGIN_SRC js snapterest/source/app.js :eval no
var React = require('react');
var ReactDOM = require('react-dom');

var createListItemElement = React.createFactory('li');

var listItemElement1 = createListItemElement({ className: 'item-1', key: 'item-1' }, 'Item 1');
var listItemElement2 = createListItemElement({ className: 'item-2', key: 'item-2' }, 'Item 2');
var listItemElement3 = createListItemElement({ className: 'item-3', key: 'item-3' }, 'Item 3');

var reactFragment = [ listItemElement1, listItemElement2, listItemElement3 ];
var listOfItems = React.createElement('ul', { className: 'list-of-items' }, reactFragment);

ReactDOM.render(listOfItems, document.getElementById('react-application'));
#+END_SRC

#+CAPTION:Creating Children with a Factory Function
#+NAME:ch2-ReactElement-children-factory-function
[[file:img/ch2-ReactElement-children-factory-function-50.png]]

#+CINDEX:@code{React.createFactory()} method
In the preceding example, we're first called the ~React.createFactory()~
function and passing a ~li~ tag name as a =type= parameter.  Then, the
~React.createFactory()~ function returns a new function that we can use as a
convenient shorthand to create elements of type ~li~.  We store a reference to
this function in a variable called ~createListItemElement~.  Then we call this
function three times, and each time we only pass the =props= and =childre=
parameters, which are unique for each element.  Notice that
~React.createElement()~ and ~React.createFactory()~ both expect the HTML tag
name string (such as ~li~) or the ~ReactClass~ object as a type parameter.

*** React's Built-in Factory Functions

#+CINDEX:factory functions, built-in to React
#+CINDEX:@code{React.DOM.#} methods
React provides a number of built-in factory functions to create the common HTML
tags.  You can call them from the ~React.DOM~ object; for example:
- ~React.DOM.ul()~
- ~React.DOM.li()~
- ~React.DOM.div()~


and so on.  Using them, we can simplify our previous example even further:

#+CAPTION:Creating a DOM Structure Using Built-in Factory Functions
#+NAME:built-in-factory-function-app.js
#+BEGIN_SRC js snapterest/source/app.js :eval no
var React = require('react');
var ReactDOM = require('react-dom');

var listItemElement1 = React.DOM.li({ className: 'itemDOM-1', key: 'item-1' }, 'Item 1');
var listItemElement2 = React.DOM.li({ className: 'itemDOM-2', key: 'item-2' }, 'Item 2');
var listItemElement3 = React.DOM.li({ className: 'itemDOM-3', key: 'item-3' }, 'Item 3');

var reactFragment = [ listItemElement1, listItemElement2, listItemElement3 ];
var listOfItems = React.DOM.ul({ className: 'list-of-items' }, reactFragment);

ReactDOM.render(listOfItems, document.getElementById('react-application'));
#+END_SRC

#+CINDEX:tree of @code{ReactNode}s
Now we know how to create a tree of ~ReactNode~'s.  However, there is one
important line of code that we need to discuss before we can progress further:


It renders our ~ReactNode~ tree to the DOM.  Let's take a closer look at how it
works.

** Rendering React Elements

{{{subheading(Parameters to ~ReactDOM.render()~)}}}

#+CINDEX:@code{ReactDOM.render()} method, parameters
The ~ReactDOM.render()~ method takes three parameters:

   #+CINDEX:@code{ReactElement}
1. ~ReactElement : A root element in the tree of ~ReactNodes~ that you have
   created
   #+CINDEX:@code{DOMElement}
2. ~DOMElement~ : A container DOM node for that tree.
   #+CINDEX:callback function
3. callback function : A function executed after the tree is rendered or
   updated.



#+CINDEX:@code{ReactElement}
It is important to note that if this ~ReactElement~ was previously rendered to
a parent DOM ~Element~, then ~ReactDOM.render()~ will perform an /update/ on
the already rendered DOM tree and only /mutate/ the DOM as it is necessary to
reflect the latest version of the ~ReactElement~.  This is why a virtual DOM
requires fewer DOM mutations.

{{{heading(Creating Static Web Content on a Server)}}}

#+CINDEX:initial page load
Can you think of a case when rendering a user interface on a client would be
slow?  The initial page load.  The problem with the initial page load is the
one mentioned at the beginning of this chapter---we're not creating static web
pages anymore.  Instead, when a web browser loads our web application, it
receives only the bare minimum HTML markup that is usually used as a container
or a parent element for our web application.  Then, our JavaScript code creates
the rest of the DOM, but in order for it to do so it often needs to request
extra data from the server.  However, getting this data takes time.  Once this
data is received, our JavaScript code starts to mutate the DOM.  We know that
DOM mutations are slow.  How can we solve this problem?

#+CINDEX:static web pages
#+CINDEX:mutate DOM in a server
The solution is instead of mutating the DOM in a web browser, we mutate it on a
server, just like we would with our static web pages.  A web browser will then
receive an HTML that fully represents a user interface of our web application
at the time of the initial page load.  But we can't mutate the DOM on a server
because it doesn't exist outside a web browser.

#+CINDEX:virtual DOM on a server
#+CINDEX:@code{ReactNode} tree
We have a virtual DOM that is just a JavaScript, and as you know using Node.js,
we can run JavaScript on a server.  So technically, we can use the React
library on a server, and we can create our ~ReactNode~ tree on a server.  The
question is how can we render it to a string that we can send to a client?

{{{subheading(ReactDOMServer.renderToString())}}} Method

#+CINDEX:@code{ReactDOMServer.renderToString()} method
React has a method called ~ReactDOMServer.renderToString()~ for just this
purpose.


It takes a ~ReactElement~ as a parameter and renders it to its initial HTML.
Not only is this faster than mutating a DOM on a client, but it also improves
the *Search Engine Optimization (SEO)* of your web application.

{{{subheading(ReactDOMServer.renderToStaticMarkup())}}} Method
<<renderToStaticMarkup>>

#+CINDEX:@code{ReactDOMServer.renderToStaticMarkup()} method
React can also generate static web pages:


Similar to ~ReactDOMServer.renderToString()~, this method also takes a
~ReactElement~ as a parameter and outputs an HTML string.  However, it doesn't
create the extra DOM attributes that React uses internally; rather, it produces
shorter HTML strings that we can transfer to the wire quickly.

Now you know not only how to create a virtual DOM tree using React Elements,
but you also know how to render it to a client and server.  Our next question
is whether we can do it quickly and in a more visual manner.

** Creating React Elements With JSX

When we build our virtual DOM by constantly calling the ~React.createElement()~
method, it becomes quite hard to visually translate these multiple function
calls into a hierarchy of HTML tags.  Don't forget that, even though we're
working with a virtual DOM, we're still creating a structure layout for our
content and user interface.  Wouldn't it be great to be able to visualize that
layout easily by simply looking at our React code?

#+CINDEX:JSX
{{{dfn(JSX)}}} is an optional HTML-like syntax that allows us to create a
virtual DOM tree without using the ~React.creatElement()~ method.

Let's [[built-in-factory-function-app.js]], which was created without using JSX.

Translate this to one using JSX:

#+CAPTION:Coding With JSX
#+NAME:jsx-app.js
#+BEGIN_SRC js snapterest/source/app.js :eval no
var React = require('react');
var ReactDOM = require('react-dom');

var listOfItems =
<ul className="list-of-items">
    <li className="jsx-item-1">Item 1</li>
    <li className="jsx-item-2">Item 2</li>
    <li className="jsx-item-3">Item 3</li>
</ul>;

ReactDOM.render(listOfItems, document.getElementById('react-application'));
#+END_SRC

JSX allows us to write HTML-like syntax in our JavaScript code.  More
importantly, we can now clearly see what our HTML layout will look like once
its rendered.  JSX is a convenience tool and it comes with a price in the form
of an additional transformation step.  Transformation of the JSX syntax into
valid JavaScript syntax must happen before our ``invalid'' JavaScript code is
interpreted.

#+CINDEX:@file{babelify} module
#+CINDEX:gulp default task
#+CINDEX:@file{gulpfile.js}
#+CINDEX:@command{.transform(babelify)} function call
In the previous chapter, we installed the ~babelify~ module that transforms our
JSX syntax into a JavaScript one.  This transformation happens every time we
run our =default= task from the {{{file(gulpfile.js)}}}
([[default gulpfile]]).  The ~transform(babelify)~ function call
transforms JSX into JavaScript before bundling it with the other JavaScript
code.

To test our transformation, run this command:

Then navigate to the ~<dir>/snapterest/build/~ directory, and open ~index.html~
in a web browser.  You will see a list of three items.

#+CAPTION:Creating a List of Items Using JSX
#+NAME:children-using-jsx
[[file:img/ch2-ReactElement-children-jsx-50.png]]

{{{heading(Online JSX Compiler)}}}

The React team has built an online JSX Compiler that you can use to test your
understanding of how JSX works.[fn::This tool has been removed as
JSXTransformer has been deprecated.]

** Summary

We started this chapter by discussing the issues with single web page
applications and how they can be addressed.  Then, we learned what a virtual
DOM is and how React allows us to build it.  We also installed React and
created our first React element using only JavaScript.  Then we also learned
how to render React elements in a web browser and on a server.  Finally, we
looked at a simpler way of creating React elements with JSX.

In the next chapter we'll dive deeper into the world of React components.

* Create Your First React Component
:PROPERTIES:
:CUSTOM_ID: Chapter 3
:END:

In the previous chapter, we learned how to create /React elements/ and how to
use them to render HTML markup.  We learned how easy it is to produce React
elements using /JSX/.  At this point, you know enough about React in order to
create the static web pages that we discussed in Chapter 2.  You want to build
interactive user interfaces that react to user and server events.  What does it
mean to react to an event?  How can a static HTML element /react/?   How can a
React element react?  In this chapter we'll answer these questions and many
other questions while introducing ourselves to /React components/.

** Stateless Versus Stateful

#+CINDEX:react
#+CINDEX:state, switch
#+CINDEX:virtual DOM elements
#+CINDEX:benefit of React library, easy to reason about
To {{{dfn(react)}}} means to switch from one state to another.  This means that
you need to have a state in the first place and the ability to change state.
Have we mentioned a state or the ability to change that state in React
elements?  No.  They are stateless.  Their sole purpose is to construct and
render virtual DOM elements.  In fact, we want them to render in the exact same
way, given that we provide them the exact same set of parameters.  We want them
to be consistent because it makes it easy for us to reason about them.  That's
one of the key benefits of using the React library---the ease of reasoning how
our web application works.

#+CINDEX:React Component
#+CINDEX:Component
#+CINDEX:state machine, component
How can we add a state to our stateless React elements?  If we can't
encapsulate a state in React elementsm, then *we should encapsulate React
elements in something that already has a state.*  Think of a simple state
machine that represents a user interface.  Every user action triggers a change
of a state in that state machine.  Every state is represented by a different
React element.  In the React library, this state machine is called a
{{{dfn(React Component)}}}.

** Creating Your First Stateless React Component

#+CINDEX:component, create
#+CINDEX:@code{React.createClass()} method
Let's take a look at the following example of how to create a React
/component/ (using the ~React.createClass()~ method):

#+CAPTION:An Example Stateless React Component
#+NAME:example stateless component
#+BEGIN_SRC js :eval no
var React = require('react');
var ReactDOM = require('react-dom');

var ReactClass = React.createClass({			(ref:1 class)
    render: function () {
        return React.createElement('h1',
                                   { className: 'header' },
                                   'React Component');
    }
});

var reactComponentElement = React.createElement(ReactClass); (ref:2 element)
var reactComponent = ReactDOM.render(reactComponentElement,	 (ref:3 component)
                                     document.getElementById('react-application'));
#+END_SRC

The new portions of this code can be broken down into three steps:

1. Creating a React class. [[(1 class)]]
2. Creating a React component element (using the class). [[(2 element)]]
3. Creating a React component (using the element). [[(3 component)]]

{{{heading(How to Create a React Component)}}}

#+CINDEX:React component, create
Let's take a closer look at how to create a React component.

   #+CINDEX:@code{React.createClass()} function
   #+CINDEX:@code{ReactClass}
   #+CINDEX:specification object
1. Create a ~ReactClass~ by calling the ~React.createClass()~ method and
   providing a /specification object/ as its parameter.  In this chapter we'll
   focus on learning about the specification objects in more detail.

   #+CINDEX:@code{ReactComponentElement}
   #+CINDEX:@code{React.createElement()} method
   #+CINDEX:~ReactClass~ as @samp{type} parameterx
2. Create a ~ReactComponentElement~ by calling the ~React.createElement()~
   method and providing our ~ReactClass~ as its =type= parameter.  In Chapter
   2, we learned that the =type= parameter can be either a string or a
   ~ReactClass~ ([[#createElement type parameter][The ~type~ Parameter]]).  In this chapter, you'll learn more
   about the latter.

   #+CINDEX:@code{ReactComponent}
   #+CINDEX:@code{ReactDOM.render()} method
3. Create a ~ReactComponent~ by calling the ~ReactDOM.render()~ method and
   providing our ~ReactComponentElement~ as its =element= parameter.

*** The Specification Object

#+CINDEX:specification object
#+CINDEX:look and feel
The {{{dfn(specification object)}}} that you pass as a parameter to
~React.createClass()~ is where your component's ``look and feel'' is defined.
*Specification* is the definition of your React component.  From now on, in
this chapter, we'll refer to a /specification object/ as a React component, and
in the rest of the chapter we will learn about this very important concept.

#+CINDEX:state, specification object
#+CINDEX:rendered, component by specification object
#+CINDEX:@code{render()} method
The /specification object/:

1) encapsulates a component's /state/ and
2) describes how a component is /rendered/.

At the very minimum, the React component needs to have a ~render()~ method that
returns at least =null= or =false=.

Here is an example of a specification object in its simplest form:

#+CAPTION:An Example of the Simplest Specification Object
#+NAME:simplest-specification-object
#+BEGIN_SRC js :eval no
{
    render: function () {
        return null;
    }
}
#+END_SRC

    #+CINDEX:@code{render()} method
The ~render()~ method is responsible for telling React how to render your
React component.  It can return =null=, and nothing will be rendered.  Or it
can return a ~ReactElement~ that we learned how to create in Chapter 2.

#+CAPTION:A Simple Specification Object Returning a ~ReactElement~
#+NAME:simple-specification-object
#+BEGIN_SRC js :eval no
{
    render: function () {
        return React.createElement('h1',
                                   { className: 'header' },
                                   'React Component');
    }
}
#+END_SRC

This example shows how we can encapsulate our React element inside our React
component.  We create a ~ReactElement~ of type =h1= with a =properties= object
and a ~ReactText~ as its only child.  Then, we return it when the ~render()~
method of our React component is called.  The fact that we encapsulated our
React element inside a React component doesn't affect how it will be rendered.


The produced HTML markup is identical to the one we created in Chapter 2
without using the React component.  In this case, you might be wondering what's
the benefit of having a ~render()~ method if we can render the exact same
markup without it?  The advantage of having a ~render()~ method is that, as
with any other function, before it returns a value, it can choose what value to
return.

*** Adding State and Conditional to a Component

So far, you've seen two examples of the ~render()~ method: one that returns
=null= and one that returns a React element.  We can merge the two and add a
condition that decides what to render:

#+CAPTION:A Simple Specification Object with State and a Conditional
#+NAME:simple-component-with-state
#+BEGIN_SRC js :eval no
{
    render: function () {
        var elementState = {
            isHidden: true
        };
        if (elementState.isHidden) {
            return null;
        }
        return React.createElement('h1',
                                   { className: 'header' },
                                   'React Component');
    }
}
#+END_SRC

#+CINDEX:state object
In this example, we created  the ~elementState~ variable that references an
object with a single ~isHidden~ property.  This object acts as a state for our
React element.  If we want to hide our React element, then we need to set the
value of ~elementState.isHidden~ to =true=, and our ~render()~ method will
return =null=.  In this case, React will render nothing.  Logically, by setting
~elementState.isHidden~ to =false=, will return our React element and the
expected HTML markup will be rendered.  The question you might ask is: how do
we set the value of ~elementState.isHidden~ to =false=?  Of to =true=?  Or how
do we change it in general?

Let's think of scenarios in which we might want to change that state.  One of
them is when a user interacts with our user interface.  Another one is when a
server sends data.  Or when a certain amount of time passes and then we want to
render something else.  Our ~render()~ method is not aware of all these events
and it shouldn't be because its sole purpose is to return a React element based
on the data that we pass to it.  How do we pass data to it?

*** Passing Data to a Component

    #+CINDEX:data, passing to a component
There are two ways to pass data to a ~render()~ method using the React API:

       #+CINDEX:@code{this.props}
1. Using the =properties= object: ~this.props~
       #+CINDEX:@code{this.state}
2. Using the =state= object: ~this.state~

{{{subheading(The ~props~ Parameter)}}}

#+CINDEX:@samp{props} parameter
#+CINDEX:attributes to HTML elements
We learned that the ~React.createElement()~ method accepts the =props=
parameter ([[#props parameter][The =props= Parameter]]).  We used it to pass attributes to our HTML
elements, but we didn't discuss what happens behind the scenes and why
attributes passed to the =props= object get rendered.

#+CINDEX:@code{this.props}
#+CINDEX:data with @samp{props} parameter
    #+CINDEX:accessing data in a component, @code{this.props}
Any data that you put in the =props= object and pass to the
~React.createElement()~ method can be accessed inside the ~render()~ method of
~ReactComponent~ via the ~this.props~ reference.  Once you have accessed data
from ~this.props~, you can render it:

#+CAPTION:Passing Props to a Component
#+NAME:component-using-props
#+BEGIN_SRC js :eval no
{
    render: function () {
        var elementState = {
            isHidden: true
        };
        if (elementState.isHidden) {
            return null;
        }
        return React.createElement('h1',
                                   { className: 'header' },
                                   this.props.header);		(ref:props)
    }
}
#+END_SRC

In this example, we're using ~this.props~ insider our ~render()~ method
([[(props)]]) to access the =header= property.  We're then passing
~this.props.header~ directly to the ~React.createElement()~ method as a child
string element.

In the preceding example, we can pass the value of ~isHidden~ as another
property of the ~this.props~ object (see [[(props-isHidden)]] (instead of
hard-coding ~isHidden~):

#+CAPTION:Example of Passing ~props~ to the ~render()~ Method
#+NAME:passing-props-to-component
#+BEGIN_SRC js :eval no
{
    render: function () {
        if (this.props.isHidden) {			(ref:props-isHidden)
            return null;
        }
        return React.createElement('h1',
                                   { className: 'header' },
                                   this.props.header);
    }
}
#+END_SRC

We can also use ~this.props~ to compute data that needs to be rendered (see
[[(props-to-render)]]):

#+CAPTION:Example of Using ~props~ to Compute a Value
#+NAME:use-props-to-compute
#+BEGIN_SRC js :eval no
{
    render: function () {
        if (this.props.isHidden) {
            return null;
        }
        var header = this.props.tweets.length + ' Latest Tweets'; (ref:props-to-render)
        return React.createElement('h1',
                                   { className: 'header' },
                                   this.props.header);
    }
}
#+END_SRC

We are accessing an array of tweets via ~this.props.tweets~ and getting its
~length~ property.  Then, we're concatenating a string ' Latest Tweets' to it.
The resulting string is stored in a ~header~ variable, and this is our computed
child string element that we're passing to the ~React.createElement()~ method.

{{{subheading(Pure Functions)}}}

#+CINDEX:pure function
Notice that in our previous example, instead of storing ~isHidden~ in a
~render()~ method, we're passing it via ~this.props~.  We removed our
~elementState~ object from it because we don't need to worry about the state in
our ~render()~ method.  It's a {{{dfn(pure function)}}}, which means that it
shouldn't mutate the state or access the real DOM, or otherwise interact with a
web browser.  Remember that we might want to use React on a server, where we
have no web browser, and we should expect the ~render()~ method to produce the
same result regardless of the environment.

*** Managing State

#+CINDEX:manage state
#+CINDEX:state management
If our ~render()~ method doesn't manage the state, then how do we manage it?
How do we set the state, and how do we update it while handling user or browser
events in React?

#+CINDEX:types of React components
#+CINDEX:components, types
Earlier in this chapter, we learned that in React we can represent a user
interface with React components.  There are two types of React components:

1. With state
2. Without state


#+CINDEX:stateless React components
Hold on, didn't we say that React components are state machines?  Surely, every
state machine needs to have a state.  You're correct; however, it's a good
practice to keep as many React components stateless as possible.

{{{subheading(Composable Elements and Separation of Concerns)}}}

React components are /composable/.  As a result, we can have a hierarchy of
React components.  Imagine that we have a parent React component that has two
child components, and each of them in turn has another two child components.
All the components are stateful and they can manage their own state.

#+CINDEX:separation of concerns
#+CINDEX:user interface
#+CINDEX:render data
How easy will it be to figure out what the last child component in the
hierarchy will render if the top component in the hierarchy updates its state?
Not easy.  There is a design pattern that removes this unnecessary complexity.
The idea is to separate your components into two concerns:

- how to handle the user interface interaction logic and
- how to render data.


- The minority of your React components are stateful.  They should be at the
  top of your component's hierarchy.  They encapsulate all of the interaction
  logic, manage the user interface state, and pass that state down the
  hierarchy to stateless components, using ~props~.

- The majority of your React components are stateless.  They receive data via
  ~this.props~ and then render that data.  The component is stateless.


In our previous example, we received ~isHidden~ state data vie ~this.props~ and
then we rendered that data.  Our component was stateless.

Next, let's create our first stateful component.

** Creating Your First Stateful Component

#+CINDEX:stateful components
#+CINDEX:interaction logic
#+CINDEX:manage state
Stateful components arre the most appropriate place for you application to
handle the interaction logic and manage the state.  They make it easier for you
to reason out how your application works.  This reasoning plays a key role in
buidling maintainable web applications.

{{{subheading(Setting Initial State with ~getInitialState()~)}}}

#+CINDEX:@code{this.state} property
#+CINDEX:@code{getInitialState()} method
React stores the component's state in ~this.state~, and it sets the initial
value of ~this.state~ to the value returned by the ~getInitialState()~ method.
However, it's up to us to tell React what the ~getInitialState()~ method will
return.  Let's add this method to our React component:

#+CAPTION:Simple Component Using ~getInitialState()~ Method
#+NAME:component-getInitialState
#+BEGIN_SRC js :eval no
{
    getInitialState: function () {
        return {
            isHidden: false
        }
    },

    render: function () {
        if (this.state.isHidden) {
            return null;
        }
        return React.createElement('h1',
                                   { className: 'header' },
                                   'React Component');
    }
}
#+END_SRC

In this example, our ~getInitialState()~ method returns an object with a single
~isHidden~ property that is set to false.  This is the initial state of our
React component and our user interface.  Notice that in our ~render()~ method
we're now referring to ~this.state.isHidden~ instead of ~this.props.isHidden~.

{{{subheading(Difference Between ~this.props~ and ~this.state~)}}}

#+CINDEX:props vs. state, difference
#+CINDEX:state vs. props, difference
Earlier in this chapter, you learned that we can pass data to the component's
~render()~ method via ~this.props~.  So, what's the difference between the two?

- ~this.props~ stores /read-only/ data that is passed from the parent.  It
  belongs to the parent and cannot be changed by its children.  This data
  should be considered /immutable/.

- ~this.state~ stores data that is private to the component.  It can be changed
  by the component.  The component will rerender itself when the state is
  updated.


{{{subheading(Setting State with ~setState()~)}}}

#+CINDEX:@code{setState()} method
How do we update a component's state?  There is a common way of informing React
of a state change using ~setState(DATA, CALLBACK)~.  This method takes two
parameters:

  #+CINDEX:@code{data} object to @code{setState()}
- The ~data~ object that represents the next state

  #+CINDEX:@code{callback} function to @code{setState()}
- The ~callback~ function, which you will rarely need to use because React
  keeps your user interface up-to-date for you.


*** Keeping the Interface Up-To-Date

How does React keep your user interface up-to-date?  It calls the component's
~render()~ method every time you update the component's state, including any
child components which are rendered as well.  In fact, it rerenders the entire
virtual DOM every time our ~render()~ method is called.

#+CINDEX:merge state
When you call the ~this.setState()~ method and pass it a data object that
represents the next state, React will merge that next state with the current
state.  During the merge, React will overwrite the current state with the next
state.  The current state that is not overwritten by the next state will become
part of the next state.

Image that this is our current state:

#+BEGIN_SRC js :eval no
{
    isHidden: true,
    title: 'Stateful React Component'
}
#+END_SRC

We call ~this.setState(nextState)~, where ~nextState~ is as follows:

#+BEGIN_SRC js :eval no
{
    isHidden: false
}
#+END_SRC

React will merge the two states into a new one:

#+BEGIN_SRC js :eval no
{
    isHidden: false,
    title: 'Stateful React Component'
}
#+END_SRC

The ~isHidden~ property is updated and the ~title~ property is not deleted or
updated in any way.

*** Creating a Component That Reacts to User Events

#+CINDEX:stateful component
#+CINDEX:react to user event
#+CINDEX:user event, reacting to
Now that we know how to update our component's state, let's create a stateful
component that reacts to a user event:

#+CAPTION:A stateful component that reacts to a user event
#+NAME:component-reacts-to-user-event
#+BEGIN_SRC js :eval no
{
    getInitialState: function () {
        return {
            isHeaderHidden: false,
            title: 'Stateful React Component'
        }
    },

    handleClick: function () {
        this.setState({
            isHeaderHidden: !this.state.isHeaderHidden		(ref:setState)
        });
    },

    render: function () {
        var headerElement = React.createElement('h1',
                                                { className: 'header', key: 'header' },
                                                this.state.title);
        var buttonElement = React.createElement('button',	(ref:createElement)
                                                { className: 'btn btn-default',
                                                  onClick: this.handleClick,		(ref:onClick)
                                                  key: 'button'},
                                                'Toggle header');
        if (this.state.isHeaderHidden) {
            return React.createElement('div', null, [ buttonElement ]);
        }
        return React.createElement('div', null, [ buttonElement, headerElement ]);
    }
}
#+END_SRC

In this example, we're creating a toggle button that shows and hides a header.
The first thing we do is set our initial state object by returning it from the
~getInitialState()~ method.  Our initial state has two properties:
~isHeaderHidden~ that is set to =false= and ~title~ that is set to =Stateful
React Component=.  Now we can access this state object in our ~render()~ method
via ~this.state~.  Inside our ~render()~ method, we create three React
elements: =hi=, =button=, and =div=.  Our =div= element acts as a parent
element for our =h1= and =button= elements.  However, in one case we create our
=div= element with two children, ~headerElement~ and ~buttonElement~, and in
another case we create it with only one child, ~buttonElement~.  The case we
choose depends on the value of ~this.state.isHeaderHidden~.  The current state
of our component directly affects what the ~render()~ method will render.
While this should look familiar to you, there is something new in this example
that we haven't seen before.

{{{subheading(Handling Events with Custom Component Properties)}}}

#+CINDEX:@code{handleClick()} method
#+CINDEX:@code{onClick} events
#+CINDEX:properties on component
Notice that we introduced a new property on our ~ReactComponent~ object, called
~handleClick()~, which is a method that has no special meaning to React.  It's
part of our application logic, and we use it to handle the ~onClick~ events.
You can add your own properties to the ~ReactComponent~ object.  All of these
will be available via a ~this~ reference, which you can access from any other
method that itself is a property of the component object.  For example, we
are accessing a state object via ~this.state~ in both the ~render()~ and
~handleClick()~ methods.

What does our ~handleClick()~ method do?  It updates our component's state by
setting the new value of this ~isHeaderHidden~ property to the opposite of the
existing one that it accesses via ~this.state.isHeaderHidden~ (see [[(setState)]]).

{{{subheading(Event Handlers in the =props= Parameter)}}}

#+CINDEX:event handler
#+CINDEX:attach event handler
Our ~handleClick()~ method reacts to a user interaction with our user
interface.  Our user interface is a =button= element that a user can click on,
and we can attach an event handler to.  In React, you can attach event handlers
to a React element by passing them to the ~props~ parameter in the
~createElement()~ method (see [[(onClick)]]).

#+CINDEX:CamelCase
#+CINDEX:events, list of supported
React uses the *CamelCase* naming convention for event handlers; for example,
~onClick~.  You can find a list of all the supported events at
https://reactjs.org/docs/events.html#supported-events.

#+CINDEX:bubble phase
#+CINDEX:capture phase
#+CINDEX:trigger event handlers
By default, React triggers the event handlers in the /bubble phase/, but you
can tell React to trigger them in the /capture phase/ by appending =Capture= to
the event name, for example, ~onClickCapture~.

#+CINDEX:@code{SyntheticEvent} object
React wraps a browser's native events into the ~SyntheticEvent~ object to
ensure that all the supported events behave identically in Internet Exploror 8
and above.

#+CINDEX:@code{nativeEvent} property
#+CINDEX:@code{initializeTouchEvents()} method
<<SyntheticEvent>>The ~SyntheticEvent~ object provides the same API as the
native browser's event, which means that you can use the ~stopPropogation()~
and ~preventDefault()~ methods as usual.  If for some reason, you need to
access the native browser's event, then you can do this via the ~nativeEvent~
property.  To enable touch-event handling, simply call
~React.initializeTouchEvents(TRUE)~.

#+CINDEX:inline event handler, none
Notice that passing the ~onClick~ property to our ~createElement()~ method in
the previous example does not create an inline event handler in the rendered
HTML markup.


#+CINDEX:listen for events, at top level
This is because React doesn't actually attach event handlers to the DOM nodes
themselves.  Instead, React listens for all the events at the top level using a
single event listener, and delegates them to their appropriate event handlers.

*** Keeping State Lean

In the previous example, you learned how to create a stateful React component
that a user can interact with and change its state.  We created and attached an
event handler to the ~onClick~ event that updates the value of the
~isHeaderHidden~ property.  But have you noticed that the user interaction does
not update the value of another property that we store in our state, ~title~?
Does thst seem odd to you?  We have data in our state that doesn't ever get
changed.  This observation raises an important question: what should we /not/
put in our state?

Ask yourself a question: what data can I remove from a component's state and
still keep its user interface always up to data?  Keep asking and keep removing
that data until you're absolutely certain that there is nothing left to remove
without breaking your user interface.

In our example, we have the ~title~ property in our state object that we can
move to our ~render()~ method without breaking the interactivity of our toggle
button.  The component will still work as expected:

#+CAPTION:A stateful component that reacts with minimal state
#+NAME:stateful-component-no-title
#+BEGIN_SRC js :eval no
{
    getInitialState: function () {
        return {
            isHeaderHidden: false
        }
    },

    handleClick: function () {
        this.setState({
            isHeaderHidden: !this.state.isHeaderHidden
        });
    },

    render: function () {
        var title = 'Stateful React Component';

        var headerElement = React.createElement('h1',
                                                { className: 'header', key: 'header' },
                                                title);
        var buttonElement = React.createElement('button',	(ref:createElement)
                                                { className: 'btn btn-default',
                                                  onClick: this.handleClick,
                                                  key: 'button' },
                                                'Toggle header');
        if (this.state.isHeaderHidden) {
            return React.createElement('div', null, [ buttonElement ]);
        }
        return React.createElement('div', null, [ buttonElement, headerElement ]);
    }
}
#+END_SRC

On the other hand, if we move the ~isHeaderHidden~ property out of a state
object, then we'll break the interactivity of our component because our
~render()~ method will not be triggered automatically by React every time a
user clicks on our button.  This is an example of broken interactivity.

This is an anti-pattern.  Remember this rule of thumb:

#+BEGIN_cartouche
A component's state should store data that a component's event handlers may
change over time in order to rerender a component's user interface and keep it
up to date.  Keep the minimal possible representation of a component's state in
a ~state~ object, and compute the rest of the data based on what's in ~state~
and ~props~ inside a component's ~render()~ method.  Anything you put in
~state~, you'll need to update yourself.  Anything you put in ~render()~ will
automatically get updated by React.  Take advantage of React.
#+END_cartouche

** An Example Stateful Component

#+CAPTION:An Example Stateful Component
#+NAME:example stateful component
#+BEGIN_SRC js -n :eval no
var React = require('react');
var ReactDOM = require('react-dom');

var ReactClass = React.createClass({
    getInitialState: function () {
        return ({
            isHeaderHidden: false
        })
    },

    handleClick: function () {
        this.setState({
            isHeaderHidden: !this.state.isHeaderHidden
        });
    },

    render: function () {
        var title = 'Stateful React Component';
        var headerElement = React.createElement('h1',
                                                { className: 'header',
                                                  key: 'header' },
                                                title);
        var buttonElement = React.createElement('button',
                                                { className: 'btn btn-default',
                                                  key: 'button',
                                                  onClick: this.handleClick },
                                                'Toggle header');

        if (this.state.isHeaderHidden) {
            return (React.createElement('div', null, [ buttonElement ]));
        }
        return (React.createElement('div', null, [ buttonElement, headerElement ]));
    }
});

var reactComponentElement = React.createElement(ReactClass);

var ReactComponent = ReactDOM.render(
    reactComponentElement,
    document.getElementById('react-application'));

#+END_SRC

** Summary

In this chapter we reached an important milestone: we learned how to
encapsulate a state and create interactive user interfaces by creating React
components.  We discussed stateless and stateful React components, and the
difference between them.  We talked about the browser events and how to handle
them in React.

In the next chapter, we'll be planning our Snapterest web application.  You'll
learn how to solve a problem with React and how to create composable React
components.

* Make Your React Components Reactive

Now that you know how to create React components with and without state, we can
start composing React components together and build more complex user
interfaces.  In fact, its time for us to start building our web application,
called *Snapterest*, that we discussed in Chapter 1.  While doing this, we'll
learn how to plan your React application and create composable React
components.

** Solving a Problem Using React

#+CINDEX:define the problem
Before you start writing code for your web application, you need to think about
the problems that your web application is going to solve.  It's very important
to understand that defining the problem as clearly and as early as possible is
the most important step toward a successful solution---a useful web
application.  If you fail to define your problem early in your development
process, or you define it inaccurately, then later on you'll have to stop,
rethink about what you're doing, throw away a piece of the code that you have
already written, and write a new one.  This is a wasteful approach, and as a
professional software developer your time is very valuable, not only to you,
but also to your organization, so it's in your best interests to invest it
wisely.  Earlier in this book, I stressed on the fact that one of the benefits
of using Reacgt is code reuse, which means that you'll be able to do more in
less time.  However, before we take a look at the React code, let's first
discuss the problem, keeping React in mind.

{{{heading(Snapterest Description)}}}

#+CINDEX:Snapterest description
#+CINDEX:Snapkite Engine server
We'll be building Snapterest---a web application that receives tweets from a
Snapkite Engine server in a real-time manner and displays them one at a time to
a user.  We don't actually know when Snapterest will receive a new tweet, but
when it does, it will display that new tweet for at least 1.5 seconds so that
the user has enought time to look at it and click on it.  Clicking on a tweet
will add it to an existing collection of tweets or create a new one.  Finally,
users will be able to export their collection to an HTML markup code.

{{{subheading(List of Smaller Tasks)}}}

#+CINDEX:task
This is a very high-level description of what we're going to build.  Let's
break it down into a list of smaller tasks:

#+BEGIN_EXAMPLE
Snapkite Engine
|
|
V
Receive Tweet               Remove Tweet from Collection
|                           ^
|                           |
V                           |
Display Tweet               Export Collection
|                           ^
|                           |
V                           |
Add Tweet to Collection --> Display Collection
#+END_EXAMPLE

1. Receive tweets from the Snapkite Engine server in real time
2. Display one tweet at a time for at least 1.5 seconds
3. Add tweets to a collection on a user click event
4. Display a list of tweets in a collection
5. Create an HTML markup code for a collection and export it
6. Remove tweetsw from a collection on a user event


{{{subheading(Using React to Solve Problems)}}}

#+CINDEX:solving tasks using React
Can you identify which tasks can be solved using React?  Remember that React is
a user interface library, so anything that describes the user interface and
interactions with that user interface can be addressed with React.  In the
preceding list, React can take care of all the tasks excdept for the first one
because it describes data fetching and not the user interface in any way.

Task 1 will be solved with another library that we'll discuss in the next
chapter.

#+CINDEX:display data
Tasks 2 and 4 describe something that needs to be displayed.  They are perfect
condidates for React components.

#+CINDEX:user events
Tasks 3 and 6 describe the user events, and as we've seen in Chapter 3, user
eventws handling can be encapsulated in React components as well.

#+CINDEX:@code{ReactDOMServer.renderToStaticMarkup()} method
#+CINDEX:static HTML markup
Can you think of how task 5 can be solved with React?  Remember in Chapter 2 we
discussed the ~ReactDomServer.renderToStaticMarkup()~ method that renders the
React element to a static HTML markup string.  That's exactly what we need in
order to solve task 5.

{{{subheading(Putting It All Together)}}}

Now that we've identified a potential solution for each individual task, let's
think about how we are going to put them together and create a fully functional
web application.

#+CINDEX:composable React application, building
There are two ways to build composable React applications:

1. You can start by building individual React components and then compose them
   together into higher-level React components, moving up the component hierarchy.

2. You can start from the topmost React element and then implement its child
   components, moving down the component hierarchy.


The second strategy has the advantage of seeing and understanding the big
picture of your application's architecture.  I think it's important to
understand how everthing fits together before we can think of how individual
pieces of functionality are implemented.

** Planning Your React Application

There are two simple guidelines we need to follow when planning your React
application:

1. Each React component should represent a single user interface element in
   your web application.  It should encapsulate the smallest element possible
   that can potentially be reused.

2. Multiple React components should be composed into a single React component.
   Ultimately, your entire user interface should be encapsulated in one React
   component.


#+BEGIN_EXAMPLE
Application --> Stream
                --> Header  --> StreamTweet
                                --> Header --> Tweet
--> Collection
    --> TweetList  --> Header --> CollectionControls
        --> Tweet                      --> Header  --> Button
                                  --> CollectionRenameForm  --> CollectionExportForm
                                      --> Header  --> Button
#+END_EXAMPLE

{{{heading(Application)}}}

#+CINDEX:@code{Application} component
#+CINDEX:@code{Stream} component
#+CINDEX:@code{Collection} component
We'll begin with our topmost React component, ~Application~.  It will
encapsulate our entire React application, and it will have two child
components: the ~Stream~ and ~Collection~ components.

{{{subheading(Stream)}}}

#+CINDEX:@code{Stream} component
The ~Stream~ component will be responsible for connecting to a stream of
tweets, and receiving  and displaying the latest tweet.  The ~Stream~ component
will have two child components: ~StreamTweet~ and ~Header~.

#+CINDEX:@code{StreamTweet} component
#+CINDEX:@code{Header} component
#+CINDEX:@code{Tweet} component
The ~StreamTweet~ component will be responsible for displaying the latest
tweet.  It will be composed of the ~Header~ and ~Tweet~ components.

#+CINDEX:@code{Header} component
#+CINDEX:@code{Tweet} component
A ~Header~ component will render a header.  It will have no child components.
A ~Tweet~ component will render an image from a tweet.

Notice how we're planning to reuse the ~Header~ component twice already.

{{{subheading(Collection)}}}

#+CINDEX:@code{Collection} component
#+CINDEX:@code{CollectionControls} component
#+CINDEX:@code{TweetList} component
The ~Collection~ component will be responsible for displaying the collection
controls and a list of tweets.  It will have two child components:
~CollectionControls~ and ~TweetList~.

#+CINDEX:codepen
#+CINDEX:@code{CollectionControls} component
#+CINDEX:@code{CollectionRenameForm} component
#+CINDEX:@code{CollectionExportForm} component
The ~CollectionControls~ will have two child components: the
~CollectionRenameForm~ component that will render a form to rename a
collection, and the ~CollectionExportForm~ component that will render a form to
export a collection tto a service called *CodePen*, which is an HTML, CSS, and
JavaScript playground website.  You can learn more about CodePen at
https://codepen.io.

#+CINDEX:@code{Header} component
#+CINDEX:@code{Button} component
#+CINDEX:@code{CollectionRenameForm} component
#+CINDEX:@code{CollectionControls} component
#+CINDEX:@code{TweetList} component
#+CINDEX:@code{Tweet} component
#+CINDEX:@code{Collection} component
As you might have noticed, we'll reuse the ~Header~ and ~Button~ components in
the ~CollectionRenameForm~ and ~CollectionControls~ components.  Our
~TweetList~ component will render a list of Tweets.  Each tweet will be
rendered by a ~Tweet~ component.  We'll be reusing the ~Header~ component once
again in our ~Collection~ component.  In fact, we'll be reusing the ~Header~
component five times.  That's a win for us.

{{{heading(State)}}}

#+CINDEX:stateless components
#+CINDEX:stateful components
As we discussed in the previous chapter, we should keep as many React
components stateless as possible.  So, only 5 out of 11 components will store
the state, which are:

- ~Application~
- ~CollectionControls~
- ~CollectionRenameForm~
- ~Stream~
- ~StreamTweet~


Now that we have a plan, we can start implementing.

** Creating a Container React Component

{{{heading(Root Application File)}}}

#+CINDEX:main application file, @file{app.js}
#+CINDEX:@file{app.js}
<<app.js creation>>Let's start by editing our application's main JavaScript
file.  Replace the contents of the ~<dir>/snapterest/source/app.js~ file with
the following code snippet:

#+CAPTION[<App Root Container>]:The React Application Root Container File
#+NAME:app root container component
#+BEGIN_SRC js :tangle snapterest/source/app.js :mkdirp yes :noweb yes :eval no
<<root container imports>>

<<root container render to dom>>
#+END_SRC

#+CAPTION:The imports of the root container ~app.js~
#+NAME:root container imports
#+BEGIN_SRC js :exports none :eval no
var React = require('react');
var ReactDOM = require('react-dom');
var Application = require('./components/Application.react');
#+END_SRC

#+CAPTION:Rendering the Application to the DOM
#+NAME:root container render to dom
#+BEGIN_SRC js :exports none :eval no
ReactDOM.render(<Application />, document.getElementById('react-application'));
#+END_SRC

There are only four lines of code in this file, and as you can guess, they
provide ~document.getElementById('react-application')~ as a deployment target
for the ~<Application />~ component and render ~<Application />~ to the DOM.
The whole user interface for our web application will be encapsulated in one
React component, ~Application~.

** Creating the React Application Component

#+CINDEX:@file{Application.react.js} file
#+CINDEX:React Application component
Next, navigate to ~<dir>/snapterest/source/components/~ and create the
~Application.react.js~ file inside this directory.  All of our React components
will have their filenames ending with ~react.js~.  This convention allows us to
easily distinguish between React and non-React source JavaScript files.

Let's take a look at the contents of the ~Application.react.js~ file:

#+CAPTION[<Application Component>]:The Application Component
#+NAME:Application component
#+HEADER: :noweb tangle :eval no
#+BEGIN_SRC js :tangle snapterest/source/components/Application.react.js :mkdirp yes
<<Application Dependencies>>

var Application = React.createClass({

 <<Application.getInitialState>>

    <<Application.addTweetToCollection>>

    <<Application.removeTweetFromCollection>>

    <<Application.removeAllTweetsFromCollection>>

    <<Application.render>>
});

module.exports = Application;
#+END_SRC

This component has significantly more code than our ~app.js~ file, but this code can
be easily divided into three logical parts:

1. Importing dependency modules
2. Defining React components
3. Exporting a React component as a module


#+CINDEX:CommonJS
You will see this logical separation in most of our React components because
they are wrapped into the *CommonJS* module pattern that allows us to easily
require them with Browserify.  In fact, the first and the third parts of this
source file are related to how CommonJS works and have nothing to do with how
React works.  The purpose of using this module pattern is to break our
application into modules that can be easily reused.  Because the React
component and CommonJS module pattern both encapsulate the code and mnake it
portable, they naturally work great together.  So, we end up encapsulating our
user interface logic in a React component and then encapsulate that React
component in the CommonJS module.  It then can be used in any other module that
wants to reuse this encapsulated React component.

*** Importing Dependency Modules

#+CINDEX:import dependencies
In our first logical part of the ~Application.react.js~ file, we're importing
the dependency modules using the ~require()~ function.

<<two child components>>Our ~Application~ component will have two child
components that we need to import:

1. The ~Stream~ component will render a stream section of our user interface
2. The ~Collection~ component will render a collection section of our user
   interface


We also need to import the ~React~ library as another module.  Notice that this
code is still part of the CommonJS module pattern, not React.

#+NAME:Application Dependencies
#+BEGIN_SRC js :eval no
var React      = require('react');
var Stream     = require('./Stream.react');
var Collection = require('./Collection.react');
#+END_SRC

*** Creating React Components

#+CINDEX:create components
The second logical part of the ~Application.react.js~ file creates the React
~Application~ component with the following methods:

- ~getInitialState()~
- ~addTweetToCollection()~
- ~removeTweetFromCollection()~
- ~removeAllTweetsFromCollection()~
- ~render()~


#+CINDEX:@code{getInitialState()} React method
#+CINDEX:@code{render()} React method
#+CINDEX:application logic
Only the ~getInitialState()~ and ~render()~ methods are part of the React API.
All the other methods are part of our application logic that this component
encapsulates.  We'll take a closer look at each of them right after we discuss
what this component renders inside its ~render()~ method.

#+NAME:Application.render
#+BEGIN_SRC js :noweb yes :eval no
<<Application.render-start>>
                    <<Stream with props>>
<<Application.render-mid>>
                    <<Collection with props>>
<<Application.render-end>>
#+END_SRC

#+NAME:Application.render-start
#+BEGIN_SRC js :exports none :eval no
render: function () {
    return (
        <div className="container-fluid">
            <div className="row">
                <div className="col-md-4 text-center">

#+END_SRC

#+NAME:Application.render-mid
#+BEGIN_SRC js :exports none :eval no

                </div>
                <div className="col-md-8">

#+END_SRC

#+NAME:Application.render-end
#+BEGIN_SRC js :exports none :eval no

                </div>
            </div>
        </div>
    );
}
#+END_SRC

#+CINDEX:Bootstrap
It defines the layout of our web page using the <<Bootstrap>>Bootstrap
framework.  If you're not familiar with Boostrap, I strongly recommend that you
visit https://getbootstrap.com/ and read the documentation.  Learning this
framework will empower you to prototype user interfaces in a fast and easy way.

Even if you don't know Bootstrap, it's quite easy to understand what's going
on.  We're dividing our web page into two columns: a smaller one and a larger
one.  The smaller one contains our ~Stream~ React component and the larger one
contains our ~Collection~ component.  You can imagine that our web page is
divided into two unequal parts and both of them contain the React components.

**** The Stream Component

#+CINDEX:@code{Stream} component
This is how we're using our ~Stream~ component:

#+NAME:Stream with props
#+BEGIN_SRC js :eval no
<Stream onAddTweetToCollection={this.addTweetToCollection} />
#+END_SRC

#+CINDEX:@code{onAddTweetToCollection} property
#+CINDEX:@code{addTweetToCollection()} method
The ~Stream~ component has an ~onAddTweetToCollection~ property, and our
~Application~ component passes its own ~addTweetToCollection()~ method as a
value for this property.  ~addTweetToCollection()~ adds a tweet to a
collection.  It's one of the custom methods that we define in our ~Application~
component, and we can refer to it using ~this~ keyword.

#+CINDEX:@code{CollectionTweets}
Let's take a look at what the ~addTweetToCollection()~ method does.

#+NAME:Application.addTweetToCollection
#+BEGIN_SRC js :eval no
addTweetToCollection: function (tweet) {
    var collectionTweets = this.state.collectionTweets;
    collectionTweets[tweet.id] = tweet;
    this.setState({
        collectionTweets: collectionTweets
    });
},
#+END_SRC

This method references ~CollectionTweets~ that are stored in the current state,
adds a new tweet to a ~collectionTweets~ object, and updates the state by
calling the ~setState()~ method.  A new tweet is passed as an argument when the
~addTweetToCollection()~ method is called inside a ~Stream~ component.  This is
an example of how a child component can update its parent component's state.

This is an important mechanism in React and it works as follows:

1. A parent component passes a callback function as a property to its child
   component.  A child component can access this callback function via the
   ~this.props~ variable.

2. Whenever a child component wants to update the parent component's state, it
   calls that callback function and passes all the necessary data to a new
   parent component's state.

3. A parent component updates its state, and as you already know, this state
   updates and triggers the ~render()~ function that re-renders all the child
   components as necessary.


This is how a child component interacts with a parent component.  This
interaction allows a child component to delegate the application's state
management to its parent component, and it is only concerned with how to render
itself.  Now, when you've learned this pattern, you will be using it again and
again because most of your React components should stay stateless.  This best
practice allows us to logically group React components by the two different
concerns they address:

- Manage the application's state and render

- Only render and delegate the application's state management to a parent
  component

**** The Collection Component

#+CINDEX:@code{Collection} component
Our ~Application~ component has a second child component, ~Collection~.

#+NAME:Collection with props
#+BEGIN_SRC js :eval no
<Collection
    tweets={this.state.collectionTweets}
    onRemoveTweetFromCollection={this.removeTweetFromCollection}
    onRemoveAllTweetsFromCollection={this.removeAllTweetsFromCollection}
/>
#+END_SRC

This component has a number of properties:

  #+CINDEX:@code{tweets}
- ~tweets~ : This refers to our current collection of tweets

  #+CINDEX:@code{onRemoveTweetFromCollection}
- ~onRemoveTweetFromCollection~ : <<removeTweet>>This refers to a function that
  removes a particular tweet from our collection

  #+CINDEX:@code{onRemoveAllTweetsFromCollection}
- ~onRemoveAllTweetsFromCollection~ : <<removeAllTweets>>This refers to a
  function that removes all the tweets from our collection


You can see that the ~Collection~ component's properties are only concerned
about how to:

- Access the application's state
- Mutate the application's state


The ~onRemoveTweetFromCollection~ and ~onRemoveAllTweetsFromCollection~
functions allow the ~Collection~ component to mutate the ~Application~
component's state.  On the other hand, the ~tweets~ property propogates the
~Application~ component's state to the ~Collection~ component so that it can
gain a read-only access to the state.

*** Data Flow

#+CINDEX:data flow
Can you recognize the single direction of data flow between the ~Application~
and ~Collection~ components?  Here's how it works:

1. The ~collectionTweets~ data is initialized in the ~Application~ component's
   ~getInitialState()~ method

   #+NAME:Application.getInitialState
   #+BEGIN_SRC js :eval no
   getInitialState: function () {
       return {
           collectionTweets: {}
       }
   },
   #+END_SRC

2. The ~collectionTweets~ data is passed to the ~Collection~ component as the
   ~tweets~ property.

3. The ~Collection~ component calls the ~removeTweetFromCollection~ and
   ~removeAllTweetsFromCollection~ functions that update the ~collectionTweets~
   data in the ~Application~ component, and the cycle starts again.


Notice that the ~Collection~ component cannott directly mutate the
~Application~ component's state.  The ~Collection~ component has read-only
access to that state via ~this.props~ object, and the only way to update the
parent component's state is to call the callback functions that are passed by
the parent component.  In the ~Collection~ component, these callback functions
are ~this.props.onRemoveTweetFromCollection~ and
~this.props.onRemoveAllTweetsFromCollection~.

This simple mental model of how data flows in our React component hierarchy
will help us increase the number of components we use, without increasing the
complexity of how our user interface works.  For example, it can have 10 levels
of nested React components, as follows:

#+BEGIN_EXAMPLE
Component A -->
  Component B -->
    Component C -->
      Component D -->
        Component E -->
          Component F -->
            Component G
#+END_EXAMPLE

If ~Component G~ wants to mutate the state of root ~Component A~, it would do
it in the exact same way that ~Component B~, or ~Component F~, or any other
component in this hierarchy would.  However, in React, you shouldn't pass data
from ~Component A~ directly to ~Component G~.  Instead, you should pass it to
~Component B~, then to ~Component C~, then to ~Component D~, and so on until
you finally reach ~Component G~.  ~Component B~ to ~Component F~ will have to
carry some ``transit'' properties that are actually meant for ~Component G~.
This might look like a waste of time, but this design makes it easy for us to
debug our application and be able to reason out how it works.  There are always
stragegies to optimize your application's architecture.  One of them is to use
*Flux*, which we'll discuss later in this book.

*** Mutating Data

#+CINDEX:mutate data
Before we finish discussing our Application component, let's take a look at the
two methods that mutate its state:

- ~removeTweetFromCollection()~
- ~removeAllTweetsFromCollection()~


#+CINDEX:@code{removeTweetFromCollection} method
#+NAME:Application.removeTweetFromCollection
#+BEGIN_SRC js :eval no
removeTweetFromCollection: function (tweet) {
    var collectionTweets = this.state.collectionTweets;
    delete collectionTweets[tweet.id];
    this.setState({
        collectionTweets: collectionTweets
    });
},
#+END_SRC

The ~removeTweetFromCollection()~ method removes a tweet from a collection of
tweets that we store in the ~Application~ component's state.  It takes the
current ~collectionTweets~ object from the component's state, deletes a tweet
with a given ID from that objectm and updates the component's state with an
updated ~collectionTweets~ object.

On the other hand, the second method removes all the tweets from the
component's state.

#+NAME:Application.removeAllTweetsFromCollection
#+BEGIN_SRC js :eval no
removeAllTweetsFromCollection: function () {
    this.setState ({
        collectionTweets: {}
    });
},
#+END_SRC

Both of these methods are called from a child's ~Collection~ component because
that component has no other way to mutate the ~Application~ component's state.

** Summary

In this chapter we learned how to solve a problem with React.  We started by
breaking down the problem into smaller individual problems and then discussed
how we can address them using React.  Then, we created a list of React
components that we needed to implement.  Finally, we created our first
composable React component and learned how a parent component interacts with
its child components.

In the next chapter, we'll implement our child components and learn about
React's lifecycle methods.

* Use Your React Components With Another Library

#+CINDEX:integrate 3rd party library
#+CINDEX:receive data, 3rd part library
React is a great library for building user interfaces.  What if we want to
integrate it with another library that is responsible for receiving data?  In
the previous chapter, we outlined five tasks that our Snapterest web
application should be able to perform.  We decided that four of them were
related to the user interface, but one of them was all about receiving data;
receive tweets from the Snapkite Engine server in real time.

In this chapter we'll learn how to integrate React with the external JavaScript
library and what React component lifecycle methods are, all while solving the
very important task of receiving data.

** Using Another Library in Your React Component

#+CINDEX:Snapkite Engine library
#+CINDEX:Twitter Streaming API
#+CINDEX:stream of tweets
Our Snapterest web application will consume a live stream of tweets.  In
Chapter 1, you installed the *Snapkite Engine* library that connects to the
Twitter Streaming API, filters the incoming tweets, and sends them to our
client application.  In turn, our client application needs a way of connecting
to that live stream and listening for the new tweets.

#+CINDEX:@code{snapkite-stream-client} module
We don't need to implement this functionality outselves because we can reuse
another Snapkite module called ~snapkite-stream-client~.  Let's install this
module.

*** Installing ~snapkite-stream-client~ Module

#+CINDEX:@code{snapkite-stream-client} module, install
Navigate to the ~<dir>/snapterest/~ directory and run the following command:

: npm install --save snapkite-stream-client

It will install the ~snapkite-stream-client~ module, and add it to
~package.json~ as a dependency.

#+NAME:snapkite-stream-client
#+CAPTION[snapkite-stream-client]:After Installing the ~snapkite-stream-client~ Module
#+BEGIN_src sh :dir snapterest :results output :exports both
yarn add snapkite-stream-client
cat package.json
#+END_SRC

Now we're ready to reuse the ~snapkite-stream-client~ module in one of our
React components.

*** Creating the ~Stream~ Component with the ~snapkite-stream-client~ Module
:PROPERTIES:
:CUSTOM_ID: Stream Component
:END:

#+CINDEX:@code{Stream} component
In the previous chapter, we created the ~Application~ component with two child
components: ~Stream~ and ~Collection~.  In this chapter, we'll create our
~Stream~ component.

Start by creating the ~<dir>/snapterest/source/components/Stream.react.js~
file:

#+CINDEX:@file{Stream.react.js} file
#+CAPTION[<Stream Component>]:The ~Stream~ Component (~Stream.react.js~)
#+NAME:Stream component
#+HEADER: :noweb yes :eval no
#+BEGIN_SRC js :tangle snapterest/source/components/Stream.react.js :mkdirp yes
<<Stream React dependencies>>
var SnapkiteStreamClient = require('snapkite-stream-client');

var Stream = React.createClass({

    <<Stream.getInitialState method>>

    <<Stream.componentDidMount method>>

    <<Stream.componentWillUnmount method>>

    <<Stream.handleNewTweet method>>

    <<Stream.render method>>
});

module.exports = Stream;
#+END_SRC

#+CINDEX:@file{StreamTweet} module
#+CINDEX:@file{Header} module
#+CINDEX:@file{snapkite-stream-client} module
We first import the modules that our ~Stream~ component depends on:

#+NAME:Stream React dependencies
#+BEGIN_SRC js :eval no
var React = require('react');
var Header = require('./Header.react');
var StreamTweet = require('./StreamTweet.react');
#+END_SRC

- ~React~: React library
- ~StreamTweet~ and ~Header~: React components
- ~snapkite-stream-client~: a utility library


#+CINDEX:@code{getInitialState()}
#+CINDEX:@code{componentDidMount()}
#+CINDEX:@code{componentWillUnmount()}
#+CINDEX:@code{handleNewTweet()}
#+CINDEX:@code{render()}
Then we define our React component.  Here are the methods that our ~Stream~
componppppent implements:

- ~getInitialState()~
- ~componentDidMount()~
- ~componentWillUnmount()~
- ~handleNewTweet()~
- ~render()~

**** ~Stream~'s ~render()~ Method

#+CINDEX:@code{render()} method, in @file{Stream}
We are already familiar with the ~getInitialState()~ and ~render()~ mnethods;
they are part of React's API.  You already know that any React component must
implement at least the ~render()~ method.  Let's take a look at the ~render()~
method of our ~Stream~ component.

#+CAPTION:The ~render()~ Method of the ~Stream~ Component
#+NAME:Stream.render method
#+BEGIN_SRC js :eval no
render: function () {
    var tweet = this.state.tweet;

    if (tweet) {
        return (
            <StreamTweet
             tweet={tweet}
             onAddTweetToCollection={this.props.onAddTweetToCollection}
            />
        );
    }

    return ( <Header text="Waiting for public photos from Twitter..." /> );
}
#+END_SRC

We created a new ~tweet~ variable that references the ~tweet~ property, which
is party of the component's state object.  We then check whether that variable
has a reference to an actual ~tweet~ object, and if it does, our ~render()~
method returns the ~StreamTweet~ component, or else, it returns the ~Header~
component.

The ~StreamTweet~ component renders a header and the latest tweet from a
stream, whereas the ~Header~ component renders only a header.

Have you noticed that our Stream component doesn't render anything itself, but
rather returns one of the two other components that do the actual rendering?
The purpose of the ~Stream~ component is to encapsulate our application's logic
and delegate rendering to the other React components.  In React, you should
have at least one component that encapsulates your application's logic, stores,
and manages your application's state.  This is usually a root component or one
of the high-level components in your component hierarchy.  All the other child
React components should have no state if possible.  If you think of all the
React components as ~Views~, then our ~Stream~ component is a ~ControllerView~.

**** ~Stream~'s Other Methods

Now that we know what a ~Stream~ component renders, let's discuss it in the
other methods:

#+CINDEX:@code{getInitialState()} in @file{Stream} component
{{{subheading(The ~Stream.getInitialState()~ Method)}}}

#+CAPTION:The ~getInitialState()~ Method of the ~Stream~ Component
#+NAME:Stream.getInitialState method
#+BEGIN_SRC js :eval no
getInitialState: function () {
    return { tweet: null }
},
#+END_SRC

The ~getInitialState()~ method returns the initial state object with a ~tweet~
property, which is set to =null=.  Our ~Stream~ component will receive an
endless stream of new tweets, and it needs to re-render its child components
every time a new tweet is received.  In order to achieve this, we need to store
the current tweet in the component's state.  Once we update its state, React
will call its ~render()~ method and re-render all of its child components.  For
this purpose, we will implement the ~handleNewTweet()~ method.

{{{subheading(The ~Stream.handleNewTweet() Method)}}}
#+CINDEX:@code{handleNewTweet()} in @file{Stream} component

#+CAPTION:The ~StreamhandleNewTweet()~ Method
#+NAME:Stream.handleNewTweet method
#+BEGIN_SRC js :eval no
handleNewTweet: function (tweet) {
    this.setState({ tweet: tweet });
},
#+END_SRC

The ~handleNewTweet()~ method takes a ~tweet~ object, and sets it as a new
value for the component state's ~tweet~ property.

{{{subheading(The ~Stream.componentDidMount()~ Method)}}}
#+CINDEX:@code{componentDidMount()} in @file{Stream} component

Where does the new tweet come from and when does it come?  Let's take a look at
our ~componentDidMount()~ method.

<<SnapkiteStreamClient.initializeStream>>
#+CAPTION:The ~Stream.componentDidMount()~ Method
#+NAME:Stream.componentDidMount method
#+BEGIN_SRC js :eval no
componentDidMount: function () {
    SnapkiteStreamClient.initializeStream(this.handleNewTweet);
},
#+END_SRC

#+CINDEX:@code{initializeStream()} method in @file{Stream} component
#+CINDEX:@file{SnapkiteStreamClient} object in @file{Stream} component
#+CINDEX:@code{handleNewTweet} callback
This function calls the ~initialzeStream()~ method of the
~SnapkiteStreamClient~ object, and passes a ~this.handleNewTweet~ callback
function as its argument.  ~SnapkiteStreamClient~ is an external library with
an API that we're using to initialize a stream of tweets.  The
~this.handlNewTweet~ function will be called for every tweet that
~SnapkiteStreamClient~ receives.

Why did we name this method ~componentDidMount()~?  We didn't.  React did.  In
fact, the ~componentDidMount()~ method is part of React's API.  It's one of the
React component's lifecycle methods.  It's called only once, immediately after
React has finished the initial rendering of our component.  At this point,
React has created a DOM tree, which is represented by our component, and now we
can access that DOM with another JavaScript library.

~componentDidMount()~ is a perfect place for integrating React with another
JavaScript library.  This is where we connect to a stream of tweets using the
external ~SnapkiteStreamClient~ library.

**** Cleaning Up

#+CINDEX:uninitialize
#+CINDEX:@code{componentWillUnmount()} method
#+CINDEX:component, unmount
#+CINDEX:unmount component

#+CAPTION:The ~Stream.componentWillUnmount()~ Method
#+NAME:Stream.componentWillUnmount method
#+BEGIN_SRC js :eval no
componentWillUnmount: function () {
    SnapkiteStreamClient.destroyStream();
},
#+END_SRC

Now we know when to initialize the external JavaScript libraries in our React
components, but what about the reverse process---when should we uninitialize
and clean up everything that we've done in the ~componentDidMount()~ method?
It's a good idea to clean up everything before we unmount our components.  For
this purpose, React API offers us another component lifecycle
method---~componentWillUnmount()~.

#+CINDEX:@code{destroyStream()} method
#+CINDEX:@file{Stream} component, unmount
The ~componentWillUnmount()~ method is called by React just before React
unmounts the component.  As you can see in the ~componentWillUnmount()~ method,
you're calling the ~destroyStream()~ method in the ~SnapkiteStreamClient~
object.  ~destroyStream()~ cleans up our connection to ~SnapkiteStreamClient~,
and we can safekly unmount our ~Stream~ component.

** Understanding React Component's Lifecycle Methods

#+CINDEX:lifecycles of React components
Think about what a React component does.  It describes what to render.  We know
that it uses the ~render()~ method for this.  However, sometimes, having only
the ~render()~ method is not enough because what if we want to do something
before or after the component has rendered?  What if we want to be able to
decide whether a component's ~render()~ method should be called at all?

#+CINDEX:component lifecycles, methods
Looks like what we're describing is a process during which the React component
is rendered.  This process has various stages, for example, before render,
render, after render, and so on.  In React, this process is called the
{{{dfn(component's lifecycle)}}}.  Each React component goes through this
process.  What we want is a way to hook into that process,and call our own
functions at different stages of that process in order to have a greater
control over it.  For this purpose, React provides a number of methods that we
cna use to get notified when a certain stage in a component's lifecycle process
occurs.  These methods are called the {{{dfn(component's lifecycle
methods)}}}.  They are called in a predictable order.

All the React component's lifecycle methods can be grouped into three phases:

#+CINDEX:mounting phase
#+CINDEX:updating phase
#+CINDEX:unmounting phase
#+CINDEX:lifecycle phases
#+CINDEX:phases, React component's lifecycle methods
#+ATTR_TEXINFO: :indic b
- Mounting ::

              This phase occurs when a component is being inserted into the DOM

- Updating ::

              This phase occurs when a component is being re-rendered into a
              virtual DOM to figure out if the actual DOM needs to be updated

- Unmounting ::

                This phase occurs when a component is being removed from the
                DOM


#+CINDEX:mounting a component
#+CINDEX:unmounting a component
In React's terminology, inserting a component into the DOM is called
{{{dfn(mounting)}}}, whereas removing a component from the DOM is called
{{{dfn(unnounting)}}}.

*** Creating the ~StreamTweet~ Component

The best way to learn about the React component's lifecycle methods is to see
them in action.  Let's create our ~StreamTweet~ component that we discussed
earlier in this chapter.  This component will implement most of React's
lifecycle methods.

Navigate to ~<dir>/snapterest/source/components/~ and create the
~StreamTweet.react.js~ file:

<<StreamTweet component>>
#+CAPTION[<StreamTweet Component>]:The ~StreamTweet~ Component (~StreamTweet.react.js~)
#+NAME:StreamTweet component
#+HEADER: :noweb no-export
#+HEADER: :comments both
#+HEADER: :tangle snapterest/source/components/StreamTweet.react.js :mkdirp yes
#+BEGIN_SRC js :eval no
<<StreamTweet imports>>

var StreamTweet = React.createClass({
    // define other component lifecycle methods here

    <<getInitialState>>
    <<componentWillMount>>
    <<componentDidMount>>
    <<componentWillReceiveProps>>
    <<shouldComponentUpdate>>
    <<componentWillUpdate>>
    <<componentDidUpdate>>
    <<componentWillUnmount>>

    render: function () {
        console.log('[Snapterest] StreamTweet: Running render()');

        return (
            <section>
                <Header text={this.state.headerText} />
                <<StreamTweet.render Tweet>>
            </section>
        );
    }
});

module.exports = StreamTweet;
#+END_SRC

{{{heading(The ~StreamTweet~'s Imports)}}}

#+NAME:StreamTweet imports
#+BEGIN_SRC js :eval no
var React = require('react');
var ReactDOM = require('react-dom');
var Header = require('./Header.react');
var Tweet = require('./Tweet.react');
#+END_SRC

{{{heading(The ~StreamTweet.render()~ of the ~Tweet~ component)}}}

The details of this rendered ~Tweet~ component will be [[StreamTweet.render Tweet for Flux][refactored for Flux]].

#+NAME:StreamTweet.render Tweet
#+BEGIN_SRC js :eval no
<Tweet
   tweet={this.props.tweet}
   onImageClick={this.props.onAddTweetToCollection}
/>
#+END_SRC

*** Discussing the Component Lifecycle Methods

The ~StreamTweet~ component has no lifecycle methods yet, other than
~render()~.  We'll create and discuss them one by one as we move ahead.

#+CINDEX:mounting phase, methods called during
The four methods are called during a component's /mounting/ phase, as shown in
the following:

#+CINDEX:@code{getInitialState()}
#+CINDEX:@code{componentWillMount()}
#+CINDEX:@code{render()}
#+CINDEX:@code{componentDidMount()}
#+BEGIN_EXAMPLE
getInitialState()
|
V
componentWillMount()
|
V
render()
|
V
componentDidMount()
#+END_EXAMPLE

In this chapter, we'll discuss three of these four methods (except
~render()~).  They are called once when the component is inserted into the
DOM.  Let's take a closer look at each of them.

*** Mounting Methods

#+CINDEX:mounting methods of a component
Now let's check out some of the useful mounting methods.

**** The ~getInitialState()~ Method

#+CINDEX:@code{getInitialState()} mounting method
The ~getInitialState()~ method is invoked first.  It is invoked /before/ React
inserts a component into the DOM.  If you want your component to have a state,
then use this method to return the initial component's state.  In your
~StreamTweet~ component, add the following code:

#+CAPTION:StreamTweet's ~getInitialState()~ Method
#+NAME:getInitialState
#+BEGIN_SRC js :eval no
// getInitialState() method
getInitialState: function () {
    console.log('[Snapterest] StreamTweet: 1. Running getInitialState()');

    return ({
        numberOfCharactersIsIncreasing: null,
        headerText: null
    });
},
#+END_SRC

In our ~StreamTweet~ component's ~getInitialState()~ method, we will perform
the following steps:

1. Log the following message in a web browser's console:
   : [Snapterest] StreamTweet: 1. Running getInitialState().

   #+CINDEX:@code{numberOfCharactersIsIncrease()} property
   #+CINDEX:@code{headerText()} property
2. Return an object with the ~numberOfCharactersIsIncreasing~ and ~headerText~
   properties set to =null=.

   - ~numberOfCharactersIsIncreasing~ will keep track of whether a tweet that
     will be displayed next has more characters in its text than a currently
     displayed tweet.  We'll set it to a Boolean value in our next component
     lifecycle method.

   - The ~headerText~ will store the text for the ~Header~ component that
     ~StreamTweet~ renders.


As with all the mounting methods, ~getInitialState()~ will be called only once.

**** The ~componentWillMount()~ Method

#+CINDEX:@code{componentWillMount()} mounting method
The ~componentWillMount()~ method is invoked second.  It is invoked
/immediately before/ React inserts a component into the DOM.  Add this code
right after the ~getInitialState()~ method in your ~StreamTweet~ component.

#+CAPTION:StreamTweet's ~componentWillMount()~ Method
#+NAME:componentWillMount
#+BEGIN_SRC js :eval no
// componentWillMount method
componentWillMount: function () {
    console.log('[Snapterest] StreamTweet: 2. Running componentWillMount()');

    this.setState({
        numberOfCharactersIsIncreasing: true,
        headerText: 'Latest public photo from Twitter'
    });

    window.snapterest = {
        numberOfReceivedTweets: 1,
        numberOfDisplayedTweets: 1
    };
},

#+END_SRC

We do a number of things in this method.  First, we log the fact that this
method is being invoked.  In fact, for the purpose of demonstration, we'll log
every component lifecycle method of this component.  When you run this code in
a web browser, you should be able to open the JavaScript console and see these
log messages printed in the expected ascending order.

Next, we update the component's state using the ~this.setState()~ method:

  #+CINDEX:@code{numberOfCharactersIsIncreasing} property, set
  #+CINDEX:@code{headerText} property, set
- Set the ~numberOfCharactersIsIncreasing~ property to =true=
- Set the ~headerText~ property to 'Latest public photo from Twitter'


Because this is the very first tweet that this component will render, we know
that the number of characters is definitely increasing from nothing to the
number of characters in that first tweet.  Hence, we set it to =true=.  We also
assign the default text to our header.


#+CINDEX:@code{setState()} method
As you know, calling the ~this.setState()~ method should trigger the
component's ~render()~ method, so it seems like ~render()~ will be called twice
during the component's mounting phase.  However, in this case, React knows that
nothing has been rendered yet, so it will call the ~render()~ method only once.

#+CINDEX:@code{snapterest} global object
#+CINDEX:global object, @code{snapterest}
#+CINDEX:@code{window.snapterest} global object
Finally, in this method, we define a ~snapterest~ global object with the
following two properties:

   #+CINDEX:@code{numberOfReceivedTweets} global property
1. ~numberofReceivedTweets~: This property counts the number of all the
   received tweets

   #+CINDEX:@code{numberOfDisplayedTweets} global property
2. ~numberOfDisplayedTweets~: This property counts the number of only the
   displayed tweets


#+CINDEX:@code{numberOfReceivedTweets}, set
#+CINDEX:@code{numberOfDisplayedTweets}, set
We set ~numberOfReceivedTweets~ to 1 because we know that the
~componentWillMount()~ method is called only once when the very first tweet is
receivedf.  We also know taht our ~render()~ method will be called for this
very first tweet, so we set ~numberOfDisplayedTweets~ to 1 as well.


#+CINDEX:global object
#+CINDEX:@code{window.snapterest} global object
This global object is not part of React or our web application's logic; we can
remove it and everything will still work as expected.  ~window.snpaterest~ is a
convenience tool used to keep track of how many tweets we've processed at any
point in time.  We use the global ~window.snapterest~ object for demonstration
purposes only.  I would strongly advise you against adding your own properties
to a global object in real life projects because you might overwrite the
exsiting properties and/or your properties might be overwritten later by some
other JavaScript code that you don't own.  Later on, if you decide to deploy
Snapterest in production, then make sure to remove the global
~window.snapterest~ object and the related code from the ~StreamTweet~
component.

After running Snapterest in a web browser for a few minutes, you can open the
JavaScripty console and type the ~snapterest.numberOfReceivedTweets~ and
~snapterest.numberOfDisplayedTweets~ commands.  These commands will output the
numbers that will help you get a better understanding of how fast the new
tweets are comming in, and how many of them are not being displayed.  In our
next component lifecycle method, we'll add more properties to our
~window.snapterest~ object.

**** The ~componentDidMount()~ Method

#+CINDEX:@code{componentDidMount()} mounting method
#+CINDEX:third party libraries, integrate
#+CINDEX:integrate third party libraries
The ~componentDidMount()~ method is invoked third.  It is invoked /immediately
after/ React inserts a component into the DOM.  The updated DOM is now
available for access, which means that this method is the best place for
initializing other JavaScript libraries that need access to that DOM.

Earlier in this chapter, we created our ~Stream~ component with the
~componentDidMount()~ method that initializes the external
~snapkite-stream-client~ JavaScript library.

Let's take a look at this component's ~componentDidMount()~ method.  Add the
following code to your ~StreamTweet~ component after the ~componentWillMount()~
method:

#+CAPTION: StreamTweet's ~componentDidMount()~ Method
#+NAME:componentDidMount
#+BEGIN_SRC js :eval no
// componentDidMount() method
componentDidMount: function () {
    console.log('[Snapterest] StreamTweet: 3. Running componentDidMount()');

    var componentDOMRepresentation = ReactDOM.findDOMNode(this);

    window.snapterest.headerHTML = componentDOMRepresentation.children[0].outerHTML;
    window.snapterest.tweetHTML = componentDOMRepresentation.children[1].outerHTML;
},

#+END_SRC

#+CINDEX:@code{ReactDOM.findDOMNode()} method
#+CINDEX:@code{findDOMNode()} method
#+CINDEX:@code{componentDOMRepresentation} variable
Here, we're referencing the DOM that represents our ~StreamTweet~ component
using the ~ReactDOM.findDOMNode()~ method.  We pass ~this~ parameter that
references the current component (in this case, ~StreamTweet~).  The
~componentDOMRepresentation~ variable references the DOM tree that we can
traverse and access its various properties.  To get a good understanding of what
this DOM tree looks like, let's take a closer look at the ~render()~ method of
four ~StreamTweet~ component.

#+CINDEX:JSX, benefit
One of the greatest benefits of using JSX is that we can easily identify how
many child elements our component will have just by looking at the component's
~render()~ method.  Here, we can see that a parent ~<section>~ element has two
child components: ~<Header />~ and ~<Tweet />~.

#+CINDEX:traverse the DOM
#+CINDEX:DOM traversal
#+CINDEX:@code{children} property of the DOM API
#+CINDEX:DOM API, @code{children}
So when we traverse the resulting DOM tree using the DOM API ~children~
property, we can be sure that it will have two child elements as well:

  #+CINDEX:@code{componentDOMRepresentation.children} array access
- ~componentDOMRepresentation.children[0]~: This is our ~<Header />~ component's
  DOM representation

- ~componentDOMRepresentation.children[1]~: This is our ~<Tweet />~ component's
  DOM representation


#+CINDEX:@code{outerHTML} attribute
#+CINDEX:@code{window.snapterest} global object
The ~outerHTML~ attribute of each element gets the HTML string that represents
the DOM tree of each element.  We reference this HTML string in our global
~window.snapterest~ object for convenience.

#+CINDEX:integrate third party library
#+CINDEX:third party library, integrate
If you are using another JavaScript library such as *JQuery*, along with React,
then use the ~componentDidMount()~ method as an opportunity to integrate the
two.  If you want to send an AJAX request, or set timers using the
~setTimeout()~ or ~setInterval()~ functions, then you can do that in this
method as well.  In general, ~componentDidMount()~ should be your preferred
component lifecycle for integrating the React library with non-React libraries
and APIs.

**** Summary of Mounting Methods

So far, in this chapter, we've learned about the fundamental mounting methods
tht the React component provides us with.  We used all the three of them in our
~StreamTweet~ component.  We also discussed the ~StreamTweet~'s ~render()~
method.  This is all that we need to know to understand how React will render
the ~StreamTweet~ compoonent initially.  On its very first render, React will
execute the following sequence of methods:

1. ~getInitialState()~
2. ~componentWillMount()~
3. ~render()~
4. ~componentDidMount()~


This is called the React component's {{{dfn(mounting phase)}}}.  It is executed
onlyi once, unless we unmount a component and mount it again.

Next, let's discuss the React component's /unmounting phase/.

*** Unmounting Methods

#+CINDEX:unmounting method
Let's now take a look at one of the popular unmounting methods.

**** The ~componentWillUnmount()~ Method

#+CINDEX:@code{componentWillUnmount()} unmounting method
#+CINDEX:clean up component
React offers only one method for this phase, that is,
~componentWillUnmount()~.  It is invoked /immediately before/ React removes a
component from the DOM and destroys it.  This method is useful for cleaning up
any data that is created during the component's mounting or updating phases.
That's exactly what we do in our ~StreamTweet~ component.  Add this code to
your ~StreamTweet~ component after the ~compontDidMount()~ method:

#+CAPTION:StreamTweet's ~componentWillUnmount()~ Method
#+NAME:componentWillUnmount
#+BEGIN_SRC js :eval no
// componentWillUnmount() method
componentWillUnmount: function () {
    console.log('[Snapterest] StreamTweet: 8. Running componentWillUnmount()');

    delete window.snapterest;
},

#+END_SRC

#+CINDEX:@code{window.snapterest} global object, delete
#+CINDEX:delete @code{window.snapterest} global object
#+CINDEX:global object @code{window.snapterest}, delete
In the ~componentWillUnmount()~ method, we delete our global
~window.snapterest~ object using the {{{command(delete)}}} operator.

Removing ~window.snapterest~ will keep our global object clean.  If you've
created any additional DOM elements in the ~componentDidMount()~ method, then
the ~componentWillUnmount()~ method is a good place to remove them.  You can
think of the ~componentDidMount()~ and ~componentWillUnmount()~ methods as a
two-step mechanism for integrating the React component with another JavaScript
API:

1. Initialize it in the ~componentDidMount()~ method
2. Terminate it in the ~componentWillUnmount()~ method


This way your external JavaScript libraries that need to work with the DOM will
stay in sync with the DOM rendered by React.

That's all we need to know to efficiently unmount React components.

** Summary

In this chapter, we created our ~Stream~ component and learned how to integrate
a React component with the external JavaScript library.  We also learned about
the React component's lifecycle methods.  We also focused on and discussed the
mounting and unmounting methods in detail and started implementing the
~StreamTweet~ component.

In our next chapter, we'll take a look at the component lifecycle's updating
methods.  We'll also implement our ~Header~ and ~Tweet~ components, and learn
how to set the component's default properties.
* Update Your React Components

In the previous chapter we learned that a React component can go through three
phases:

1. Mounting

2. Updating

3. Unmounting


We've already discussed the mounting and unmounting phases.  In this chapter,
we're going to focus on the updating phase.  During this phase, a React
component is already inserted into the DOM.  This DOM represents a component's
current state, and when the state changes, React needs to evaluate how a new
state is going to mutate the previously rendered DOM.

React provides us with methods to influence what is going to be rendered during
an update as well as to make us aware of when an update happens.  These methods
allow us to control the transition from the current component's state to the
next component's state.  Let's learn more about the powerful nature of the
React component's updating methods.

** Understanding Component Lifecycle's Updating Methods

#+CINDEX:update phase of component
#+CINDEX:component's update phase
#+CINDEX:lifecycle methods of update phase
#+CINDEX:@code{componentWillReceiveProps()}
#+CINDEX:@code{shouldComponentUpdate()}
#+CINDEX:@code{componentWillUpdate()}
#+CINDEX:@code{render()}
#+CINDEX:@code{componentDidUpdate()}
A React component has *five lifecycle methods* that belong to a component's
/updating/ phase:

1. ~componentWillReceiveProps()~
2. ~shouldComponentUpdate()~
3. ~componentWillUpdate()~
4. ~render()~
5. ~componentDidUpdate()~


*** The ~componentWillReceiveProps()~ Method

We'll start with the ~componentWillReceiveProps()~ method in the ~StreamTweet~
component.  Add the following code after the ~componentDidMount()~ method in
~StreamTweet.react.js~ file:

#+CAPTION[componentWillReceiveProps]:The ~componentWillReceivePropse()~ Method in ~StreamTweet~ Component
#+NAME:componentWillReceiveProps
#+BEGIN_SRC js :eval no
// componentWillReceiveProps() Method
componentWillReceiveProps: function (nextProps) {
    console.log('[Snapterest] StreamTweet: 4. Running componentWillReceiveProps()');

    var currentTweetLength = this.props.tweet.text.length;
    var nextTweetLength = nextProps.tweet.text.length;
    var isNumberOfCharactersIncreasing = (nextTweetLength > currentTweetLength);
    var headerText;

    this.setState({
        numberOfCharactersIsIncreasing: isNumberOfCharactersIncreasing
    });

    if (isNumberOfCharactersIncreasing) {
        headerText = 'Number of characters is increasing';
    } else {
        headerText = 'Latest public photo from Twitter';
    }

    this.setState({
        headerText: headerText
    });

    window.snapterest.numberOfReceivedTweets++;
},

#+END_SRC

{{{heading(Explanation of ~componentWillReceiveProps()~)}}}

#+CINDEX:@code{componentWillReceiveProps()} update phase
This method is invoked first in the component's lifecycle's updating phase.  It
is called when a component receives new properties from its parent component.

{{{subheading(Using ~nextProps~ Object)}}}

#+CINDEX:@code{nextProps} object
This method is an opportunity for us to compare the current component's
properties using the ~this.props~ object with the next component's properties
using the ~nextProps~ object.  Based on this comparison, we can choose to
update the component's state using the ~this.setState()~ method, which will not
trigger an additional render in this scenario.

{{{subheading(Comparing the Lengths of the Tweets)}}}

We first get the lengths of the current tweet and the next tweet.  The current
one is available via ~this.props.tweet~ and the next one via
~nextProps.tweet~.  We then compare their lengths by checking whether the next
tweet is longer than the current one.  The result of the comparison is stored
in the ~isNumberOfCharactersIncreasing~ variable.  Finally, we update the
component's state by setting the ~numberOfCharactersIsIncreasing~ property to
the value of our ~isNumberOfCharactersIncreasing~ variable.

{{{subheading(Setting the ~headerText~ Property)}}}

We then set our header text.  If the next tweet is longer, we set the header
text to `Number of characters is increasing', or else we set it to `Latest
public photo from Twitter'.  We then update our component's state once more by
setting the ~headerText~ property to the value of our ~headerText~ variable.

{{{subheading(Batching State Updates)}}}

Notice that we call the ~this.setState()~ function twice in our
~componentWillReceiveProps()~ method.  This is to illustrate the point that no
matter how many times you call ~this.setState()~ in the
~componentWillReceiveProps()~ method, it won't trigger any additional renders
of that component.  React does an internal optimization where it batches the
state updates together.

{{{subheading(Counting Total Tweets Received)}}}

Since the ~componentWillReceiveProps()~ method will be called once for each new
tweet that our ~StreamTweet~ component will receive, it makes it a good place
to count the total number of received tweets.

Now we know how to check whether the next tweet is longer than the tweet we're
currently displaying, but how can we choose not to render the next tweet at
all?

*** The ~shouldComponentUpdate()~ Method

#+CINDEX:@code{shouldComponentUpdate()} updating method
The ~shouldComponentUpdate()~ method allows us to decide whether the next
component's state should trigger the component's re-rendering or not.  This
method returns a Boolena value, which by default is =true=, but you can return
=false=, and the following component methods will /not/ be called:

- ~componentWillUpdate()~
- ~render()~
- ~componentDidUpdate()~


Skipping a call to the component's ~render()~ method will prevent that
component from re-renderibng which in turn will improve your application's
performance, since no addiitional DOM mutations will be made.

This method is invoked second in the component lifecycle's updating phase.

This method is a great place for us to prevent the next tweet with one or less
characters from being displayed.  Add this code to the ~StreamTweet~ component
after the ~componentWillReceiveProps()~ method:

#+CAPTION:The ~shouldComponentUpdate()~ Method of ~StreamTweet~
#+NAME:shouldComponentUpdate
#+BEGIN_SRC js :eval no
// shouldComponentUpdate() method
shouldComponentUpdate: function (nextProps, nextState) {
    console.log('[Snapterest] StreamTweet: 5. Running shouldComponentUpdate()');

    return (nextProps.tweet.length > 1);
},

#+END_SRC

If the next tweet's length is greater than 1, then ~shouldComponentUpdate()~
returns =true=, and the ~StreamTweet~ component renders the next tweet.  Or
else, it returns =false=, and the ~StreamTweet~ component doesn't render the
next state.

*** The ~componentWillUpdate()~ Method

#+CINDEX:@code{componentWillUpdate()} method
The ~componentWillUpdate()~ method is called /immediately before/ React updates
the DOM.  It gets the following two arguments:

1. ~nextProps~: The next properties object
2. ~nextState~: The next state object


You can use these arguments to prepare for the DOM update.  However, you cannot
use ~this.setState()~ in the ~componentWillUpdate()~ method.  If you want to
update the component's state in response to its properties change, then do that
in the ~componentWillReceiveProps()~ method, which will be called by React when
the properties change.

To demonstrate when the ~componentWillUpdate()~ method is called, we need to
log it in the ~StreamTweet~ component.  Add this code after the
~shouldComponentUpdate()~ method:

#+CAPTION:The ~componentWillUpdate()~ Method of ~StreamTweet~
#+NAME:componentWillUpdate
#+BEGIN_SRC js :eval no
// componentWillUpdate Method
componentWillUpdate: function (nextProps, nextState) {
    console.log('[Snapterest] StreamTweet: 6. Running componentWillUpdate()');
},

#+END_SRC

*** The ~componentDidUpdate()~ Method

#+CINDEX:@code{componentDidUpdate()} method
The ~componentDidUpdate()~ method is called /immediately after/ React updates
the DOM.  It gets these two arguments:

- ~prevProps~: The previous properties object
- ~prevState~: The previous state object


#+CINDEX:post-render operations
We will use this method to interact with the updated DOM or perform any
post-render operations.  In our ~StreamTweet~ component, we'll use
~componentDidUpdate()~ to increment the number of displayed tweets in our
global object.  Add this code after the ~componentWillUpdate()~ method:

#+CAPTION:The ~componentDidUpdate()~ Method of ~StreamTweet~
#+NAME:componentDidUpdate
#+BEGIN_SRC js :eval no
// componentDidUpdate() method
componentDidUpdate: function (prevProps, prevState) {
    console.log('[Snapterest] StreamTweet: 7. Running componentDidUpdate()');

    window.snapterest.numberOfDisplayedTweets++;
},

#+END_SRC

#+CINDEX:@code{forceUpdate()} method
After ~componentDidUpdate()~ is called, the updating cycle ends.  A new cycle
is started when a component's state is updated or a parent component passes new
properties.  Or when you call the ~forceUpdate()~ method, it triggers a new
updating cycle, but skips the ~shouldComponentUpdate()~ method on a component
that triggered the update.  However, ~shouldComponentUpdate()~ is called on all
child components as per the usual updating phase.  Try to avoid using the
~forceUpdate()~ method as much as possible; this will promote your
application's maintainability.

That concludes our discussion of React component lifecycle methods.

** Setting Default React Component Properties

Our ~StreamTweet~ component renders two child components: ~Header~ and ~Tweet~.

Let's create these components.

*** Creating the ~Header~ Component

#+CINDEX:Header component, create
#+CINDEX:@file{Stream} Component
Navigate to ~<dir>/snapterest/source/components/~ and create the
~Header.react.js~ file:

#+CAPTION[<Header Component>]:The ~Header~ Component (~Header.react.js~)
#+NAME:Header component
#+HEADER: :mkdirp yes :eval no
#+BEGIN_SRC js -r :tangle snapterest/source/components/Header.react.js
var React = require('react');

var headerStyle = {
    fontSize: '16px',
    fontWeight: '300',
    display: 'inline-block',
    margin: '20px 10px'
};

var Header = React.createClass({

    getDefaultProps: function () {		(ref:getDefaultProps)
        return ({
            text: 'Default header'
        });
    },

    render: function () {
        return (
            <h2 style={headerStyle}>		(ref:style-prop)
                {this.props.text}
            </h2>
        );
    }
});

module.exports = Header;
#+END_SRC

#+CINDEX:@code{Header} component
#+CINDEX:stateless component, @code{Header}
The ~Header~ component is a stateless component that renders the ~h2~ element.
The hepader text is passed from a parent component as a ~this.props.text~
property, which makes this component flexible in that it allows us to reuse it
anywhere we need a header.  We'll reuse this component again later in this
book.

Notice that the ~h2~ element has a [[(style-prop)][=style= property]].

#+CINDEX:style property
#+CINDEX:inline styling
In React, we can define the CSS rules in a JavaScript object, and then pass
that object as a value to the React element's =style= property.  For example,
in this component, we define the [[(headerStyle)][~headerStyle~ variable]] that references an
object where:

- Each object key is a CSS property
- Each object value is a CSS value


#+CINDEX:inline styling, advantages
The advantages of defining your CSS rules inside a React component are as
follows:

#+ATTR_TEXINFO: :indic b
- Portability: ::

                 You can easily share a component together with its styling,
                 all in one JavaScript file;

- Encapsulation: ::

                   Making styles inline allows you to limit the scope they
                   affect

- Flexibility: ::

                 The CSS rules can be calculated using the power of JavaScript


#+CINDEX:Content Security Policies (CSP)
#+CINDEX:CSP
#+CINDEX:inline styling, disadvantage
The significant disadvantage of using this technique is the fact that
{{{dfn(Content Security Policies (CSP))}}} can block inline styling from having
any effect.  You can learn more about CSP at
https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP.

#+CINDEX:@code{getDefaultProps()} method
The ~Header~ component has one method that we haven't discussed yet, that is,
~getDefaultProps()~.  What if you forget to pass a property that a React
component depends on?  In that case, a component can set the default properties
using the ~getDefaultProps()~ method.

[[(getDefaultProps)][In this example]], we're setting a default value of =Default header= to our
=text= property.  If a parent component passes the ~this.props.text~ property,
then it will overwrite the default one.

*** Creating the ~Tweet~ Component

#+CINDEX:@file{Tweet} component
Next, let's create our ~Tweet~ component.  Navigate to
~<dir>snapterest/source/components/~ and create the ~Tweet.react.js~ file:

#+CAPTION[<Tweet Component>]:The ~Tweet~ Component (~Tweet.react.js~)
#+NAME:Tweet component
#+HEADER: :mkdirp yes :eval no
#+BEGIN_SRC js -r :tangle snapterest/source/components/Tweet.react.js
var React = require('react');

var tweetStyle = {
    position: 'relative',
    display: 'inline-block',
    width: '300px',
    height: '400px',
    margin: '10px'
};

var imageStyle = {
    maxHeight: '400px',
    boxShadow: '0px 1px 1px 0px #aaa',
    border: '1px solid #fff'
};

var Tweet = React.createClass({

    propTypes: {

        tweet: function (properties, propertyName, componentName) {
            var tweet = properties[propertyName];

            if (!tweet) {
                return new Error('Tweet must be set.');
            }

            if (!tweet.media) {
                return new Error('Tweet must have an image.');
            }
        },

        onImageClick: React.PropTypes.func		(ref:func-validator)
    },

    handleImageClick: function () {			(ref:click-handler)
        var tweet = this.props.tweet;
        var onImageClick = this.props.onImageClick;

        if (onImageClick) {
            onImageClick(tweet);
        }
    },

    render: function () {
        var tweet = this.props.tweet;
        var tweetMediaUrl = tweet.media[0].url;

        return (
            <div style={tweetStyle}>
                <img src={tweetMediaUIrl}
                 onClick={this.handleImageClick}
                 style={imageStyle}
                />
            </div>
        );
    }
});

module.exports = Tweet;
#+END_SRC

#+CINDEX:click event handler
This component renders a ~<div>~ element with a child ~<img>~ element.  Both
the elements have inline styles, and the ~<img>~ element has a click event
handler, that is, [[(click-handler)][~this.handleImageClick~]].

#+CINDEX:optional property
#+CINDEX:required property
When a user clicks on a tweet's image, the ~Tweet~ component checks whether a
parent component has passed a ~this.props.onImageClick~ callback function as a
property and calls that function.  ~this.props.onImageClick~ is an optional
~Tweet~ component's property, so we need to check whether it was passed before
we can use it.  On the other hand, ~tweet~ is a required property.

How can we ensure that a component receives all the required properties?

** Validating React Component Properties

#+CINDEX:=propTypes= object
#+CINDEX:validate component properties
#+CINDEX:properties, validate
In React, there is a way to validate the component properties using the
component's =propTypes= object:

#+CAPTION:The =PropTypes= Object
#+NAME:PropTypes-object
#+BEGIN_SRC js :eval no
propTypes: {
    propertyName: validator
}
#+END_SRC

#+CINDEX:validator function
#+CINDEX:@code{React.PropTypes} object
#+CINDEX:predefined validators
#+CINDEX:validators, predefined
In this object, you need to specify a property name and a validator function
that will determine whether a property is valid or not.  React provides some
predefined validators for you to reuse.  That are all available in the
=React.PropTypes= object:

- ~React.PropTypes.number~: ::  This will validate whether a property is a
     numberr or not

- ~React.PropTypes.string~: :: This will validate whether a property is a
     string or not

- ~React.PropTypes.bool~: :: This will validate whether a property is a Boolean
     or not

- ~React.PropTypes.object~: :: This will validate whether a property is an
     object or not

- ~React.PropTypes.element~: :: This will validate whether a property is a
     React element or not


For a complete list of the =React.PropTypes= validators, you can check the docs
at https://reactjs.org/docs/typechecking-with-proptypes.html.

By default, all the properties that you validate with the =React.PropTypes=
validators are optional.  You can chain any of them with ~isRequired~ to make
sure that a warning message is displayed on a JavaScript console when a
property is missing:

#+CAPTION:The =PropTypes= Object with ~isRequired~
#+NAME:PropTypes-object-isRequired
#+BEGIN_SRC js :eval no
propTypes: {
    propertyName: React.PropTypes.number.isRequired
}
#+END_SRC

#+CINDEX:custom validator function
#+CINDEX:validator function, custom
#+CINDEX:@code{Error} object
You can also specify your own custom validator function tht should return an
=Error= object if the validation fails:

#+CAPTION:A Custom =PropTypes= Object
#+NAME:PropTypes-object-custom
#+BEGIN_SRC js :eval no
propTypes: {
    propertyName: function (properties, propertyName, componentName) {
        // ... validation failed
        return new Error('A property is not valid.');
    }
}
#+END_SRC

#+CINDEX:custom validator function
Look at the [[(propTypes)][=propTypes= object]] in the ~Tweet~ component.  We're validating two
~Tweet~ component properties: ~tweet~ and ~onImageClick~.  We use the custom
validator function to validate the ~tweet~ property.  React passes three
parameters to this function:

1. ~properties~: This is the component properties object
2. ~propertyName~: This is the name of the property that we're validating
3. ~componentName~: This is the name of the Component


We first check whether our ~Tweet~ component received the [[(tweet-validator)][~tweet~ property]].
Then we assume that the ~tweet~ proeprty is an object, and we check whether
that object has no ~media~ property.  Both of these checks return an =Error=
object that will be logged in a JavaScript console.

Another ~Tweet~ component's property that we will validate is [[(func-validator)][~onImageClick~]].
We validate that the value of the ~onImageClick~ is a function.  In this case,
we reuse a validator function provided by the =React.PropTypes= object.
~onImageClick~ is an optional property because we didn't add ~isRequired~.

Finally, for performance reasons, =propTypes= is only checked in the
development version of React.

** Creating a Collection Component

[[two child components][Recall]] that our topmost hierarchy ~Application~ component has two child
components:
- ~Stream~
- ~Collection~


#+CINDEX:~Collection~ component
So far, we've discussed and implemented our ~Stream~ component and its child
components.  Next, we're going to focus on our ~Collection~ component.

<<Collection component>>Create the
~<dir>/snapterest/source/components/Collection.react.js~ file:

#+CAPTION[<Collection Component>]:The ~Collection~ Component (~Collection.react.js~)
#+NAME:Collection component
#+HEADER: :noweb yes :eval no
#+BEGIN_SRC js :tangle snapterest/source/components/Collection.react.js :mkdirp yes
<<Collection imports>>

var Collection = React.createClass({

    <<Collection.createHtmlMarkupStringOfTweetList>>

    <<Collection.getListOfTweetIds>>

    <<Collection.getNumberOfTweetsInCollection>>

    <<Collection.render>>
});

module.exports = Collection;
#+END_SRC

#+NAME:Collection imports
#+BEGIN_SRC js :eval no
var React = require('react');
var ReactDOMServer = require('react-dom/server');
var CollectionControls = require('./CollectionControls.react');
var TweetList = require('./TweetList.react');
var Header = require('./Header.react');
#+END_SRC

*** Collection Renders Tweets and Control Elements

#+CINDEX:@file{Collection} component
The ~Collection~ component is responsible for rendering two things:

1. Tweets that a user has collected

2. User interface control elements for manipulating that collection


{{{subheading(Collection's ~render()~ Method)}}}

#+CINDEX:@file{Collection} @code{render()} method
Take a look at the component's [[(Collection-render)][~render()~ method]].

#+NAME:Collection.render
#+BEGIN_SRC js :noweb yes :eval no
render: function () {
    var numberOfTweetsInCollection = this.getNumberOfTweetsInCollection();

    if (numberOfTweetsInCollection > 0) {

        <<Collection.render-variables>>

        <<Collection.render-when not empty>>
    }

    return (<Header text='Your Collection is empty' />);
}
#+END_SRC

#+CINDEX:@code{getNumberOfTweetsInCollection()} method
#+CINDEX:@code{getListOfTweetIds()} method
We first get a number of tweets in the collection using the
~this.getNumberOfTweetsInCollection()~ method.

#+NAME:Collection.getNumberOfTweetsInCollection
#+BEGIN_SRC js :eval no
getNumberOfTweetsInCollection: function () {
    return (this.getListOfTweetIds().length);
},
#+END_SRC


This method in turn uses another method to get a list of tweet IDs:

#+NAME:Collection.getListOfTweetIds
#+BEGIN_SRC js :eval no
getListOfTweetIds: function () {
    return (Object.keys(this.props.tweets));
},
#+END_SRC

The ~getListOfTweetIds()~ method call returns an array of tweet IDs, and then
~this.getNumberOfTweetsInCollection()~ returns the length of this array.

Once we know the number of tweets in our collection, we have to make a choice:

  #+CINDEX:@file{CollectionControls} component
  #+CINDEX:@file{TweetList} component
- If the collection is /not/ empty, then render the ~CollectionControls~ and
  ~TweetList~ components;

  #+CINDEX:@file{Header} component
- Otherwise, render the ~Header~ component;


What do all these components render?

  #+CINDEX:@file{CollectionControls} component @code{render()}
- The ~CollectionControls~ component renders a header with a collection name
  and a set of buttons that allow users to rename, empty, and export a
  collection;

  #+CINDEX:@file{TweetList} component @code{render()}
- The ~TweetList~ component renders a list of tweets;

  #+CINDEX:@file{Header} component @code{render()}
- The ~Header~ component simply renders a header with a message that the
  collection is empty;


The idea is to only show a collection when it is not empty.  In that case,
we're creating [[(four-variables)][four variables]]:

#+NAME:Collection.render-variables
#+BEGIN_SRC js :eval no
var tweets = this.props.tweets;
var htmlMarkup = this.createHtmlMarkupStringOfTweetsList();
var removeAllTweetsFromCollection = this.props.onRemoveAllTweetsFromCollection;
var handleRemoveTweetFromCollection = this.props.onRemoveTweetFromCollection;
#+END_SRC

  #+CINDEX:@code{tweets} variable
- the ~tweets~ variable references our ~tweets~ property that is passed from a
  parent component;

  #+CINDEX:@code{htmlMarkup} variable
- the ~htmlMarkup~ variable references a string that is returned by the
  component's ~this.createHtmlMarkupStringOfTweetList()~ method;

  #+CINDEX:@code{removeAllTweetsFromCollection} variable
  #+CINDEX:@code{handleRemoveTweetFromCollection} variable
- The ~removeAllTweetsFromCollection~ and ~handleRemoveTweetFromCollection~
  variables reference functions that are passed from a parent component;


*** HTML Markup  Flexible  JSX Syntax

{{{subheading(Creating HTML Markup)}}}

#+CINDEX:@code{createHtmlMarkupStringOfTweetList()} method
#+CINDEX:@code{ReactDOMServer.renderToStaticMarkup()} method
#+CINDEX:@code{renderToStaticMarkup()} method
#+CINDEX:@file{TweetList} component as argument
As the name suggests, the ~this.createHtmlMarkupStringOfTweetList()~ method
creates a string that represents the HTML markup created by rendering the
~TweetList~ component:

#+NAME:Collection.createHtmlMarkupStringOfTweetList
#+BEGIN_SRC js :noweb yes :eval no
createHtmlMarkupStringOfTweetList: function () {
    <<htmlString>>

    var htmlMarkup = {
        html: htmlString
    };

    return (JSON.stringify(htmlMarkup));
},
#+END_SRC

#+CINDEX:@code{renderToStaticMarkup} method
#+CINDEX:@code{ReactDOMServer} method, @code{renderToStaticMarkup}
This method uses the ~ReactDOMServer.renderToStaticMarkup()~ method that we
discussed in [[renderToStaticMarkup][Chapter 2]].  We pass the ~TweetList~ component as its argument.

#+NAME:htmlString
#+BEGIN_SRC js :eval no
var htmlString = ReactDOMServer.renderToStaticMarkup(
    <TweetList tweets={this.props.tweets} />
);
#+END_SRC

This ~TweetList~ component has a =tweets= property that references the =tweets=
property passed by a parent component.

#+CINDEX:@code{htmlString} variable
#+CINDEX:@code{htmlMarkup} object
#+CINDEX:@code{JSON.stringify()} function
#+CINDEX:@code{createHtmlMarkupStringOfTweetList()} method
The resuling HTML string produced by the
~ReactDOMServer.renderToStaticMarkup()~ method is stored in the ~htmlString~
variable.  Then, we create a new ~htmlMarkup~ object with the ~html~ property
that references our ~htmlString~ variable.  Finally, we use the
~JSON.stringify()~ function to convert our ~htmlMarkup~ JavaScript object to a
JSON string.  The result of the ~JSON.stringify(htmlMarkup)~ call is what our
~createHtmlMarkupStringOfTweetList()~ method returns.

{{{subheading(React Components are Flexible)}}}

This method demonstrates how flexible React components are; you can use the
same React components to render the DOM elements as well as produce a string of
HTML markup that can be passed to a third-party API.

{{{subheading(JSX Syntax can be used Anywhere)}}}

#+CINDEX:JSX syntax outside @code{render()} method
Another interesting observation that one can make is the use of JSX syntax
outside a ~render()~ method.  In fact, you can use JSX anywhere in your source
file, even outside the ~React.createClass()~ method.

*** What ~Collection~ Returns When Collection is not Empty

#+CINDEX:root element, only one
#+CINDEX:@file{CollectionControls} component
Take a closer look at what the ~Collection~ component returns when our
collection [[(Collection-notempty)][is /not/ empty]].

#+NAME:Collection.render-when not empty
#+BEGIN_SRC js :eval no
return (
    <div>
        <CollectionControls
            numberOfTweetsInCollection={numberOfTweetsInCollection}
    	htmlMarkup={htmlMarkup}
    	onRemoveAllTweetsFromCollection={removeAllTweetsFromCollection}
        />

        <TweetList
    	tweets={tweets}
    	onRemoveTweetFromCollection={handleRemoveTweetFromCollection}
        />
    </div>
);
#+END_SRC

We wrap the ~CollectionControls~ and ~TweetList~ components in the ~<div>~
element because React allows only one root element.  Let's take a look at each
component and discuss its properties.

We pass the following three properties to the ~CollectionsControls~ component:

   #+CINDEX:@code{numberOfTweetsInCollection} property
1. The =numberOfTweetsInCollection= property references the current number of
   tweets in our collection.

   #+CINDEX:@code{htmlMarkup} property
2. The =htmlMarkup= property references a string of HTML markup that we produce
   in this component using the ~createHtmlMarkupStringOfTweetList()~ method.

   #+CINDEX:@code{onRemoveAllTweetsFromCollection} property
3. The =onRemoveAllTweetsFromCollection= property references a function that
   removes all the tweets from our collection.  This function is implemented in
   the ~Application~ component as discussed in [[removeAllTweets][Chapter 4]].


#+CINDEX:@file{TweetList} component, arguments passed to
We pass these two properties to the ~TweetList~ component:

  #+CINDEX:@code{tweets} property
- The =tweets= property references tweets passed from a parent ~Application~
  component;

  #+CINDEX:@code{onRemoveTweetFromCollection} property
- The =onRemoveTweetFromCollection= property references a function that removes
  a tweet from a collection of tweets tht we store in the ~Application~
  component's state.  We've already discussed this function in [[removeTweet][Chapter 4]].

** Summary

In this chapter, we learned about a component's lifecycle updating methods.  We
also discussed how to validate the component properties and set the default
properties.  We also made good progress with our Snapterest application; we
created and discussed the ~Header~, ~Tweet~, and ~Collection~ components.

In the next chapter we'll focus on building more complex React components and
finish building our Snapterest application.

* Build Complex React Components

In this chapter we'll put everything we learned so far about React components
in action by building the most complex components in our application, that is,
child components of our ~Collection~ component.  Our aim in this chapter is to
gain a solid React experience and grow our React muscles.

** Creating the ~TweetList~ Component

#+CINDEX:@file{TweetList} component
The ~Collection~ component has two child components:

1. ~CollectionControls~
2. ~TweetList~


#+CINDEX:@file{TweetList} component
First build the ~TweetList~ component.  Create the following
~<dir>/snapterest/source/components/TweetList.react.js~ file:

<<TweetList component>>
#+CAPTION[<TweetList Component>]:The ~TweetList~ Component (~TweetList.react.js~)
#+NAME:TweetList component
#+HEADER: :noweb tangle :mkdirp yes :eval no
#+BEGIN_SRC js :tangle snapterest/source/components/TweetList.react.js
<<TweetList imports>>

<<TweetList styles>>

var TweetList = React.createClass({
    <<TweetList getListOfTweetIds method>>
    <<TweetList getTweetElement method>>
    <<TweetList render method>>
});

module.exports = TweetList;
#+END_SRC

#+NAME:TweetList imports
#+BEGIN_SRC js :eval no
var React = require('react');
var Tweet = require('./Tweet.react');
#+END_SRC

#+NAME:TweetList styles
#+BEGIN_SRC js :eval no
var listStyle = {
    padding: '0'
};

var listItemStyle = {
    display: 'inline-block',
    listStyle: 'none'
};
#+END_SRC

*** The ~render()~ Method

#+CINDEX:list of tweets
#+CINDEX:@code{Tweet} elements
#+CINDEX:@file{Tweet} component
#+CINDEX:@code{map} method
#+CINDEX:@code{getTweetElement()} method
The ~TweetList~ component renders a [[(list-of-tweets)][list of tweets]] using the ~render()~
function.

#+CAPTION:The ~TweetList~ ~render()~ Method
#+NAME:TweetList render method
#+BEGIN_SRC js :eval no
render: function () {
    var tweetElements = this.getListOfTweetIds().map(this.getTweetElement);

    return (
        <ul style={listStyle}>
            {tweetElements}
        </ul>
    );
}
#+END_SRC

First, we create a list of ~Tweet~ elements.

{{{subheading(The ~getListOfTweetIds~ Method)}}}

The ~this.getListOfTweetIds()~ method returns an array of tweet IDs.

#+CAPTION:The ~getListOfTweetIds~ Method of ~TweetList~
#+NAME:TweetList getListOfTweetIds method
#+BEGIN_SRC js :eval no
getListOfTweetIds: function () {
    return Object.keys(this.props.tweets);
},

#+END_SRC

Then, for each tweet ID in that array, we create a ~Tweet~ component.  For
this, we will call the ~map()~ method on our array of tweet IDs and pass the
~this.getTweetElement()~ method as a callback function.

{{{subheading(The ~getTweetElement~ Method)}}}

#+CAPTION:The ~getTweetElement~ Method of ~TweetList~
#+NAME:TweetList getTweetElement method
#+BEGIN_SRC js :noweb yes :eval no
<<TweetList getTweetElement method A>>
    <<variable handleRemoveTweetFromCollection>>
<<TweetList getTweetElement method B>>
#+END_SRC

#+NAME:TweetList getTweetElement method A
#+BEGIN_SRC js :exports none :eval no
getTweetElement: function (tweetId) {
    var tweet = this.props.tweets[tweetId];
#+END_SRC

#+NAME:variable handleRemoveTweetFromCollection
#+BEGIN_SRC js :exports none :eval no
var handleRemoveTweetFromCollection = this.props.onRemoveTweetFromCollection;
#+END_SRC

#+NAME:TweetList getTweetElement method B
#+BEGIN_SRC js :exports none :eval no
    var tweetElement;

    if (handleRemoveTweetFromCollection) {
        tweetElement = (
            <Tweet
                tweet={tweet}
                onImageClick={handleRemoveTweetFromCollection}
            />
        );
    } else {
        tweetElement = <Tweet tweet={tweet} />;
    }

    return (
        <li style={listItemStyle} key={tweet.id} >
            {tweetElement}
        </li>
    );
},

#+END_SRC

*** Handling the Optional ~onImageClick~ Property

#+CINDEX:@code{onImageClick} property
The ~getTweetElement()~ method returns a ~Tweet~ element [[(tweet-in-li)][wrapped]] in the ~<li>~
element.  The ~Tweet~ component has an optional ~onImageClick~ property.  When
do we want to provide this optional property and when don't we?

There are two scenarios.

- In the [[(scenario1)][first scenario]], the user will click on a tweet image to remove it from
  a collection of tweets.  In this scenario, our Tweet component will react to
  a ~click~ even, so we need to provide the ~onImageClick~ property.

- In the [[(scenario2)][second scenario]], the use will export a static collecton of tweets that
  has no user interaction.  In this scenario, we don't need to provide the
  ~onImageClick~ property.


#+CINDEX:@code{getTweetElement()} method
#+CINDEX:@code{tweet} variable
#+CINDEX:@code{tweetId} argument
#+CINDEX:@code{onRemoveTweetFromCollection} property
That's exactly what we do in our ~getTweetElement()~ method.  We create a
~tweet~ variable that stores a tweet with an ID that is provided by the
~tweetId~ argument.  Then, we create a variable that stores a
~this.props.onRemoveTweetFromCollection~ property that is passed by a parent
~Collection~ component.

#+CINDEX:@code{onImageClick} property
Next we check whether the ~this.props.onRemoveTweetFromCollection~ property is
provided by a ~Collection~ component.  If it is, then we create a ~Tweet~
component with an ~onImageClick~ property.  If it isn't provided, then we
create a ~Tweet~ component without a ~handleImageClick~ property.

*** Using the ~TweetList~ Component

#+CINDEX:@code{TweetList} component
We use the ~TweetList~ component in the following two cases:

  #+CINDEX:@code{onRemoveTweetFromCollection} property
- This component is used when rendering a collection of tweets in the
  ~Collection~ component.  In this case, the ~onRemoveTweetFromCollection~
  property /is/ provided.

- This component is used when rendering a string of HTML markup that represents
  a collection of tweets in the ~Collection~ component.  In this case, the
  ~onRemoveTweetFromCollection~ property /is not/ provided.


#+CINDEX:@code{tweetElement} variable
Once we create our ~Tweet~ element, and put it into the ~tweetElement~
variable, we return the ~<li>~ element with an inline style.

#+CINDEX:@code{key} property
#+CINDEX:dynamic children
Besides the =style= property, our ~<li>~ element has a =key= property.  It is
used by React to identify each child element that is created dynamically.  I
recommend that you read more about dynamic children at
https://react.tips/how-to-create-components-dynamically-in-react-16/.

#+CINDEX:@code{getTweetElement()} method
That's how the ~getTweetElement()~ method works.  As a result, the ~TweetList~
component returns an unordered list of ~Tweet~ elements.

** Creating the ~CollectionControls~ Component

#+CINDEX:child components of @file{Collection} componenet
Now, when we understand what the ~Collection~ component renders, let's discuss
its child components.  We'll start with ~CollectionControls~.  Create the
following ~<dir>/snapterest/source/components/CollectionControls.react.js~
file:

<<CollectionControls component>>
#+CAPTION[<CollectionControls Component>]:The ~CollectionControls~ Component (~CollectionControls.react.js~)
#+NAME:CollectionControls component
#+HEADER: :noweb tangle :mkdirp yes :eval no
#+BEGIN_SRC js :tangle snapterest/source/components/CollectionControls.react.js
<<CollectionControls imports>>

var CollectionControls = React.createClass({
    <<CollectionControls getInitialState method>>
    <<CollectionControls getHeaderText method>>
    <<CollectionControls toggleEditCollectionName method>>
    <<CollectionControls setCollectionName method>>
    <<CollectionControls render method>>
});

module.exports = CollectionControls;
#+END_SRC

#+CINDEX:@file{CollectionsControls} Component
#+CINDEX:user interface
#+CINDEX:collection, control
The ~CollectionsControls~ Component renders a user interface to control a
collection.  These controls allow the use to:

- Rename a collection
- Empty a collection
- Export a collection


A collection has a name.  By default this name is =new= and users can change
it.  A collection name is displayed in a header that is rendered by the
~CollectionControls~ component.  This component is a perfect candidate for
storing the collection's name, and since changing a name will require a
component re-render, we'll store that name in the component's state object:

#+CAPTION[CollectionControls getInitialState()]:The ~getInitialState()~ Method of ~CollectionControls~ Component
#+NAME:CollectionControls getInitialState method
#+BEGIN_SRC js :eval no
getInitialState: function () {
    return ({
        name: 'new',
        isEditingName: false
    });
},

#+END_SRC

#+NAME:CollectionControls imports
#+BEGIN_SRC js :eval no
var React = require('react');
var Header = require('./Header.react');
var Button = require('./Button.react');
var CollectionRenameForm = require('./CollectionRenameForm.react');
var CollectionExportForm = require('./CollectionExportForm.react');
#+END_SRC

#+CINDEX:@code{isEditingName} property
The ~CollectionControls~ component can render either collection control
elements or a form to change the collection name.  A user can switch betweeen
the two.  We need a way to represent these two states---we'll use the
=isEditingName= property for that purpose.  By default, =isEditingName= is set
to =false=; and therefore, users won't see a form to change the collection
name, when the ~CollectionControls~ component is mounted.

{{{subheading(The ~render()~ Method of ~CollectionControls~ Component)}}}

#+CINDEX:@code{render} method of @file{CollectionControls} component
Let's take a look at its ~render()~ method:

#+CAPTION[CollectionControls render()]:The ~render()~ Method of ~CollectionControls~ Component
#+NAME:CollectionControls render method
#+BEGIN_SRC js :noweb yes :eval no
render: function () {
    if (this.state.isEditingName) {
        return (
            <<CollectionControls render CollectionRenameForm>>
        );
    }

    return (
        <div>
            <Header text={this.getHeaderText()} />

            <<CollectionControls render Rename Button component>>
            <<CollectionControls render Empty Button component>>

            <<CollectionControls render Export component>>
        </div>
    );
}
#+END_SRC

#+CINDEX:@code{isEditinName} property
#+CINDEX:@file{CollectionRenameForm} component
First we check whether the component state's property
~this.state.isEditingName~ is set to =true=.  If it is, then the
~CollectionControls~ component returns the ~CollectionRenameForm~ component
that renders a form to change the collection name:

#+CAPTION:CollectionControls render CollectionRenameForm
#+NAME:CollectionControls render CollectionRenameForm
#+BEGIN_SRC js :eval no
<CollectionRenameForm
    name={this.state.name}
    onChangeCollectionName={this.setCollectionName}
    onCancelCollectionNameChange={this.toggleEditCollectionName}
/>
#+END_SRC

The ~CollectionRenameForm~ component renders a form to change the collection
name.  It receives three properties:

- The =name= property referendes the current collection name
- The =onChangeCollectionName= and =onCancelCollectionNameChange= properties
  reference the component's methods


We'll implement the ~CollectionRenameForm~ component [[*Creating the ~CollectionRenameForm~ Component][later in this chapter]].

{{{subheading(The ~setCollectionName()~ Method)}}}

#+CINDEX:@code{setCollectionName()} method
Now let's take a closer look at the ~setCollectionName~ method.

#+CAPTION:The ~setCollectionName()~ Method of ~CollectionList~
#+NAME:CollectionControls setCollectionName method
#+BEGIN_SRC js :eval no
    setCollectionName: function (name) {
        this.setState({
            name: name,
            isEditingName: false
        });
    },

#+END_SRC

The ~setCollectionName()~ method updates the collection's name and hides a form
to edit the collection name by updating the component's state.  We'll call this
method when the user submits a new collection name.

{{{subheading(The ~toggleCollectionName()~ Method)}}}

#+CINDEX:@code{toggleEditCollectionName()} method
Now, let's take a look at the ~toggleEditCollectionName()~ method.

#+CAPTION:The ~toggleEditCollectionName()~ Method
#+NAME:CollectionControls toggleEditCollectionName method
#+BEGIN_SRC js :eval no
toggleEditCollectionName: function () {
    this.setState({
        isEditingName: !this.state.isEditingName
    });
},

#+END_SRC

#+CINDEX:@code{isEditingName} property
#+CINDEX:@key{Rename collection} button
#+CINDEX:@key{Cancel} button
It shows or hides the collection's name editing form by setting the
=isEditingName= property to the opposite of its current Boolean value using the
=!= operator.  We'll call this method when the user clicks on the {{{key(Rename
collection)}}} or {{{key(Cancel)}}} buttons, that is, show or hide the
collection name change form.

#+CINDEX:collection controls
If the ~CollectionControls~ component state's property
=this.state.isEditingName= is set to =false=, then it returns collection
controls.  [[CollectionControls render method]].

#+CINDEX:@file{Header} component
#+CINDEX:@file{CollectionExportForm} component
#+CINDEX:@code{getHeaderText()} method
We wrap the ~Header~ component, two ~Button~ components, and the
~CollectionExportForm~ component in a ~<div>~ element.  You're already familiar
with a ~Header~ component from the [[Header component][previous chapter]].  It receives a =text=
property that references a string.  However, in this case, we do not directly
pass a string, but rather a call to the ~this.getHeaderText()~ method.

#+CAPTION[CollectionControls getHeaderText() Method]:The ~getHeaderText()~ Method of ~CollectionControls~ Component
#+NAME:CollectionControls getHeaderText method
#+BEGIN_SRC js :noweb yes :eval no
getHeaderText: function () {
    var numberOfTweetsInCollection = this.props.numberOfTweetsInCollection;
    var text = numberOfTweetsInCollection;

    if (numberOfTweetsInCollection === 1) {
        text = text + ' tweet in your';
    } else {
        text = text + 'tweets in your';
    }

    <<getHeaderText returnText>>
},

#+END_SRC

#+CINDEX:tree of React elements
#+CINDEX:@code{numberOfTweetsInCollection} variable
#+CINDEX:@code{text} variable
This method generates a string for a header based on the number of tweets in
our collection.  The important feature of this method is that it returns not
only a string, but rather a tree of React elements that encapsulate that
string.  First, we create the ~numberOfTweetsInCollection~ variable.  It stores
a number of tweets in a collection.  We then create a ~text~ variable and
assign it a number of tweets in a collection.  At this point, the ~text~
variable stores an integer value.  Our next task is to concatenate the right
string to it based on what that integer value is:

- If ~numberOfTweetsInCollection~ is 1, then we need to concatenate ` tweet in
  your'
- Otherwise, we need to concatenate ` tweets in your'


Once the header string is created, then we return the following elements:

#+NAME:getHeaderText returnText
#+BEGIN_SRC js :eval no
return (
    <span>
        {text} <strong>{this.state.name}</strong> collection
    </span>
);

#+END_SRC

The final string encapsulated inside a ~<span>~ element consists of a value of
a ~text~ variable, a collection name, and the =collection= keyword.  For
example, run the following command:

Once this string is returned by the ~getHeaderText()~ method, it is then passed
as a property to a ~Header~ component.

*** The ~Button~ Controls

#+CINDEX:@file{Button} controls
#+CINDEX:@key{Rename collection} button
{{{subheading(The =Rename collection= Button)}}}

#+CINDEX:@code{toggleEditCollectionName} method
#+CINDEX:@code{handleClick} property
Our next collection control element in the ~CollectionControls~'s ~render()~
method is ~Button~.

#+CAPTION:Rendering the Rename ~Button~ Component
#+NAME:CollectionControls render Rename Button component
#+BEGIN_SRC js :eval no
<Button
     label="Rename collection"
     handleClick={this.toggleEditCollectionName}
/>

#+END_SRC

#+CINDEX:@code{toggleEditCollectionName} method
#+CINDEX:@code{handleClick} property
We pass the =Rename collection= string to its =label= property and the
~this.toggleEditCollectionName~ method to its =handleClick= property.  As a
result, this button will have the =Rename collection= label, and it will toggle
a form to change the collection name.

{{{subheading(The =Empty collection= Button)}}}

#+CINDEX:@code{Empty collection} @file{Button} component
#+CINDEX:tweets, remove all
#+CINDEX:remove all tweets
The next collection control element is our second ~Button~, =Empty collection=.
It will remove all the tweets from a collection.

#+CAPTION:Rendering the Empty ~Button~ Component
#+NAME:CollectionControls render Empty Button component
#+BEGIN_SRC js :eval no
<Button
     label="Empty collection"
     handleClick={this.props.onRemoveAllTweetsFromCollection}
/>
#+END_SRC

{{{subheading(The =CollectionExportForm= Button)}}}

#+CINDEX:@file{CollectionExportForm} component, rendering to
Our final collection control element is =CollectionExportForm=.

#+CAPTION:Rendering the ~ExportForm~ Component
#+NAME:CollectionControls render Export component
#+BEGIN_SRC js :eval no
<CollectionExportForm htmlMarkup={this.props.htmlMarkup} />
#+END_SRC

#+CINDEX:HTML markup string
It receives an HTML markup string that represents our collection, and it will
render a button.  We'll create this component [[*Creating the ~CollectionExportForm~ Component][later in this chapter]].

Now, when we understand what the ~CollectionControls~ component will render,
let's take a closer look at its child components.

** Creating the ~CollectionRenameForm~ Component

First, let's create the
~<dir>/snapterest/source/components/CollectionRenameForm.react.js~ file:

<<CollectionRenameForm-component>>
#+CINDEX:@file{CollectionRenameForm} component
#+CAPTION[<CollectionRenameForm Component>]:The ~CollectionRenameForm~ Component (~CollectionRenameForm.react.js~)
#+NAME:CollectionRenameForm component
#+HEADER: :noweb tangle :mkdirp yes :eval no
#+BEGIN_SRC js :tangle snapterest/source/components/CollectionRenameForm.react.js
<<CollectionRenameForm imports>>

var inputStyle = {
    marginRight: '5px'
};

var CollectionRenameForm = React.createClass({

    <<CollectionRenameForm getInitialState method>>
    <<CollectionRenameForm setInputValue method>>
    <<CollectionRenameForm handleInputValueChange method>>
    <<CollectionRenameForm handleFormSubmit method>>
    <<CollectionRenameForm handleFormCancel method>>
    <<CollectionRenameForm componentDidMount method>>
    <<CollectionRenameForm render method>>
});

module.exports = CollectionRenameForm;
#+END_SRC

#+NAME:CollectionRenameForm imports
#+BEGIN_SRC js :eval no
var React = require('react');
var ReactDOM = require('react-dom');
var Header = require('./Header.react');
var Button = require('./Button.react');
#+END_SRC

*** CollectionRenameForm ~render()~ Method

#+CINDEX:@code{render()} method of @file{CollectionRenameForm} component
This component renders a form to change the collection name:

#+CAPTION[CollectionRenameForm render() Method]:The ~render()~ Method of ~CollectionRenameForm~ Component
#+NAME:CollectionRenameForm render method
#+BEGIN_SRC js :eval no
render: function () {
    return (
        <form
            className="form-inline"
            onSubmit={this.handleSubmit}
        >

            <Header text="Collection name:" />

            <div className="form-group">
                <input
                    className="form-control"
                    style={inputStyle}
                    onChange={this.handleInputValueChange}
                    value={this.state.inputValue}
                    ref="collectionName"
                />
            </div>

            <Button label="Change" handleClick={this.handleFormSubmit} />
            <Button label="Cancel" handleClick={this.handleFormCancel} />
        </form>
    );
}
#+END_SRC

#+CINDEX:@code{form} element of @file{CollectionRenameForm} component
The ~<form>~ element wraps four elements, which are as follows:

- One ~Header~ component
- One ~<input>~ element
- Two ~Button~ components


#+CINDEX:@file{Header} component of @file{CollectionRenameForm} component
#+CINDEX:Bootstrap framework
#+CINDEX:styling
The ~Header~ component renders the ='Collection name:'= string.  The ~<input>~
element is wrapped inside a ~<div>~ element with a =className= property set to
=form-group=.  This name is part of the [[Bootstrap][Bootstrap framework]] that we discussed
in Chapter 4.  It's used for layout and styling and it's not part of our React
application's logic.

#+CINDEX:@code{<input>} element of @file{CollectionRenameForm} component
The ~<input>~ element has quite a few properties.

- The =className= property is set to =form-control=.  It is another class name,
  which is part of the Bootstrap framework.  We will use this for styling
  purposes.
- In addition, we apply our own style to this =input= element using the =style=
  property that references the =inputStyle= object with a single style rule:
  =marginRight=.
- The =value= property is set to a current value stored in the component's
  state, ~this.state.inputValue~.
- The =onChange= property references a ~this.handleInputValueChange~ method
  that is an ~onChange~ event handler.
- =ref= is a special React property that you can attach to any component that
  is returned by a ~render()~ method.  It allows you to refer to that component
  outside a ~render()~ method.  Shortly, we'll see [[refs object][an example]] of this.


#+CINDEX:@code{ref} property
#+CINDEX:@code{value} property, changing
Focus on the last three properties: =value=, =onChange=, and =ref=.  The
=value= property is set to the component state's property, and the only way to
change that value is to update its state.  On the other hand, we know that a
user can interact with an input field and change its value.  Will this behavior
apply to our component?  No.  Whenever a user types, our input field's value
won't change.  This is because a component is in control of ~<input>~, not a
user.  In our ~CollectionRenameForm~ component, the value of the ~<input>~
always reflects the value of ~this.state.inputValue~ property, regardless of
what the user types.  The user is not in control, but the
~CollectionRenameForm~ component is.

*** Handle User Input

#+CINDEX:user input, reacting to
#+CINDEX:reacting to user input
Then how can we make sure that our input field reacts to a user input?  We need
to listen to a user input, and update the state of the ~CollectionRenameForm~
component, which in turn will re-render the input field with an updated value.
Doing so on every inputer's ~change~ event will make our input look like it
works as usual, and the user can freely change its value.

#+CINDEX:@code{onChange} property
#+CINDEX:@file{handleInputValueChange()} method
For this, we provide our ~<input>~ element with the =onChange= property that
references the component's ~this.handleInputValueChange~ method:

#+CAPTION[CollectionRenameForm handleInputValueChange() Method]:handleInputValueChange Method
#+NAME:CollectionRenameForm handleInputValueChange method
#+BEGIN_SRC js :eval no
handleInputValueChange: function (event) {
    var inputValue = event.target.value
    this.setInputValue(inputValue);
},

#+END_SRC

#+CINDEX:@file{SyntheticEvent}
#+CINDEX:event handlers
#+CINDEX:@code{handleInputValueChange()} method
#+CINDEX:@code{value} property
#+CINDEX:@code{setInputValue()} method
As we discussed in Chapter 3, React passes instances of [[SyntheticEvent][~SyntheticEvent~]] to
event handlers.  The ~handleInputValueChange()~ method receives an =event=
object with a =target= property that has a =value= property.  This =value=
property stores a string that a user has typed in our input field.  We pass
that string into our ~this.setInputValue()~ method:

#+CAPTION[CollectionRenameForm setInputValue]:The ~setInputValue()~ Method of ~CollectionRenameForm~ Component
#+NAME:CollectionRenameForm setInputValue method
#+BEGIN_SRC js :eval no
setInputValue: function (inputValue) {
    this.setState({
        inputValue: inputValue
    });
},

#+END_SRC

~setInputValue()~ is a convenience method that updates the component's state
with a new input value.  In turn, this update will re-render the ~<input>~
element with an updated value.

What is the initial input's value when the ~CollectionRenameForm~ component is
mounted?  Let's take a look at this:

#+CINDEX:@code{getInitialState()} method
#+CAPTION[CollectionRenameForm getInitialState() Method]:The ~getInitialState()~ Method of ~CollectionRenameForm~ Component
#+NAME:CollectionRenameForm getInitialState method
#+BEGIN_SRC js :eval no
getInitialState: function () {
    return ({
        inputValue: this.props.name
    });
},

#+END_SRC

We pass the collection's name from a parent component, and we use it to set our
initial input value.

*** Set Focus

After we mount this component, we want to set focus on the input field so that
the user can start editing the collection's name straightaway.  We know that
once a component is inserted into the DOM, React calls its
~componentDidMount()~ method.  This method is our best opportunity to set
focus:

#+CINDEX:@code{componentDidMount()} method
#+CAPTION[CollectionRenameForm componentDidMount() Method]:The ~componentDidMount()~ Method of ~CollectionRenameForm~ Component
#+NAME:CollectionRenameForm componentDidMount method
#+BEGIN_SRC js :eval no
componentDidMount: function () {
    this.refs.collectionName.focus();
},

#+END_SRC

#+CINDEX:@code{focus()} function
To do this, we get our input element and call ~focus()~ function on it.

#+CINDEX:@code{refs} object
#+CINDEX:@code{refs.collectionName}
<<refs object>>How can we reference an element inside the ~componentDidMount()~
method?  We can use the =this.refs= object to refer to our ~input~ element.
Because we provided our ~input~ element with a =ref= property, which is set to
=collectionName=, we can refer to it via ~this.refs.collectionName~.

*** Change and Cancel Buttons

#+CINDEX:form buttons
#+CINDEX:@code{Change} button
#+CINDEX:@code{Cancel} button
Finally, let's discuss our two form buttons:

- The ~Change~ button submits the form and changes the collection name
- The ~Cancel~ button submits the form but doesn't change the collection name


We'll start with a ~Change~ button.  When a user clicks on it, the
~this.handleFormSubmit()~ method is called:

<<CollectionRenameForm.handleFormSubmit method>>
#+CINDEX:@code{handleFormSubmit()} method
#+CAPTION[CollectionRenameForm handleFormSubmit Method]:The ~handleFormSubmit()~ Method of ~CollectionRenameForm~ Component
#+NAME:CollectionRenameForm handleFormSubmit method
#+BEGIN_SRC js :eval no
handleFormSubmit: function (event) {
    event.preventDefault();

    var collectionName = this.state.inputValue;
    this.props.onChangeCollectionName(collectionName);
},

#+END_SRC

#+CINDEX:@code{props.onChangeCollectionName()} method call
#+CINDEX:@code{onChangeCollectionName()} method
#+CINDEX:@file{CollectionControls} component
We cancel the ~submit~ event, then get the collection name from the component's
state, and pass it to the ~this.props.onChangeCollectionName()~ method call.
The ~onChangeCollectionName()~ method is passed by a parent
~CollectionControls~ component.  Calling this method will change our
collection's name.

Now let's discuss our second form button.

#+CINDEX:@code{handleFormCancel()} method
When a user clicks on it, the ~this.handleFormCancel()~ method is called:

<<CollectionRenameForm handleFormCancel method>>
#+CAPTION[CollectionRenameForm handleFormCancel() Method]:The ~handleFormCancel()~ Method of ~CollectionRenameForm~ Component
#+NAME:CollectionRenameForm handleFormCancel method
#+BEGIN_SRC js :eval no
handleFormCancel: function (event) {
    event.preventDefault();

    var collectionName = this.props.name;
    this.setInputValue(collectionName);
    this.props.onCancelCollectionNameChange();
},

#+END_SRC

#+CINDEX:@code{props.onCancelCollectionNameChange()} method
#+CINDEX:@code{onCancelCollectionNameChange()} method
#+CINDEX:@code{setInputValue()} method
Once again, we cancel a ~submit~ event, then get the original collection name
that is passed as a property by a parent ~CollectionControls~ component, and
pass it to our ~this.setInputValue()~ method.  Then, we call the
~this.props.onCancelCollectionNameChange()~ method that hides the collection
controls.

That's our ~CollectionRenameForm~ component.  Next, let's create our ~Button~
component that we reused twice in our ~CollectionRenameForm~ Component.

** Creating the ~Button~ Component

#+CINDEX:@file{Button} component
Create the following file at
~<dir>/snapterest/source/components/Button.react.js~:

#+CAPTION[<Button Component>]:The ~Button~ Component (~Button.react.js~)
#+NAME:Button component
#+BEGIN_SRC js :tangle snapterest/source/components/Button.react.js :mkdirp yes :eval no
var React = require('react');

var buttonStyle = {
    margin: '10px 10px 10px 0'
};

var Button = React.createClass({

    render: function () {
        return (
            <button
                className="btn btn-default"
                style={buttonStyle}
                onClick={this.props.handleClick}
            >
                {this.props.label}
            </button>
        );
    }
});

module.exports = Button;
#+END_SRC

#+CINDEX:@code{button} element
The ~Button~ component renders a button.  What is the benefit of creating a
dedicated component for a button if you could just use the ~<button>~ element?
Think of a component as a wrapper for a ~<button>~ element and something else
that comes with it.  In our case, most ~<button>~ elements come with the same
style, so it makes sense to encapsulate both the ~<button>~  and style objects
inside a component and reuse that component.  Hence, the Button component.  It
expects to receive two properties from a parent component:

1. The =label= property is a label for a button
2. The =handleClick= property is a callback function that is called when a user
   clicks on this button


** Creating the ~CollectionExportForm~ Component

#+CINDEX:~CollectionExportForm~ component
Now it's time to create our ~CollectionExportForm~ component.

#+CINDEX:CodePen website
The ~CollectionExportForm~ component is responsible for exporting a collection
to a third-party website (https://codepen.io/).  Once your collection is on
CodePen, you can save it and share it with friends.  Let's take a look at how
this can be done.

Create the ~<dir>/snapterest/source/components/CollectionExportForm.react.js~
file:

#+CAPTION[<CollectionExportForm Component>]:The ~CollectionExportForm~ Component (~CollectionExportForm.react.js~)
#+NAME:CollectionExportForm component
#+BEGIN_SRC js :tangle snapterest/source/components/CollectionExportForm.react.js :mkdirp yes :eval no
var React = require('react');

var formStyle = {
    display: 'inline-block'
};

var CollectionExportForm = React.createClass({

    render: function () {
        return (
            <form
                action="https://codepen.io/pen/define"
                method="POST"
                target="_blank"
                style={formStyle} >

                <input
                    type="hidden"
                    name="data"
                    value={this.props.htmlMarkup} />

                <button
                    type="submit"
                    className="btn btn-default" >

                    Export as HTML

                </button>
            </form>
        );
    }
});

module.exports = CollectionExportForm;
#+END_SRC

#+CINDEX:@code{input} element
#+CINDEX:@code{button} element
#+CINDEX:@samp{Export as HTML}
The ~CollectionExportForm~ component renders a form with the ~<input>~ and
~<button>~ elements.  The ~<input>~ element is hidden, and its value is set to
an HTML markup string that is passed by a parent component.  The ~<button>~
element is the only element in this form that is visible to a user.  When a
user clicks on the {{{key(Export as HTML)}}} button, a collection is submitted
to CodePen that is opened in a new window.  A user can then modify and share
that collection.

** Start Your Engine

#+CINDEX:web application, fully functional
Congratulations! At this point, we've build a fully functional web application
with React.  Let's see how it works.

Install ({{{samp(tangle)}}}) all of the source files into the project structure:

#+NAME:tangle all files
#+begin_src emacs-lisp :exports both :results output
;;; 'org-babel-tangle' saves the current buffer before proceeding; for whatever
;;; reason, the current buffer has been modified during the exporting and evaluating
;;; process, which causes problems with subsequent export processes after the
;;; tangling process, e.g., the current buffer differs from the source file.
;;; This function copies the unmodified source file, opens it in a new buffer,
;;; then tangles the files, then deletes the newly-created file and buffer, then
;;; proceeds with the remaining exporting process.  This solves the problem created
;;; by the tangling process.
(copy-file "reactjs-essentials.org" "reactjs-essentials-bak.org" t t t t)
(with-current-buffer (find-file "reactjs-essentials-bak.org")
  (progn
    (org-babel-tangle)
    (delete-file "reactjs-essentials-bak.org")
    (kill-buffer "reactjs-essentials-bak.org")))

;(rename-file "reactjs-essentials-bak.org" "reactjs-essentials.org" t)
#+end_src

#+CINDEX:Snapkite Engine, run
Also, make sure that the Snapkite Engine that we installed and configured in
Chapter 1 is [[test-Snapkite-Engine][running]].  Navigate to ~<dir>/snapkite-engine/~ and run the
following command:[fn::This was already done when the Snapkite Engine was
installed; see [[test-Snapkite-Engine][Run the Snapkite Engine]]]
: npm start

Then, open a new Terminal window, navigate to ~<dir>/snapterest/~, and run this
command:

#+NAME:run gulp command
#+HEADER: :exports results :results output
#+BEGIN_SRC sh :dir snapterest
yarn run gulp
#+END_SRC

Now, open ~<dir>/snapterest/build/index.html~ in your web browser.

#+NAME:open index.html in browser
#+begin_src sh :exports results :results output silent :dir snapterest/build
open -a 'Google Chrome' index.html
#+end_src

[[file:snapterest/build/index.html][index.html]]

You will see new tweets appear.  Click on them to add them to your collection.
Click on them again to remove individual tweets from the collection.  Click on
the {{{key(Empty collection)}}} button to remove all thee tweets from your
collection.  Click on the {{{key(Rename collection)}}} button, type a new
collection name, and click on the {{{key(Change)}}} button.  Finally, click on
the {{{key(Export as HTML)}}} button to export your collection to CodePend.

If you have any trouble with this chapter or previous chapters, then go to
https://github.com/fedosejev/react-essentials and create a new issue.

** Summary

In this chapter, you created the

- ~TweetList~ component
- ~CollectionControls~ component
- ~CollectionRenameForm~ component
- ~CollectionExportForm~ component
- ~Button~ component


You completed building a fully functional React applicationb.  In our next
chapters, we'll test it with Jest and enhance it with Flux.

* Test Your React Application With Jest

By now you have created a number of React components.  Some of them are quite
straightforward, but some are sophisticacted.  Having built both, you might
have gained a certain confidence, which makes you believe that no matter how
complex the user interface is, you can build it with React, without any major
pitfalls.  This is a good confidence to have.  After all that's why we're
investing time in learning React.  However, there is a trap that many confident
React developers fall into: the act of not writing unit tests.

#+CINDEX:unit test
What is a unit test?  As the name suggests, a {{{dfn(unit test)}}} is a test
for a single unit of your application.  A single unit in your application is
often a function, which suggests that writing unit tests means writing tests
for your functions.

** Install Jest 0.4                                               :noexport:

- See [[https://github.com/fedosejev/react-essentials/blob/master/updates.md#chapter-8-page-6][Errata]]
  : npm install --save-dev jest-cli@^0.4

- Note: Jest CLI 0.4 will not install correctly

** Why Write Unit Tests

You might be wondering why you should write unit tests.

** Creating Test Suites---Specs---Expectations

#+CINDEX:test fraemwork
#+CINDEX:Facebook test framework, Jest
#+CINDEX:Jest, Facebook's test framework
#+CINDEX:Jasmine
How does one write a test for JavaScript functions?  You need a testing
framework, and luckily Facebook has built its own unit test framework for
JavaScript called *Jest*.  It is built on top of *Jasmine*, another well-known
JavaScript test framework.  Jest's approach to testing is very similar
However, I'll make no assumptions about your prior experience with testing
frameworks and discuss the basics first.

#+CINDEX:mock, mocking
The fundamental idea of unit testing is that you test only one piece of
functionality in your application that usually is implemented by one function.
You test it in isolation, which means that all the other parts of your
application that the function depends on are not used by your tests.  Instead,
they are imitated by your tests.  To imitate a JavaScript object is to create a
fake one that simulates the behavior of the real object.  In unit testing, the
fake object is called a {{{dfn(mock)}}} and the process of creating it is
called {{{dfn(mocking)}}}.

Jest automatically mocks the dependencies when you're running your tests.  It
automatically finds tests to be executed in your repository.  Here's an
example.

*** TweetUtils Example Test

#+CINDEX:@file{snapterest/source/utils/} directory
#+CINDEX:@file{TweetUtils.js} file
First, create the ~<dir>/snapterest/source/utils/~ directory.  Then, create a
new ~TweetUtils.js~ file in it:

#+CAPTION[<TweetUtils Module>]:The ~TweetUtils~ Module in ~source/utils/~
#+NAME:TweetUtils module
#+BEGIN_SRC js :tangle snapterest/source/utils/TweetUtils.js :mkdirp yes :eval no
exports.getListOfTweetIds = function (tweets) {
    return (Object.keys(tweets));
}
#+END_SRC

#+CINDEX:@code{getListOfTweetIds()} utility function
#+CINDEX:CommonJS module pattern
The ~TweetUtils.js~ file is a module with the ~getListOfTweetIds()~ utility
function for our application to use.  Given an object with tweets,
~getListOfTweetIds()~ returns an array of tweet IDs.  Using the CommonJS module
pattern, we export this function.

*** Unit Test for TweetUtils Module

Now let's write our first unit test with Jest.  We'll test our
~getListOfTweetIds()~ function.

#+CINDEX:@file{snapterest/source/utils__tests__} directory
#+CINDEX:@file{__tests__} directory
Create a new directory: ~<dir>/snapterest/source/utils/__tests__/~.  Jest will
run any tests in any ~__test__~ directories that it finds in your project
structure.  So, it's important to name your directories with ~__tests__~.

#+CINDEX:@file{TweetUtils-test.js} file
Create a ~TweetUtils-test.js~ file inside ~__tests__~.

#+CINDEX:@code{TweetUtils-test} test module
#+CAPTION[<TweetUtils-test Module>]:The ~TweetUtils-test~ Test Module
#+NAME:TweetUtils-test module
#+BEGIN_SRC js :tangle snapterest/source/utils/__tests__/TweetUtil-test.js :mkdirp yes :eval no
jest.dontMock('../TweetUtils');

describe ('Tweet utilities module', function () {
    it('returns an array of tweet ids', function () {
        var TweetUtils = require('../TweetUtils');
        var tweetsMock = {
            tweet1: {},
            tweet2: {},
            tweet3: {}
        };
        var expectedListOfTweetIds = [ 'tweet1', 'tweet2', 'tweet3' ];
        var actualListOfTweetIds = TweetUtils.getListOfTweetIds(tweetsMock);
        expect(actualListOfTweetIds).toEqual(expectedListOfTweetIds);
    });
});
#+END_SRC

#+CINDEX:mock @code{require}d modules automatically
We need to tell Jest not to mock our ~TweetUtils~ module because Jest will
/automatically/ mock modules returned by the ~require()~ function.  In our
test, we ~require()~ the ~TweetUtils~ module.

#+CINDEX:@code{jest.dontMock()} function
Without the ~jest.dontMock('../TweetUtils')~ call, Jest would return an
imitation of our ~TweetUtils~ module, instead of the real one.  In this case,
we actually need the real ~TweetUtils~ module because that's what we're
testing.

*** Create a Suite of Tests using ~describe()~

#+CINDEX:@code{describe()} global function
#+CINDEX:global @code{describe} function
#+CINDEX:suite of tests
Next, we call a global ~describe()~ Jest function.  It's important to
understand the concept behind it.  In our ~TweetUtils-test.js~ file, we're not
just creating a single test; instead we're creating a suite of tests.  A suite
is a collection of tests that collectively tests a bigger unit of
functionality.  For example, a suite can have multiple tests, which tests all
the individual parts of a larger module.  In our example, we have a
~TweetUtils~ module with potentially a number of utility functions.  In this
situation, we would create a suite for the ~TweetUtils~ module, and then create
tests for each individual utility function, such as ~getListOfTweetIds()~.

#+CINDEX:suite name parameter
#+CINDEX:suite implemenetation parameter
The ~describe()~ function defines a suite and takes these two parameters:

- Suite name :: the title that describes what is being tested by this ~Tweet
                  utilities module' suite
- Suite implementation :: the function that implements this suite


*** Create Specs using ~it()~

#+CINDEX:spec
#+CINDEX:@code{it()} global function
#+CINDEX:global @code{it()} function
How do you create an individual test?  In Jest, individual tests are called
{{{dfn(specs)}}}.  They are defined by calling another global Jest function,
~it()~.

#+CINDEX:spec name parameter
#+CINDEX:spec implementation parameter
Just like ~describe()~, the ~it()~ function takes two parameters:

- Spec name :: the title that describes what is being tested by this =returns
               an array of tweet ids= spec;
- Spec implementation :: the function that implements this spec;


#+CINDEX:spec for @file{TweetUtils} module
The spec tests whether the ~getListOfTweetIds()~ method of our ~TweetUtils~
module returns an array of tweet IDs, when given an object with tweets.

#+CINDEX:mock object for tweets object
First, we import the ~TweetUtils~ module.  Then we create a mock object that
simulates the real tweets object.  The only requirement for this mock object is
to have tweet IDs as object keys.  The values are not important, so we choose
empty objects.  The key names are not important as well, so we choose to name
them =tweet1=, =tweet2=, and =tweet3=.  This mock object doesn't fully simulate
the real tweet objects.  Its sole purpose is to simulate the fact that its keys
are tweet IDs.

#+CINDEX:expected list of tweet IDs
#+CINDEX:@code{tweetsMock} object
#+CINDEX:@code{actualListOfTweetsIds} variable
The next step is to create an expected list of tweet IDs.  We know what tweet
IDs to expect because we've mocked the =tweets= object.  For this, we use the
~getListOfTweetIds()~ method that takes the =tweets= object and returns an
array of tweet IDs.  We pass the =tweetsMock= object to that method and store
the result in the ~actualListOfTweetIds~ variable.  The reason it's name that
is because this list of tweet IDs is produced by the actual
~getListOfTweetIds()~ function that we are testing.

*** Test Expectations with ~expect().toEqual()~

#+CINDEX:@code{expect().toEqual()} global function
#+CINDEX:global @code{expect().toEqual()} function
The final step will introduce us to a new important concept: the
~expect().toEqual()~ method.  Let's think about the process of testing, that
is, ~getListOfTweetIds()~, and match it to the expected value that we know in
advance.  The result of that match will determine whether our test has passed
or failed.

The reson why we can guess what ~getListOfTweetIds()~ will return in advance is
because we've prepared the input for it; that's our mock object, the
~tweetsMock~ variable.  So, we can expect the following output by calling
~TweetUtils.getListOfTweetIds(tweetsMock)~:

#+CINDEX:expectation
#+CINDEX:@code{expect()} function
#+CINDEX:@code{matcher} function
Because something can go wrong inside ~getListOfTweetIds()~, we cannot
guarantee this result; we can only /expect/ it.  That's why we need to create
an expectation.  In Jest, an {{{dfn(expectation)}}} is build using the
~expect()~ function, which takes an actual value, for example, the
=actualListOfTweetIds= object.  Then, we chain it with a {{{dfn(matcher)}}}
function that compares the actual value with the expected value and tells Jest
whether the expectation was met or not.

#+CINDEX:@code{toEqual()} matcher function
#+CINDEX:matcher functions, complete list
In our example, we use the ~toEqual()~ matcher function to compare the two
arrays.  You can find a list of all the built-in matcher functions in Jest at
https://jestjs.io/docs/en/expect.

#+CINDEX:spec, create
#+CINDEX:expectations, in a spec
#+CINDEX:passing spec
#+CINDEX:failing spec
This is how you create a spec.  A spec contains one or more expectations.  Each
expectation tests the state of your code.  A spec can be either a /passing
spec/ or a /failing spec/.  A spec is a passing spec only when all the
expectations are met; otherwise, it's a failing spec.

** Installing and Running Jest

First, let's install the Jest command-line interface *Jest CLI*.

- See [[https://github.com/fedosejev/react-essentials/blob/master/updates.md#chapter-8-page-6][Errata]]
  : npm install --save-dev jest-cli@^0.4
Note that the above will not install on my machine, so try installing the
latest and see how things go:
  : Yarn add jest-cli --dev

#+NAME:Install Latest Jest-CLI
#+BEGIN_SRC sh :dir snapterest :results output :exports both
yarn add --dev jest-cli
#+END_SRC

This command installs the Jest CLI and adds it as a development dependency to
the ~<dir>snapterest/package.json~ file.

Next, edit the ~package.json~ file.  Replace the existing =scripts=
object[fn::My ~package.json~ does not have an existing =scripts= object,
perhaps because it was created with Yarn?], replacing it with:

#+BEGIN_SRC js :eval no
"scripts": {
     "test": "jest"
},
#+END_SRC

#+CAPTION: Adding a =test= Script Command to ~Package.json~
#+NAME:add test script to package.json
#+HEADER: :results output
#+HEADER: :exports both
#+HEADER: :dir snapterest
#+BEGIN_SRC js
var fs = require('fs');
var p = JSON.parse(fs.readFileSync('package.json', 'utf8'));
p.scripts = { "test": "jest"};
p = JSON.stringify(p,null,2);
fs.writeFileSync('package.json', p);
console.log(p);
#+END_SRC


Now we're ready to run our test suite.  Navigate to the ~<dir>/snapterest/~
directory, and run the following command:

[[shell:(cd%20snapterest;%20yarn%20test;)][yarn test]]

You should see the following message in your Terminal:

#+BEGIN_EXAMPLE
Using Jest CLI v.0.4.18
  PASS  source/utils/__tests__/TweetUtils-test.js (0.065s)
1 test passed (1 total)
Run time: 0.295s
#+END_EXAMPLE

The key line in this message is as follows:

- =PASS=: tells you that your test has passed
- ~source/utils/__tests__/TweetUtils-test.js~: tells you what test it was running
- =(0.065s)=: tells you how long it took to run the test


That's all it takes to write and test a tiny unit test.  Now, let's create
another one!

** Creating Multiple Specs and Expectations

#+CINDEX:collection utility module
#+CINDEX:@file{CollectionUtils.js} file
#+CINDEX:@file{snapterest/source/utils/} directory
<<CollectionUtils module>>This time, we'll create and test the collection
utility module.  Create the ~CollectionUtils.js~ file in the
~<dir>/snapterest/source/utils/~ directory:

#+CAPTION[<CollectionUtils Module>]:The ~CollectionUtils~ Module for Testing
#+NAME:CollectionUtils module
#+BEGIN_SRC js :tangle snapterest/source/utils/CollectionUtils.js :mkdirp yes :eval no
function getNumberOfTweetsInCollection (collection) {
    var TweetUtils = require('./TweetUtils');
    var listOfCollectionTweetIds = TweetUtils.getListOfTweetIds(collection);

    return listOfCollectionTweetIds.length;
}

function isEmptyCollection (collection) {
    return (getNumberOfTweetsInCollection(collection) === 0);
}

module.exports = {
    getNumberOfTweetsInCollection,
    isEmptyCollection
};

#+END_SRC

#+CINDEX:@code{getNumberOfTweetsInColelction()} function
#+CINDEX:@code{isEmptyCollection()} function
The ~CollectionUtils~ module has two functions:
- ~getNumberOfTweetsInCollection()~
- ~isEmptyCollection()~

{{{heading(Describing the ~getNumberOfTweetsInCollection()~ Function)}}}

First, let's discuss ~getNumberOfTweetsInCollection()~.  This function requires
the ~TweetUtils~ module as a dependency.  It then calls the
~getListOfTweetIds()~ function and passes the =collection= object as a
parameter.  The result return by ~getListOfTweetIds()~ is stored in the
~listOfCollectionTweetIds~ variable, and since it's an array,
~getNumberOfTweetsInCollection()~ returns a =length= property of that array.

{{{heading(Describing the ~isEmptyCollection()~ Function)}}}

Now, let's take a look at the ~isEmptyCollection()~ function.  It reuses the
~getNumberOfTweetsInCollection()~ function that we just discussed.  It checks
whether the result returned by a call to ~getNumberOfTweetsInCollection()~ is
equal to zero.  Then it returns the result of that check, which is either true
or false.

Finally, we export both the functions from this module.

*** Testing the ~CollectionUtils~ Module

We just created our ~CollectionUtils~ module.  Our next task is to test it.

#+CINDEX:@file{CollectionUtils-test.js} file
Inside the ~<dir>/snapterest/source/utils/__tests__/~ directory, create the
following ~CollectionUtils-test.js~ file:

#+CAPTION[<CollectionUtils-test File>]:The ~CollectionUtils-test~ File
#+NAME:CollectionUtils-test file
#+BEGIN_SRC js :tangle snapterest/source/utils/__tests__/CollectionUtils-test.js :mkdirp yes :eval no
jest.autoMockOff();

describe('Collection utilities module', function () {
    var CollectionUtils = require('../CollectionUtils');
    var collectionTweetsMock = {
        collectionTweet7: {},
        collectionTweet8: {},
        collectionTweet9: {}
    };

    it('returns a number of tweets in collection', function getNumberOfTweetsInCollection () {
        var actualNumberOfTweetsInCollection = CollectionUtils.
            getNumberOfTweetsInCollection(collectionTweetsMock);
        var expectedNumberOfTweetsInCollection = 3;

        expect(actualNumberOfTweetsInCollection).toBe(expectedNumberOfTweetsInCollection);
    });

    it('checks if collection is not empty', function isNotEmptyCollection () {
        var actualIsEmptyCollectionValue = CollectionUtils.isEmptyCollection(collectionTweetsMock);

        expect(actualIsEmptyCollectionValue).toBeDefined();
        expect(actualIsEmptyCollectionValue).toBe(false);
        expect(actualIsEmptyCollectionValue).not.toBe(true);

    });
});
#+END_SRC

The ~CollectionUtils-test.js~ is a bigger test suite than the one we created
earlier.  There are quite a few things to learn from it.  Let's discuss it in
detail.

*** No Automatic Mocking

#+CINDEX:mock automatically
#+CINDEX:@code{dontMock()}
#+CINDEX:@code{mock()}
#+CINDEX:@code{autoMockOff()}
#+CINDEX:@code{autoMockOn()}
The first thing that we need to do is to tell Jest not to mock automatically.
What does it mean to mock automatically?  In the testing environment, Jest
replaces your usual ~require()~ function with its own version.  Jest's version
of ~require()~ function loads the real module and replaces that module with its
mock version.  As a result, none of the ~require()~ function calls will work as
expected in our testing environment, not even the ones that are used to import
the dependency modules inside a module that we are testing.  This means that
for the module that we want the test work, we need to call ~jest.dontMock()~
for that module, and then for each module that it depends on.  There can be a
large numberr of dependency modules.  So instead of calling ~jest.dontMock()~
too many times, we can reverse the situation by called the ~jest.autoMockOff()~
method.  Now Jest won't mock by default, which means that we will need to
explicitly call the ~jest.mock()~ method for each module that we want to mock.

In ~CollectionsUtils-test.js~, we only import the two modules ~CollectionUtils~
and its dependency module ~TweetUtils~.  So a less efficient alternative to
~jest.autoMockOff()~ would be as follows:


Once you call ~jest.autoMockOff()~ to turn the automatic mocking off, you can
then call ~jest.autoMockOn()~ to turn it back on later in your code.

*** Define the Test Suite with ~describe()~

#+CINDEX:@samp{Collection utilities module} description
#+CINDEX:@code{describe()} function
#+CINDEX:@code{collectionTweetsMock} object
After taking care of turning off the automatic mocking, we define our test
suite using ~describe()~.  We give it a name =Collection utilities module=
since it describes exactly what module we're testing.  Now let's take a look at
the implementation of this test suite.  Instead of immediately defining specs
like we did in our previous test suite, we're importing the ~CollectionUtils~
module and creating the =collectionTweetsMock= object.  So, are we allowed to
do that?  Absolutely.  The test suite implementation function is just another
JavaScript function, where we can do some work before we define our test specs.

#+CINDEX:specs, implementing
#+CINDEX:@code{collectionTweetsMock} object
This test suite will implement more than one spec.  All of them will use the
=collectionTweetsMock= object, so it makes sense to define it outside the
specs' scope and reuse it inside the specs.  As you might have already guessed,
the =collectionTweetsMock= object imitates a collection of tweets.

Now, let's implement the individual specs.  Our first spec tests whether the
~CollectionUtils~ module returns a number of tweets in the collection.  We
first get the actual number of tweets in our mock collection.  For this, we
call the ~getNumberOfTweetsInCollection()~ function and pass the
~collectionTweetsMock~ object to it.  Then we define the number of expected
tweets in our mock collection.  Finally, we call the ~expect()~ global function
to create an expectation.  We use the ~toBe()~ matcher function to match the
actual value and the expected one.

*** Running Tests and Learning About Failing Tests

If you now run the {{{command(npm test)}}} command, you will see that both the
test suites pass.

[[shell:(cd%20snapterest;%20yarn%20test;)][Test Collection utilities module]]

How about running a little evil experiment?

Open your ~<dir>/snapterest/source/utils/CollectionUtils.js~ file and inside
the ~getNumberOfTweetsInCollection()~ function, to the following line of code:

Now change it to this:

That this tiny update will do is return an incorrect number of tweets in any
given collection.  Now run {{{command{npm test)}}} one more time.  You should
see that all of your specs in ~CollectionUtils-test.js~ have failed.  Here is
the one we're interested in.

#+BEGIN_EXAMPLE
yarn run v1.13.0
$ jest
FAIL source/utils/__tests__/CollectionUtils-test.js
   Collection utilities module  returns a number of tweets in collection

    expect(received).toBe(expected) // Object.is equality

    Expected: 3
    Received: 4

      14 |         var expectedNumberOfTweetsInCollection = 3;
      15 |
    > 16 |         expect(actualNumberOfTweetsInCollection).toBe(expectedNumberOfTweetsInCollection);
         |                                                  ^
      17 |     });
      18 |
      19 |     it('checks if collection is not empty', function isNotEmptyCollection () {

      at Object.toBe (source/utils/__tests__/CollectionUtils-test.js:16:50)

PASS source/utils/__tests__/TweetUtil-test.js

Test Suites: 1 failed, 1 passed, 2 total
Tests:       1 failed, 2 passed, 3 total
Snapshots:   0 total
Time:        0.932s, estimated 1s
Ran all test suites.
error Command failed with exit code 1.
info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.
#+END_EXAMPLE

We haven't seen a failing test before, so let's take acloser look at what it's
trying to tell us.  First, it gives us the bad news that the
~CollectionUtils-test.js~ test has failed.  Then, it tells us in a
human-friendly manner what we were testing.  Then, what went wrong; the
unexpected test result.  Finally, Jest prints a stack trace that should give us
enough technical details to quickly identify what part of our code has produced
the unexpected result.

Don't forget to revert the file to its original value.

*** Implementing Multiple Specs in a Test Suite

The distinct difference between our previous test suite and
~CollectionUtils-test.js~ is the number of specs.  A test suite in Jest can
have many specs that test different methods of a single module.  Our
~CollectionUtils~ module has two methods.  Our test suite for it will have
three specs.  Let's discuss the other two.

Our next spec in ~CollectionUtils-test.js~ checks whether the collection is not
empty.  First, we call the ~isEmptyCollection()~ method and pass the
~collectionTweetsMock~ object to it.  We store the result in the
~actualIsEmptyCollectionValue~ variable.  Notice how we're reusing the same
~collectionTweetsMock~ object as in our previous spec?

#+CINDEX:expectations
#+CINDEX:@code{toEqual()}
#+CINDEX:@code{toBeDefined()}
#+CINDEX:@code{toBe(false)}
#+CINDEX:@code{not.toBe(true)}
Next, we create not one but three expectations.  You might have already guessed
what we're expecting from our ~actualIsEmptyCollectionValue~.  We expect it to
be defined.  This means that the ~isEmptyCollection()~ function must return
something other than =undefined=.  We expect its value to be =false=.  Earlier,
we used the ~toEqual()~ matcher function to compare the arrays.  ~toEqual()~
does a deep comparison, which is perfect for comparing arrays, but it is an
overkill for primitive values such as =false=.

Finally, we expect ~actualIsEmptyCollectionValue~ not to be true.  The ~.not~
inverses the next comparison.  It matches the expectation with the inverse of
~toBe(true)~ with =false=.  Notice that ~toBe(false)~ and ~not.toBe(true)~
produce the same result.

Only when all three expectations are met does this spec pass.

So far we've tested the utility modules, but how do you test the React
components with Jest?  Let's find out next.
** Testing React Components

Just like with utility modules, creating tests for React components starts with
creating the ~__tests__~ directory.  Navigate to
~<dir>/snapterest/source/components/~ and create the ~__tests__~ directory.

#+CINDEX:@file{Header-test.js} file
#+CINDEX:test @file{Header} component
The first React component that we'll test will be our ~Header~ component.
Create the ~Header-test.js~ in the
~<dir>/snapterest/source/components/__tests__~ directory.

#+CAPTION[<Header-test File>]:The ~Header-test.js~ File
#+NAME:Header-test file
#+BEGIN_SRC js :tangle snapterest/source/components/__tests__/Header-test.js :mkdirp yes :eval no
jest.dontMock('../Header.react');

describe('Header component', function () {

    it('renders provided header text', function () {

        var React = require('react');
        var ReactDOM = require('react-dom');
        var TestUtils = require('react-addons-test-utils');
        var Header = require('../Header.react');

        var header = TestUtils.renderIntoDocument(
            <Header text="Testing..." />
        );

        var actualHeaderText = ReactDOM.findDomNode(header).textContent;

        expect(actualHeaderText).toBe('Testing...');

        var defaultHeader = TestUtils.renderIntoDocument(
            <Header />
        );

        var actualDefaultHeaderText = ReactDOM.findDomNode(defaultHeader).textContent;

        expect(actualDefaultHeaderText).toBe('Default header');
    });
});
#+END_SRC

By now you can recognize the structure of our test files.  First, we tell Jest
not to mock the ~Header~ component.  Then we define our test suite, and we give
it a name, =Header component=.  Our test suite has one spec name =renders
provided header text=.  As the name suggests, it tests whether our ~Header~
component renders the provided header text.  The implementation of that spec
has a number of new things that we'll discuss.

*** Importing React and TestUtils and Header

#+CINDEX:@file{react-addons-test-utils}
#+CINDEX:@file{TestUtils}
First, we import React and ReactDOM.  Then we import one of the React add-ons,
~react-addons-test-utils~.  ~TestUtils~ helps you test the React components
with any test framework that you choose.  Naturally, it works great with Jest.
Let's install it:

#+NAME:install react-addons-test-utils
#+BEGIN_SRC sh :dir snapterest :results output :exports both
yarn add --dev react-addons-test-utils
#+END_SRC

Next, in order to test our ~Header~ component, we need to import it also.

*** Render the ~Header~ Component to the DOM and Get Its Text Content

#+CINDEX:@code{renderIntoDocument()} function
#+CINDEX:@code{text} property
Our next task is to render the ~Header~ component to the DOM.  The ~TestUtils~
add-on has a helper ~renderIntoDocument()~ function that does exactly this.  We
pass the React ~Header~ component instance to the ~renderIntoDocument()~
function as a parameter.  Notice that in this case, our ~Header~ component
instance has a =text= property.  ~renderIntoDocument()~ returns a reference to
that component.

#+CINDEX:text content of @file{Header} componenet
Now we have a reference to our ~Header~ component that is rendered to the DOM.
Our next task is to check what header text it rendered.  This means that we
need to perform the following steps:

1. Find the conmponent's DOM node;
2. Get the DOM node's text content.


#+CINDEX:@code{findDOMNode()} method
#+CINDEX:@code{textContent} property
Do you remember what method React provides us to find the component's DOM node?
Did you say ~ReactDOM.findDOMNode()~?  We pass ~header~ to
~ReactDOM.findDOMNode()~ as a parameter.  As a result, ~ReactDOM.findDOMNode()~
returns a DOM node element.  Now we can access its =textContent= property.  The
value of the =textContent= property becomes the actual header text.

*** Create Expectations and Test

#+CINDEX:expectation, create
The final step is to create an expectation and match it with the expected
text.  We're expecting =Testing...= to be rendered as a DOM node text.

Now we can test that the provided header text to the ~Header~ component
instance is rendered to the DOM.

*** Creating a Second Instance Without a Text Property

What happens when we create the ~Header~ component instance without providing
any header text?

#+CINDEX:default @file{Header}
Let's find this out by rendering another instance of the ~Header~ component to
the DOM, only this time without giving it any =text= property.  We'll call this
component reference ~defaultHeader~.  Let's find the ~defaultHeader~
component's DOM node element and access its =textContent= property.  This will
be our actual header text rendered by default by a ~Header~ component.

Finally, we create an expectation and match this with the expected text.  In
this case, ~actualDefaultHeaderText~ must be equal to =Default header=.

*** Testing React Component Behavior

#+CINDEX:behavior, testing
#+CINDEX:testing behavior
This is how you test what your React component renders.  You might be wondering
how to test the behavior of your React component.  That's what we'll discuss
next.

{{{heading(The ~Button-test~ Test File)}}}

#+CINDEX:@file{Button-test.js} test file
Create the ~Button-test.js~ file in the
~<dir>/snapterest/source/components/__tests__/~ directory.

#+CAPTION[<Button-test.js File>]:The ~Button-test.js~ File
#+NAME:Button-test file
#+BEGIN_SRC js :tangle snapterest/source/components/__tests__/Button-test.js :mkdirp yes :eval no
jest.dontMock('../Button.react');

describe('Button component', function () {
    it('calls handler function on click', function () {
        var React = require('react');
        var TestUtils = require('react-addons-test-utils');
        var Button = require('../Button.react');
        var handleClick = jest.genMockFunction();

        var button = TestUtils.renderIntoDocument(
            <Button handleClick={handleClick} />
        );

        var buttonInstance = TestUtils.findRenderedDOMComponentWithTag(button, 'button');

        TestUtils.Simulate.click(buttonInstance);

        expect(handleClick).toBeCalled();

        var numberOfCallsMadeIntoMockFunction = handleClick.mock.calls.length;

        expect(numberOfCallsMadeIntoMockFunction).toBe(1);
    });
});
#+END_SRC

#+CINDEX:test the @file{Button} component
#+CINDEX:test event handler function
The ~Button-test.js~ file will test our ~Button~ component, and specifically,
check whether it triggers the event handler function when you click on it.
Without further ado, let's focus on the =calls handler function on click= spec
implementation.

{{{subheading(Imports)}}}

First, we're importing React with the add-ons module and our ~Button~
component.  As usual, we tell Jest not to mock the ~Button~ component.

*** Implementing the ~Button-test~ Spec

Before we continue with implementing our spec, let's talk about how we're going
to implement it.  The plan is to:

   #+CINDEX:mock function
1. Generate a mock function;

2. Render the ~Button~ component instance with our mock function that imitates
   a click handler;

3. Find the instance of our rendered ~Button~ component;

   #+CINDEX:simulate click event
4. Simulate a click event on that component instance;

5. Check whether a click event handler function was triggered;

6. Check whether our mock function was called exactly once.


#+CINDEX:@code{genMockFunction()} function
#+CINDEX:mock function
Generate a mock function using the ~genMockFunction()~ function.  This function
returns the newly generated Jest mock function, which we name ~handleClick~.

Next, we render the instance of our ~Button~ component to the DOM.  This
~Button~ component instance receives our mock ~handleClick~ function as a
property.

#+CINDEX:@code{button} tag
#+CINDEX:@code{findRenderedDOMComponentWithTag()} method
Then we find the ~Button~ component instance rendered to the DOM.  The
~TestUtils.findRenderedDOMComponentWithTag()~ method finds one instance of the
~Button~ component that is rendered as a ~button~ tag.  We store that instance
in the ~buttonInstance~ variable.

#+CINDEX:simulate click event
#+CINDEX:@code{Simulate.click()} method
#+CINDEX:@code{TestUtils.Simulate} event methods
Next, we simulate a click on that component instance using
~TestUtils.Simulate.click()~ method, which simulates an event dispatch on a DOM
node.  For our purposes, we need to simulate a click event dispatch.  For this,
we need to call the above method and pass the ~buttonInstance~ as a DOM node
element.  ~TestUtils.Simulate~ provides an event method such as ~click()~ for
all events supported by React.

*** Counting Events

#+CINDEX:count events
#+CINDEX:@code{toBeCalled()} function
Finally, we create an expectation, ~expect(handleClick).toBeCalled()~.  We
expect our ~handleClick~ mock function to be called at least once during our
test.

#+CINDEX:@code{mock} property
#+CINDEX:@code{mock.calls} property
#+CINDEX:@code{calls} property on @code{mock}
What we also want to check is whether it's called exactly once.  How do we
check the number of calls made into our ~handleClick~ mock function?  All the
Jest mock functions have a special =mock= property that stores all the data
about how the mock function was called.  We'll take a look at our ~handleClick~
mock function's =mock= property to find out how many times ~handleClick~ was
called: ~mock.calls.length~.  The =mock= property has the =calls= property,
which is an array that represents all the calls that have been made into our
~handleClick~ mock function.  The length of that array will be the number of
calls made into ~handleClick~.  We store this number in the
~numberOfCallsMadeIntoMockFunction~ variable and then create another
expectation: ~toBe(1)~.  We expect the number of calls made into our mock
function to be exactly 1.

*** Adding a Babel Preprocessor

#+CINDEX:JSX and Jest
#+CINDEX:Jest and JSX
#+CINDEX:preprocessor, Babel and Jest
#+CINDEX:@file{babel-jst} module
#+CINDEX:@code{jest} property, @file{package.json}
#+CINDEX:@file{package.json}, @code{jest} property
Right now, we've finished creating our tests.  However, we can't run them yet.
We're testing the React components written in the JSX syntax, but Jest doesn't
understant the JSX syntax.  So, if you run the {{{command(npm test)}}} command
now, both the component tests will fail and report =SyntaxError=.  What we need
to do is to configure Jest in order to use a preprocessor provided by the
~babel-jest~ module.  Add the ~jest~ property to your
~<dir>/snapterest/package.json~ file.[fn::Updated the property per Jest's
warning]

#+BEGIN_EXAMPLE
jest = {
    "transform": {".*": "<rootDir>/node_modules/babel-jest"},
    "unmockedModulePathPatterns": [ "<rootDir>/node_modules/react" ]
};
#+END_EXAMPLE

#+CAPTION[<jest-preprocessor>]:Adding the Babel Proprocessor to Jest
#+NAME:add babel preprocessor for jest to package.json
#+HEADER: :results output
#+HEADER: :exports both
#+HEADER: :dir snapterest
#+BEGIN_SRC js
var fs = require('fs');
var p = JSON.parse(fs.readFileSync('package.json', 'utf8'));
p.jest = {
    "transform": {".*": "<rootDir>/node_modules/babel-jest"},
    "unmockedModulePathPatterns": [ "<rootDir>/node_modules/react" ]
};
p = JSON.stringify(p,null,2);
fs.writeFileSync('package.json', p);
console.log(p);
#+END_SRC


Install ~babel-jest~:

#+NAME:install babel-jest
#+BEGIN_SRC sh :dir snapterest :results output :exports both
yarn add --dev babel-jest
#+END_SRC

#+CINDEX:@code{unmockedModulePathPatterns}
If you are curious about what ~unmockedModulePathPatterns~ does, then go to
https://facebook.github.io/jest/docs/api.html#config-unmockedmodulepathpatterns-array-string.

*** Testing React Components

Now it's time to run all our tests.  Navigate to ~<dir>/snapterest/~ and run
the command:

[[shell:(cd%20snapterest;%20yarn%20test;)][yarn test]]

All your test suites should PASS.

** Summary

Now you know how to create the React components and unit test them.

In this chapter you learned the essentials of Jest; the unit testing framework
from Facebook that works well with React.  We discussed the test suits, specs,
expectations, and matchers.  We created mock and simulated click events.

In the next chapter we'll learn the essentials of the Flux architecturem, and
how to improve the maintainability of our React application.

* Supercharge Your React Architecture With Flux

#+CINDEX:development process, stop
The process of building a web application has one quality that somewhat mirrors
the process of evolution of life itself: it never ends.  Unlike building a
bridge, building a web application has no natural state that represents the end
of the development process.  It's up to you or your team to decide when you
should stop the development process and release what you've already built.

In this book, we have reached the point at which we can stop developing
Snapterest.  We now have a small React.js application with basic functionality
that simply works.

Isn't that enough?

#+CINDEX:maintain, web application
Not exactly.  Earlier in this book, we discussed how the process of maintaining
your web applications is much more expensive in terms of time and effort than
the process of developing it.  If we choose to finish developing Snapterest at
its current state, we'll also choose to start the process of maintaining it.

Are we ready for maintaining Snapterest?  Do we know if its current state will
allow us to introduce a new functionality later on without any significant code
refactoring?

** Analyzing Your Web Application's Architecture

#+CINDEX:architecture, web application
To answer these questions, let's zoom away from the implementation details and
explore our application's architecture:

- The ~app.js~ file renders our ~Application~ component
- The ~Application~ component manages a collection of tweets and renders our
  ~Stream~ and ~Collection~ components
- The ~Stream~ component receives the new tweets from the
  ~SnapkiteStreamClient~ library and renders the ~StreamTweet~ and ~Header~
  components
- The ~Collection~ component renders the ~CollectionControls~ and ~TweetList~
  components


#+CINDEX:data flow
Stop right there.  Can you tell how data flows inside our application?  Do you
know where it enters our application?  How does a new tweet end up in our
collection?  Let's examine our data flow more closely:

{{{subheading(How Data Flows)}}}

1. We use the ~SnapkiteStreamClient~ library to receive a new tweet inside a
   ~Stream~ componnent.
2. This new tweet is then passed from ~Stream~ to the ~StreamTweet~ component.
3. The ~StreamTweet~ component passes it to the ~Tweet~ component, which
   renders the tweet image.
4. A user clicks on that tweet image to add it to its collection.
5. The ~Tweet~ component passes the ~tweet~ object to the ~StreamTweet~
   component via the ~handleImageClick(tweet)~ callback function.
6. The ~StreamTweet~ component passes that ~tweet~ object to the ~Stream~
   component via the ~onAddTweetToCollection(tweet)~ callback function.
7. The ~Stream~ component passes that ~tweet~ object to the ~Application~
   component via the ~onAddTweetToCollection(tweet)~ callback function.
8. The ~Application~ component adds ~tweet~ to the ~collectionTweets~ object
   and updates its state.
9. The state update triggers the ~Application~ component to re-render, which in
   turn re-renders the ~Collection~ component with an updated collection of
   tweets.
10. Then, the child components of the ~Collection~ component can mutate our
    collection of tweets as well.


Do you feel confused?  Can you rely on this architecture in the long run?  Do
you think it's easily maintainable?  I don't think so.

*** Identifying the Key Problems with the Architecture

Let's identify the key problems with our current architecture.  We can see that
the new data enters our React application via the ~Stream~ component.  It then
travels all the way down to the ~Tweet~ component in the component hierarchy.
Then it travels all the way up to the ~Application~ component, where it's
stored and managed.

#+CINDEX:store data
#+CINDEX:data store
Why do we store and manage our collection tweets in the ~Application~
component?  Because ~Application~ is a parent component for two other
components: ~Stream~ and ~Collection~.  Both of them need to be able to mutate
our collection tweets.  In order to accommodate this, our ~Application~
component needs to pass callback functions to both the components:

- The ~Stream~ component ::
     : Stream onAddTweetToCollection={this.addTweetToCollection} />

- The ~Collection~ component ::
     : <Collection
     :    tweets={this.state.collectionTweets}
     :    onRemoveTweetFromCollection={this.removeTweetFromCollection}
     :    onRemoveAllTweetsFromCollection={this.removeAllTweetsFromCollection}
     : />


The ~Stream~ component gets the ~onAddTweetToCollection()~ method to add a
tweet to the collection.  The ~Collection~ component gets the
~onRemoveTweetFromCollection()~ method to remove a tweet from the collection,
and the ~onRemoveAllTweetsFromCollection()~ methods to remove all the tweets
from the collection.

These callback methods are then propagated down to the component hierarchy
until they reach some component that actually calls them.  In our application,
the ~onAddTweetToCollection()~ method is only called in the ~Tweet~ component.
Let's take a look at how many times it needs to be passed from one component to
another before it can be called ion a ~Tweet~ component:


~onAddTweetToCollection()~ is not used in the ~Stream~ and ~StreamTweet~
components, yet both of them get it as a property for the purpose of passing it
down to their child components.

*** A Maintenance Nightmare in the Making

Snapterest is a small React applicationm, so this problem is reather an
inconvenience, but later on, if you decide to add new features, this
inconvience will quickly become a maintenance nightmare:


To prevent this from happening, we're going to solve two problems:

1. We'll change hos the new data enters our application
2. We'll change how the components get and set data


We'll rethink how data flows inside our application with the help of Flux.

** Understanding Flux

#+CINDEX:Flux
#+CINDEX:scalable client-side applications, how to build
{{{dfn(Flux)}}} ([[*Flux][Flux]]) is the application architecture from Facebook that
complements React.  It's not a framework or a library, but rather a solution to
a common problem: how to build scalable client-side applications.

#+CINDEX:data flow, single direction
With the Flux architecture, we can rethink how data flows inside our
application.  Flux makes sure that all our data flows only in a /single
direction/.  This helps us reason about how our application works, regardless
of how small or large it is.  With Flux, we can add a new functionality without
exploding our application's complexity.

#+CINDEX:one-way data flow
You might have noticed that both React and Flux share the same core concept:
one-way data flow.  That's why they naturally work well together.  We know how
data flows inside a React component, but how does Flux implement the one-way
data flow?

{{{heading(The Logical Entities of Flux)}}}

#+CINDEX:logical entities, Flux
#+CINDEX:Action
#+CINDEX:Dispatcher
#+CINDEX:Stores
#+CINDEX:Views
With Flux, we separate the concerns of our application into four logical
entities:

- Actions
- Dispatcher
- Stores
- Views


{{{subheading(Actions in Flux)}}}

#+CINDEX:@code{type} property, of action object
{{{dfn(Actions)}}} are /objects/ that we create when our application's state
changes.  For example, when our application receives a new tweet, we create a
new action.  An action object has a =type= property that identifies what action
it is and any other properties that our application needs to transition to a
new state.

Here is an example of an /action/ object:

#+CAPTION:An example of a Flux /action/ object
#+NAME:example-action
#+BEGIN_SRC js :eval no
var action = {
    type: 'receive_tweet',
    tweet: tweet
};
#+END_SRC

This is an action of type =receive_tweet=, and it has the =tweet= property,
which is a new tweet object that our application has received.  You can guess
in which case this action is created by looking at its type.  For each new
tweet that our application receives, it creates a =receive_tweet= action.

{{{subheading(Dispatcher and Store in Flux)}}}

Where does this action go?  What part of our application gets this action?
Actions are /dispatched/ to *stores*.

#+CINDEX:store
#+CINDEX:dispatch
{{{dfn(Stores)}}} are responsible for managing an application's data.  They
provide methods for accessing that data, but not for changing it.  If you want
to change data in stores, you have to /create and dispatch an action./

#+CINDEX:dispatcher
We know how to create an action, but how do we dispatch it?  You can use a
dispatcher for this.  The {{{dfn(dispatcher)}}} is responsible for
/dispatching/ all the actions to all stores:

  #+CINDEX:register, store with dispatcher
- It stores register with a dispatcher.  They provide a callback function.
- All actions are dispatched by a dispatcher to all the stores that are
  registered with it.


#+CINDEX:data flow in Flux
This is how our data flow works:



The dispatcher plays a role of a central element in our data flow.  All actions
are dispatched by it.  Stores register with it.  All the actions are dispatched
synchronously.  You can't dispatch an action in the middle of the previous
action dispatch.  No action can skip the dispatcher in the Flux architecture.
** Creating a Dispatcher

Now let's implement this data flow.  We'll start by creating a dispatcher
first.  Facebook offers us its implementation of a dispatcher that we can
reuse.  Let's take advantage of this.

1. Navigate to the ~<dir>/snapterest/~ directory and run the following command:
   : npm install --save flux

   The ~flux~ module comes with a ~Dispatcher~ method that we'll be reusing.

2. Next, create a new folder called ~dispatcher~ in our project's
   ~<dir>/snapterest/source/dispatcher/~ directory.  Now create the
   ~AppDispatcher.js~ file in it:

#+BEGIN_SRC js :tangle snapterest/source/dispatcher :mkdirp yes :eval no
var Dispatcher = require('flux').Dispatcher;
module.exports = new Dispatcher();
#+END_SRC

First, we import ~Dispatcher~ provided by Facebook; then create, and export a
new instance of it.  Now we can use this instance in our application.

Next, we need a convenient way of creating and dispatching actions.  For each
action, let's create a function that creates and dispatches that action.  These
functions will be our action creators.

** Creating an Action Creator

#+CINDEX:@code{actions} directory
Let's create a new folder called ~actions~ in our project's
~<dir>/snapterest/source/~ directory.  Then, create the
~TweetActionCreators.js~ file in it.

#+CINDEX:@code{TweetActionCreators.js} file
#+CAPTION[<TweetActionCreators Module>]:The ~TweetActionCreators~ Module
#+NAME:TweetActionCreators module
#+BEGIN_SRC js :tangle snapterest/source/actions/TweetActionCreators.js :mkdirp yes :eval no
var AppDispatcher = require('../dispatcher/AppDispatcher');

function receiveTweet(tweet) {
    var action = {
        type: 'receive_tweet',
        tweet: tweet
    };

    AppDispatcher.dispatch(action);
}

module.exports = {
    receiveTweet: receiveTweet
};
#+END_SRC

#+CINDEX:action creator
#+CINDEX:dispatcher
#+CINDEX:@code{receiveTweet()} method
#+CINDEX:@code{action} object
#+CINDEX:@code{type} property of @code{action} object
#+CINDEX:@code{receive_tweet} type property
Our action creators will need a dispatcher to dispatch the actions.  We will
import ~AppDispatcher~ that we created previously.  Then we create our first
action creator ~receiveTweet()~.  This method takes the ~tweet~ object as an
argument and creates the =action= object with a =type= property set to
=receive_tweet=.  It also adds the =tweet= object to the =action= object, and
now every store will receive this =tweet= object.

#+CINDEX:@code{dispatch()} method of @code{AppDispatcher} object
The ~receiveTweet()~ action creator dispatches our =action= object by calling
the ~dispatch()~ method on the =AppDispatcher= object.  The ~dispatch()~ method
dispatches the =action= object to all the stores registered with the
=AppDispatcher= dispatcher.

So far, we've created =AppDispatcher= and ~TweetActionCreators~.  Next, let's
create our first store.

** Creating a Store

#+CINDEX:stores in Flux, create
#+CINDEX:data for React components, in stores
Stores manage data in our Flux architecture.  They provide that data to the
React components.  We're going to create a simple store that manages a new
tweet that our application receives from Twitter.

#+CINDEX:@code{stores} directory
Create a new folder called ~stores~ in our project's ~<dir>/snapterest/source/~
directory, then create the ~TweetStore.js~ file in it.

#+CINDEX:@code{TweetStore.js} file
#+CAPTION[<TweetStore Module>]:The ~TweetStore~ Module
#+NAME:TweetStore module
#+HEADER: :mkdirp yes :eval no
#+BEGIN_SRC js :tangle snapterest/source/stores/TweetStore.js
var AppDispatcher = require('../dispatcher/AppDispatcher');
var EventEmitter = require('events').EventEmitter;
var assign = require('object-assign');

var tweet = null;

function setTweet (receivedTweet) {
    tweet = receivedTweet;
}

function emitChange () {
    TweetStore.emit('change');
}

var TweetStore = assign( {}, EventEmitter.prototype, {
    addChangeListener: function (callback) {
        this.removeListener('change', callback);
    },

    getTweet: function () {
        return tweet;
    }
});

function handleAction (action) {
    if (action.type === 'receive_tweet') {
        setTweet(action.tweet);
        emitChange();
    }
}

TweetStore.dispatchToken = AppDispatcher.register(handleAction);

module.exports = TweetStore;
#+END_SRC

*** The Four Logical Parts to Implementing a Simple Store

#+CINDEX:store parts
The ~TweetStore.js~ file implements a simple store.  We can break it into four
logical parts:

- Importing dependency modules and creating private data and methods.
- Creating the =TweetStore= object with public methods.
- Creating an action handler and registering a store with a dispatcher.
- Assigning ~dispatchToken~ to our =TweetStore= object and exporting it.


**** I. Importing Dependencies and Creating Private Data and Methods

#+CINDEX:register with a dispatcher
#+CINDEX:@code{AppDispatcher} module
#+CINDEX:@code{EventEmitter} class
#+CINDEX:event listeners, add and remove
In the first logical part of our store, we're simply importing the dependency
modules that our store needs.  Because our store will need to register with a
dispatcher, we import the ~AppDispatcher~ module.  Next, we import the
~EventEmitter~ class to be able to add and remove event listeners from our
store.

#+CINDEX:@code{object-assign} module
Finally, we import the ~object-assign~ module that copies the properties from
multiple source objects to a single target object.  We need to install this
module:

Once we import all the dependencies, we then define the data that our store
manages, a ~tweet~.  ~TweetStore~ manages a single tweet object that we
initially set to =null= to identify that we didn't receive the new tweet yet.

Next, we create two private methods, ~setTweet()~ and ~emitChange()~.  The
~setTweet()~ method updates ~tweet~ with a =receivedTweet= object.  The
~emitChange()~ method emts the =change= event on the =TweetStore= object.
These methods are private to the ~TweetStore~ module and not accessible outside
it.

**** II. Creating the =TweetStore= Object with Public Methods

#+CINDEX:@code{TweetStore} object, create
#+CINDEX:events
#+CINDEX:@code{change} event
#+CINDEX:event listener
#+CINDEX:@code{addChangeListener()} method
#+CINDEX:@code{removeChangeListener()} method
The second logical part of the ~TweetStore.js~ file is creeating the
=TweetStore= object.  We want the store to be able to notify other parts of the
application when it changes its data.  We'll use /events/ for this.  Whenever
our store updates its data, it emits the =change= event.  Anyone interested in
data changes can listen for this =change= event.  They need to add their event
listener function that our store will trigger on every =change= event.  For
this, our store defines the ~addChangeListener()~ method that adds the event
listener, which listens to the =change= event, and the ~removeChangeListener()~
method that removes the =change= event listener.

#+CINDEX:@code{EventEmitter.prototype} methods
#+CINDEX:@code{assign()} function
~addChangeListener()~ and ~removeChangeListener()~ depend on methods provided
by the ~EventEmitter.prototype~ object.  So we need to copy the methods from
the ~EventEmitter.prototype~ object to our =TweetStore= object.  That's what
the ~assign()~ function does.  It copies the properties owned by
=sourceObject1= and =sourceObject2= to =targetObject= and then returns
=targetObject=.

In our case, =sourceObject1= is ~EventEmitter.prototype~, and =sourceObject2=
is an object literal that defines our store's methods.  ~assign()~ returns
=targetObject= with the properties copied from all the source objects.  That's
what our =TweetStore= object is.

Have you noticed that we define the ~getTweet()~ method as a method of our
=TweetStore= object, whereas we don't do that with the ~setTweet()~ method?
Why is that?

Later on, we'll export the =TweetStore= object, which means that all its
properties will be available for other parts of our application to use.  We
want them to be able to get the data from =TweetStore=, but not update that
data directly by calling ~setTweet()~.  Instead, the only way to update data in
any store is to create an action and dispatch it using a dispacher to stores
that have registered with that dispatcher.  When the store gets that action, it
can decide how to update its data.

This is a very important aspect of Flux architecture.  Stores are in full
control of managing their data.  They only allow other parts in our application
to read that data, but never write to it directly.  Only actions should mutate
data in stores.

**** III. Creating an Action Handler and Registering a Store

#+CINDEX:action handler, create
#+CINDEX:register store with dispatcher
The third logical part of the ~TweetStore.js~ file is creating an action
handler and registering the store with a dispatcher.

#+CINDEX:@code{handleAction()} function
First, we create the action handler function, ~handleAction()~.  This function
takes an =action= object as a parameter and checks its type property.  In Flux,
all stores get all the actions, but not all stores are interested in all the
actions, so each store must decide what actions its interested in.  For this, a
store must check for the action type.  In our =TweetStore= store, we check
whether the action thype is =receive_tweet=, mwhich mneans that our application
has received a new tweet.  If that's the case, then our =TweetStore= calls its
private ~setTweet()~ function to update the =tweet= object with a new one that
comes from the =action= object, that is, =action.tweet=.  When the store
changes its data, it needs to tell everyone who is interested in the data
change.  For this, it calls its private ~emitChange()~ function that emits the
=change= event and triggers all the event listeners created by other parts in
our application.

#+CINDEX:register store with dispatcher
#+CINDEX:@code{register()} method
Our next task is to register the =TweetStore= with a dispatcher.  To register a
store with a dispatcher, you need to call a dispatcher's ~register()~ method
and pass the store's action handler function to it as a callback function.
Whenever the dispatcher dispatches an action, it calls that callback function
and passes the action object to it.

#+CINDEX:token, from registration
We call the ~register()~ method of ~AppDispatcher~, and we pass the
~handleAction()~ function to that method.  The ~register()~ method returns a
/token/ that identifies =TweetStore=, and we can use it in other methods of
~AppDispatcher~.  We also save that token as a property of our =TweetStore=
object, =TweetStore.dispatchToken=.

**** IV. Exporting the =TweetStore= Object

The fourth logical part of the ~TweetStore.js~ file is exporting the
=TweetStore= object.

*** Summary of Creating Stores

That's how you create a simple store.  Now, when we have implemented our first
action creator, dispatcher, and store, let's revisit the Flux architecture and
take a look at a bigger picture of how it works:

1. The stores register themselves with a dispatcher.
2. Action creators create and dispatch actions to the stores via a dispatcher.
3. Stores check for relevant actions and change their data accordingly.
4. Stores notify everyone who is listening about the data change.


Well that makes sense, you may say, but what triggers action creators?  Who is
listening to store updates?  These are very good questions to ask.  And the
answers asre awaiting you in our next chapter.

** Summary

In this chapter, we analyzed our React application's architecture.  We learned
about the core concepts behind the Flux architecture, and implemented a
dispatcher, action creator, and a store.  In the next chapter, we'll integrate
them into our React application and get its architecture ready for a
maintenance paradise.

* Prepare Your React Application for Painless Maintenance with Flux

The reason why we decided to implement the Flux architecture in our React
application is that we wanted to have a data flow that is easier to maintain.
In the previous chapter, we implemented =AppDispatcher=, =TweetActionCreators=,
and =TweetStore=.  Let's quickly recap what they are used for:

- =TweetActionCreators= creates and dispatches the actions
- =AppDispatcher= dispatches all the actions to all the stores
- =TweetStore= stores and manages the application data


The only missing parts in our data flow are bits of functionality that are as
follows:

- Use =TweetActionCreators= to create the actions and start the data flow
- Use =TweetStore= to get data


#+CINDEX:refactor app for Flux, how
Here are some important questions to ask: Where in the application does the
data flow start?  What is our data?  If we answer these questions, we will
understand where to start refactoring our application to adapt to the Flux
architecture.

#+CINDEX:data flow, begins with tweets
#+CINDEX:new tweets, @file{Stream} component
Snapterest allows users to receive and collect the latest tweets.  The only
data that our application is concerned with is tweets, so our data flow begins
with receiving the new tweets.  At the moment, what part of our application is
responsible for receiving new tweets?  You might remember that our ~Stream~
component has the following ~componentDidMount()~ method
([[SnapkiteStreamClient.initializeStream][SnapkiteStreamClient.initializeStream]]):

#+CINDEX:@code{SnapkiteStreamClient.initializeStream()} method
#+CINDEX:@code{initializeStream()} method of @file{SnapkiteStreamClient}
#+BEGIN_SRC js :eval no
componentDidMount: function () {
    SnapkiteStreamClient.initalizeStream(this.handleNewTweet);
}
#+END_SRC

#+CINDEX:single responsibility principle, violation
Yes, currently, we initiate a stream of new tweets after we render the ~Stream~
component.  ``Wait,'' you might say, ``didn't we learn that React components
should only be concerned with rendering the user interface?''  You're correct.
Unfortunately, at the moment, the ~Stream~ component is responsible for two
different things:

1. Rendering the ~StreamTweet~ component
2. Initiating the data flow


#+CINDEX:decouple concerns using Flux
Clearly, it will be a potential maintenance issue in the future.  Let's
decouple these two different concerns with the help of Flux.

** Decoupling Concerns with Flux

#+CINDEX:@file{WebAPIUtils.js}
First, we'll create a new utility module called ~WebAPIUtils~.  Create
{{{file(WebAPIUtils.js)}}} in the ~<dir>/snapterest/source/utils/~ directory:

#+CINDEX:@code{WebAPIUtils} module
#+CAPTION[<WebAPIUtils Module>]:The ~WebAPIUtils~ Module for Flux
#+NAME:WebAPIUtils module
#+BEGIN_SRC js :tangle snapterest/source/utils/WebAPIUtils.js :mkdirp yes :eval no
var SnapkiteStreamClient = require('snapkite-stream-client');
var TweetActionCreators = require('../actions/TweetActionCreators');

function initializeStreamOfTweets () {
    SnapkiteStreamClient.initializeStream(TweetActionCreators.receiveTweet);
}

module.exports = {
    initializeStreamOfTweets
}
#+END_SRC

#+CINDEX:@code{SnapkiteStreamClient} library
#+CINDEX:@code{TweetActionCreators} module
In this utility module, we first import the ~SnapkiteStreamClient~ library and
~TweetActionCreators~.

#+CINDEX:@code{initializeStreamOfTweets()} method
Then, we create the ~initializeStreamOfTweets()~ method that initializes a
stream of new tweets, just like in the ~componentDidMount()~ method of the
~Stream~ component, except with one key difference: whenever
~SnapkiteStreamClient~ receives a new tweet, it calls the
~TweetActionCreators.receiveTweet~ method that passes a new tweet to it as an
argument.  Remember that the ~TweetActionCreators.receiveTweet~ function
expects to receive a =tweet= argument.  This tweet will then be dispatched as a
property of a new action object that the ~receiveTweets()~ function creates.

Then, the ~WebAPIUtils~ module exports our ~initializeStreamOfTweets()~ method.

#+CINDEX:data flow initiated in Flux architecture
Now we have a module with a method that initiates the data flow in our Flux
architecture.  Where should we imnport and call it?  Since it's decoupled from
the ~Stream~ component, and in fact, it doesn't depend on any React component
at all, we can use it even before React renders anything.  Let's use it in our
{{{file(app.js)}}} file:

#+COMMENT: <<WebAPIUtils in app.js>>
#+CAPTION:Adding ~WebAPIUtils~ to ~app.js~
#+NAME:WebAPIUtils in app.js
#+BEGIN_SRC js :eval no
var WebAPIUtils = require('./utils/WebAPIUtils');

WebAPIUtils.initializeStreamOfTweets();
#+END_SRC

#+CINDEX:@code{initializeStreamOfTweets()} method call
All that we need to do is import it and call the ~initializeStreamOfTweets()~
method.  We do this before calling React's ~render()~ method.

In fact, for the purpose of experimentation, you can remove the
~ReactDOM.render()~ line of code altogether and put a log statement in the
~TweetActionCreators.receiveTweet()~ function.  For example, run the following
code:

#+BEGIN_SRC js :eval no
function receiveTweet(tweet) {
    console.log("I've received a new tweet and now ill dispatch it together with a new action");

    var action = {
        type: 'receive_tweet',
        tweet: tweet
    };

    AppDispatcher.dispatch(action);
}
#+END_SRC

Don't forget to run the {{{command(gulp)}}} command.  Then, in your web
browser, you will see the following output:

While on your web browser's console, you will see this output:

#+BEGIN_EXAMPLE
[Snapkite Stream Client] Socket connected
I've received a new tweet and now will dispatch it together with a new action.
#+END_EXAMPLE

This log message will be printed out for each new tweet that our application
receives.  Even though we didn't render any React component, our Flux
architecture is still there:

1. Our application receives a new tweet.
2. It creates and dispatches a new action.
3. No stores have registered with the dispatcher, so there is no one to receive
   the new action; hence, nothing is happening.


#+CINDEX:Flux independent of React
Now you can clearly see how React and Flux are two separate things that don't
depend on each other at all.

#+CINDEX:@code{TweetStore}
We do want to render our React components.  After all, we've put so much effort
into creating themn over the course of the last nine chapters!  For this, we
need to put our ~TweetStore~ into action.  Can you tell where we should use it?
We should use it in a React component that needs a tweet to render itself; our
good old ~Stream~ component.

** Refactoring the ~Stream~ Component

#+CINDEX:data to React components, how
#+CINDEX:data sources, possible
Now, with the Flux architecture in place, we will rethink how our React
components get the data that they need to render.  As you know, there are
usually two sources of data for a React component:

   #+CINDEX:data from external library
   #+CINDEX:data from parent component
   #+CINDEX:data from @code{props} object
1. Calling another library; for example, in our case, calling the
   ~jQuery.ajax()~ method, or ~SnapkiteStreamComponent.initializeStream()~
2. Receiving data from a parent React component via the =props= object


#+CINDEX:data store, receive data from
#+CINDEX:refactor @file{Stream} component
We want our React components not to use any external libraries to receive
data.  Instead, from now on, they will get that same data from stores.  Keeping
this plan in mind, let's refactor our ~Stream~ component.

Here's how it looks now: [[#Stream Component][The Stream Component]]

*** Remove Components

#+CINDEX:@file{TweetStore}, import
#+CINDEX:store, import
#+CINDEX:data store, import
First, let's get rid of the ~componentDidMount()~, ~componentWillUnmount()~,
and ~handleNewTweet()~ methods, and import the =TweetStore= store.  There is
also no need to import the ~snapkite-stream-client~ module anymore.

#+NAME:Flux Stream component imports
#+BEGIN_SRC js :noweb yes :eval no
<<Stream React dependencies>>
var TweetStore = require('../stores/TweetStore');
#+END_SRC

*** Change How ~Stream~ Component Gets Initial Tweet

#+CINDEX:tweet, get initial
Next, we need to change how the ~Stream~ component gets its initial tweet.
Let's update its ~getInitialState()~ method:

#+NAME:Flux Stream.getInitialState method
#+BEGIN_SRC js :eval no
getInitialState: function () {
    return ({ tweet: TweetStore.getTweet() });
},
#+END_SRC

#+CINDEX:getters
#+CINDEX:@code{getTweet()} method
#+CINDEX:@code{TweetStore}
Code-wise, this might look like a small change, but it's significant
architectural improvement.  We are now using the ~getTweet()~ method to get
data from the =TweetStore=.   In the previous chapter, we discussed how stores
expose the public methods in Flux in order to allow other parts of our
application to get data from them.  ~getTweet()~ is an example of one of these
public methods, which are called {{{dfn(getters)}}}.

#+CINDEX:setters
You can get data from a store, but you can't set data on a store directly just
like that.  Stores have no public {{{dfn(setter)}}} methods.  They are
purposely designed with this limitation in mind so taht when you write your
application with Flux, your data can flow in one direction.  This will benefit
you hugely down the road, when you'll need to maintain your Flux application.

*** Getting Additional Tweets with ~addChangeListener()~

#+CINDEX:tweets, getting subsequent
Now we know how to get our initial tweet, but how do we get all the other new
tweets that will arrive later?  We can create a timer and call
~TweetStore.getTweet()~ repeatedly; however, this is not the best solution,
because it assumes that we don't know when =TweetStore= updates its tweet with
a new one.  However, we /do/ know that.

How?  Remember that, in the previous chapter, we implemented the following
public method on the =TweetStore= object; that is, the ~addChangeListener()~
method.  We implemented the ~removeChangeListener()~ method as well.

#+CINDEX:@code{addChangeListener()} method
That's right.  We can ask =TweetStore= to tell us when it changes its data.
For this, we need to call its ~addChangeListener()~ method and pass it a
callback function that =TweetStore= will call for each new tweet.  The question
is this: in our ~Stream~ component, where do we call the
~TweetStore.addChangeListener()~ method?

#+CINDEX:event listener for @code{change}
#+CINDEX:@code{change} event listener
Since we need to add the =change= event listener to =TweetStore= only once per
component lifecycle, it makes ~componentDidMount()~ a perfect candidate.  Add
the following ~componentDidMount()~ method to the ~Stream~ component:

#+CAPTION:Adding the ~componentDidMount()~ Method to the ~Stream~ Component
#+NAME:Flux Stream.componentDidMount method
#+BEGIN_SRC js :eval no
componentDidMount: function () {
    TweetSTore.addChangeListener(this.onTweetChange);
},
#+END_SRC

#+CINDEX:event listener, add
#+CINDEX:@code{onTweetChange()} method
We add our own =change= event listener, ~this.onTweetChange~, to =TweetStore=.
Now when =TweetStore= changes its data, it will trigger our
~this.onTweetChange()~ method.  We will create this method shortly.

*** Removing the Event Listeners Before Unmounting

#+CINDEX:event listeners, remove
Don't forget that we need to remove any event listeners before we unmount our
React component.  To to this, add the following ~componentWillUnmount()~
method to the ~Stream~ component:

#+CAPTION:Adding the ~componentWillUnmount~ Method to the ~Stream~ Component
#+NAME:Flux Stream.componentWillUnmount method
#+BEGIN_SRC js :eval no
componentWillUnmount: function () {
    TweetStore.removeChangeListener(this.onTweetChange);
},
#+END_SRC

Removing an event listener is very similar to adding it.  We call the
~TweetStore.removeChangeListener()~ method and pass our ~this.onTweetChange~
method as an argument.

*** Creating the ~onTweetChange()~ Method

#+CINDEX:@code{onTweetChange()} method
It's time to create the ~onTweetChange()~ method in our ~Stream~ component.

#+CAPTION:Creating the ~onTweetChange()~ Method of the ~Stream~ Component
#+NAME:Stream.onTweetChange method
#+BEGIN_SRC js :eval no
onTweetChange: function () {
    this.setState ({
        tweet: TweetStore.getTweet()
    });
},
#+END_SRC

#+CINDEX:@code{getTweet()} method
It updates the component's state with a new tweet stored in =TweetStore= by
using the ~TweetStore.getTweet()~ method.

*** Removing the ~onAddTweetToCollection~ Callback from ~Stream.render()~

#+CINDEX:@code{onAddTweetToCollection()} callback function
There is one final change that we need to make to our ~Stream~ component.
Later in this chapter, you'll learn to that our ~StreamTweet~ component doesn't
need the ~onAddTweetToCollection()~ callback function anymore; therefore, in
this component, we're going to change the ~return~.  Replace it with:

#+CAPTION:Changing the ~return~ of the ~Stream~ Component
#+NAME:Flux Stream.render method
#+BEGIN_SRC js :eval no
render: function () {
    var tweet = this.state.tweet;

    if (tweet) {
        return (<StreamTweet tweet={tweet} />);
    }

    return (<Header text="Waiting for public photos from Twitter..." />);
}
#+END_SRC

*** The Refactored ~Stream~ Component for Flux

#+CINDEX:@code{Stream} component refactored for Flux
Now let's take a look at our newly refactored ~Stream~ component.

#+CAPTION:The ~Stream~ Component Refactored for Flux
#+NAME:Flux Stream Component
#+HEADER: :noweb yes :mkdirp yes :eval no
#+BEGIN_SRC js :tangle snapterest/source/components/Stream.flux.react.js
<<Flux Stream component imports>>

var Stream = React.createClass({

    <<Flux Stream.getInitialState method>>

    <<Flux Stream.componentDidMount method>>

    <<Flux Stream.componentWillUnmount method>>

    <<Stream.onTweetChange method>>

    <<Flux Stream.render method>>
});

module.exports = Stream;
#+END_SRC

Let's recap to see how our ~Stream~ component always has the latest tweet:

1. We set the component's intitial tweet to the latest tweet that we get from
   =TweetStore= by using the ~getTweet()~ method.
2. Then, we listen to changes in =TweetStore=.
3. When =TweetStore= changes its tweet, we update the component's state to the
   latest tweet that we get from =TweetStore= by using the ~getTweet()~ method.
4. When the component is about to unmount, we stop listening to the changes in
   =TweetStore=.

n*** Look at the Flux Data Flow

That's how a React component interacts with a Flux store.

#+CINDEX:data flow in Flux
Before we move on to making the rest of our application Flux-strong, let's take
a look at our current data flow:

- ~app.js~: :: This receives the new tweets and calls ~TweetActionCreators~ for
               each tweet.
- ~TweetActionCreators~: :: This creates and dispatches a new action with a new tweet.
- ~AppDispatcher~: :: This dispatches all the actions to all stores.
- =TweetStore=: :: This registers with a dispatcher and emits the change event
                   on every new action received from a dispatcher.
- ~Stream.flux~: :: This listens to changes in =TweetStore=, updates the state
                    with a new tweet, and re-renders.


#+CINDEX:scale React app
Can you see how we can now scale the number of React components, action
creators, and stores, and still be able to maintain Snapterest?  With Flux, it
will always be a one-way data flow.  It will be the same mental model
regardless of how many new features we implement.  We will benefit hugely in
the long run when we need to maintain our app.

Did I mention that we're going to adapt Flux in our application even more?
Next, let's do exactly that.

** Creating ~CollectionStore~

#+CINDEX:@code{CollectionStore}, create
Not only does Snapterest store the latest tweet, but it also stores a
collection of tweets that the user creates.  Let's refactor this feature with
Flux.

First, let's create a collection store.  Navigate to the
~<dir>/snapterest/source/stores/~ directory and create the ~CollectionStore.js~
file:

#+CAPTION[<Collection.js File>]:The ~Collection.js~ File
#+NAME:CollectionStore file
#+HEADER: :mkdirp yes :noweb yes :eval no
#+BEGIN_SRC js :tangle snapterest/source/stores/CollectionStore.js
<<CollectionStore imports>>

var CHANGE_EVENT = 'change';

<<CollectionStore data and private methods>>

<<CollectionStore store>>

<<CollectionStore.handleAction func>>

<<CollectionStore.emitChange func>>

<<CollectionStore register callback>>

module.exports = CollectionStore;
#+END_SRC

The ~CollectionStore~ is a bigger store, but it has the same structure as ~TweetStore~.

*** Import Dependencies

First, we import the dependencies.

#+NAME:CollectionStore imports
#+BEGIN_SRC js :eval no
var AppDispatcher = require('../dispatcher/AppDispatcher');
var EventEmitter = require('events').EventEmitter;
var assign = require('object-assign');
#+END_SRC

#+CINDEX:@code{change} event
Then, we assign a =change= event name to the =CHANGE_EVENT= variable.

*** Define Data and Private Methods to Mutate Data

#+CINDEX:@code{CollectionStore}, private data and mutators
Then we define our data and the four private methods that mutate this data.

#+NAME:CollectionStore data and private methods
#+BEGIN_SRC js :eval no
var collectionTweets = {};
var collectionName = 'new';

function addTweetToCollection (tweet) {
    collectionTweets[tweet.id] = tweet;
}

function removeTweetFromCollection (tweetId) {
    delete collectionTweets[tweetId];
}

function removeAllTweetsFromCollection () {
    collectionTweets = {};
}

function setCollectionName (name) {
    collectionName = name;
}
#+END_SRC

#+CINDEX:store collection of tweets in object
We store a collection of tweets in an object that is initially empty, and we
also store the collection name that is initially set to =new=.  Then, we create
three private functions that mutate =collectionTweets=:

- ~addTweetToCollection()~: :: adds the =tweet= objct to the =collectionTweets=
     object
- ~removeTweetFromCollection()~: :: removes the =tweet= object from the
     =collectionTweets= object
- ~removeAllTweetsFromCollection()~: :: removes all the =tweet= objects from
     =collectionTweets= by setting it to an empty object


Next, we define one private function that mutates =collectionName= (called
~setCollectionName()~), which changes the existing collection name toa new one.

#+CINDEX:private functions
These functions are regarded as private because they are not accessible outside
=CollectionStore=; that is, you /can't/ access them using method calls.  As we
discussed earlier, this is done on purpose to enforce a one-way data flow in
your application.

#+CINDEX:change event
#+CINDEX:@code{emitChange()} function
We also create the ~emitChange()~ function that emits the =change= event:

#+NAME:CollectionStore.emitChange func
#+BEGIN_SRC js :eval no
function emitChange () {
    CollectionStore.emit(CHANGE_EVENT);
}
#+END_SRC

*** Create the =CollectionStore= Object

#+CINDEX:@code{CollectionStore} object, create
Then, we create the =CollectionStore= Object

#+NAME:CollectionStore store
#+BEGIN_SRC js :eval no
var CollectionStore = assign({}, EventEmitter.prototype, {

    addChangeListener: function (callback) {
        this.on(CHANGE_EVENT,  callback);
    },

    removeChangeListener: function (callback) {
        this.removeListener(CHANGE_EVENT, callback);
    },

    getCollectionTweets: function () {
        return collectionName;
    }
});
#+END_SRC

This is very similar to the =TweetStore= object, except for two methods:

- ~getCollectionTweets()~ returns a collection of tweets
- ~getCollectionName()~ returns the collection name


These methods are accessible outside the ~CollectionStore.js~ file, and should
be used in React components to get data from =CollectionStore=.

*** Create the ~handleAction()~ Function

#+CINDEX:@code{handleAction()} function
Next we create the ~handleAction()~ function.

#+NAME:CollectionStore.handleAction func
#+BEGIN_SRC js :eval no
function handleAction (action) {

    switch (action.type) {

        case 'add_tweet_to_collection':
          addTweetToCollection(action.tweetId);
          emitChange();
          break;

        case 'remove_tweet_from_collection':
          removeTweetFromCollection();
          emitChange();
          break;

        case 'remove_all_tweets_from_collection':
          removeAllTweetsFromCollection();
          emitChange()
          break;

        case 'set_collection_name':
          setCollectionName(action.collectionName);
          emitChange();
          break;

        default: // ... do nothing
    }
}
#+END_SRC

This function handles the actions that are dispatched by ~AppDispatcher~, but
unlike =TweetStore= in our =CollectionStore=, we can handle more than one
action.  In fact, we can handle the four actions that are related to the
collection of tweets:

- =add_tweet_to_collection= adds a tweet to a collection
- =remove_tweet_from_collection= removes a tweet from a collection
- =remove_all_tweets_from_collection= removes all the tweets from a collection
- =set_collection_name= sets a collection name


Remember that all the stores receive all the actions, so =CollectionStore= will
receive the =receive_tweet= action as well, but we simply ignore it in this
store, just like =TweetStore= ignores all of the above actions.

*** Register the ~handleAction~ Callback with ~AppDispatcher~ and Export Module

#+CINDEX:register action callback with dispatcher
Next, we register the ~handleAction~ callback with ~AppDispatcher~, and save
~dispatchToken~ in the =CollectionStore= object.

#+NAME:CollectionStore register callback
#+BEGIN_SRC js :eval no
CollectionStore.dispatchToken = AppDispatcher.register(handleAction);
#+END_SRC

Finally, we export =CollectionStore= as a module.

Now that we have the collection store ready, let's create action creator
functions next.

** Creating ~CollectionActionCreators~

#+CINDEX:@code{CollectionActionCreators}, create
Navigate to ~<dir>/snapterest/source/actions/~ and create the
~CollectionActionCreators.js~ file:

#+CAPTION[<CollectionActionCreators.js>]:The ~CollectionActionCreators~ File
#+NAME:CollectionActionCreators file
#+HEADER: :mkdirp yes :noweb yes :eval no
#+BEGIN_SRC js :tangle snapterest/source/actions/CollectionActionCreators.js
var AppDispatcher = require('../dispatcher/AppDispatcher');

module.exports = {

    AddTweetToCollection: function (tweet) {
        var action = {
            type: 'add_tweet_to_collection',
            tweet: tweet
        };

        AppDispatcher.dispatch(action);
    },

    removeTweetFromCollection: function (tweetId) {

        var action = {
            type: 'remove_tweet_from_collection',
            tweetId: tweetId
        };

        AppDispatcher.dispatch(action);
    },

    removeAllTweetsFromCollection: function () {

        var action = {
            type: 'remove_all_tweets_from_collection'
        };

        AppDispatcher.dispatch(action);
    },

    setCollectionName: function (collectionName) {

        var action = {
            type: 'set_collection_name',
            collectionName: collectionName
        };

        AppDispatcher.dispatch(action);
    }
};
#+END_SRC

#+CINDEX:action creator function
For each action that we handle in =CollectionStore=, we have an action creator
function:

- ~addTweetToCollection()~ creates and dispatches the =add_tweet_to_collection=
  action with a new tweet
- ~removeTweetFromCollection()~ creates and dispatches the
  =remove_tweet_from_collection= action with the ID of the tweet that must be
  removed from the collection
- ~removeAllTweetsFromCollection()~ creates and dispatches the
  =remove_all_tweets_from_collection= action
- ~setCollectionName()~ creates and dispatches the =set_collection_name= action
  with a new collection name


Now that we've created both the =CollectionStor= and ~CollectionActionCreators~
modules, we can start refactoring our React components to adopt the Flux
architecture.

** Refactoring the ~Application~ Component

#+CINDEX:refactor React components, start at top
Where do we start refactoring our React components?  Let's start with the
uppermost React component in our component's hierarchy, ~Application~.

#+CINDEX:refactor @file{Application} component
At the moment, our Application component, [[Application component][Application component]], stores and
manages the collection of tweets.  Let's remove this functinality, as it's now
managed by the =CollectionStore=.  Remove these methods from the ~Application~
component:

- ~getInitialState()
- ~addTweetToCollection()
- ~removeTweetFromCollection()
- ~removeAllTweetsFromCollection()


#+CAPTION[<Flux Application Component>]:The ~Application~ Component Under Flux
#+NAME:Flux Application component
#+HEADER: :mkdirp yes :noweb yes :eval no
#+BEGIN_SRC js :tangle snapterest/source/components/Application.flux.react.js
<<Application Dependencies>>

var Application = React.createClass({
    <<Flux Application.render>>
});

module.exports = Application;
#+END_SRC

Now the ~Application~ component has only the ~render()~ method that renders the
~Stream~ and ~Collection~ components.  Since it doesn't manage the collection
of tweetsw any more, we also don't need to pass any properties to the ~Stream~
and ~Collection~ components as well.

Update the ~Application component's ~render()~ method as follows.

#+CAPTION: The ~render()~ Method of ~Application~ Under Flux
#+NAME:Flux Application.render
#+BEGIN_SRC js :noweb yes :eval no
<<Application.render start>>
                    <Stream />
<<Application.render mid>>
                    <Collection />
<<Application.render end>>
#+END_SRC

The adoption of the Flux architecture allows the ~Stream~ component to manage
the latest tweet, and the ~Collection~ component to manage the collection of
tweets, whereas the ~Application~ component doesn't need to manage anything any
more, so it becomes a container component that wraps the ~Stream~ and
~Collection~ components in the additional HTML markup.  The ~Application~
component has become much simpler, and its markup, visually, looks much cleaner
now.  This improves the maintainability.

** Refactoring the ~Collection~ Component

#+CINDEX:refactor @file{Collection} component
#+CINDEX:@file{Collection} component, refactor for Flux
Next, let's refactor our ~Collection~ component.  Replace the existing
~Collection~ component ([[Collection component][existing ~Collection~ component]]) with an updated one.


#+CAPTION[<Collection Flux Component>]:Refactored ~Collection~ Component for Flux
#+NAME:Collection Flux component
#+HEADER: :mkdirp yes :noweb yes :eval no
#+BEGIN_SRC js :tangle snapterest/source/components/Collection.flux.react.js
<<Collection imports>>
<<Collection utils imports>>

var Collection = React.createClass({

    getInitialState: function () {
        return ({ collectionTweets: CollectionStore.getCollectionTweets() });
    },

    componentDidMount: function () {
        CollectionStore.addChangeListener(this.onCollectionChange);
    },

    componentWillUnmount: function () {
        CollectionStore.removeChangeListener(this.onCollectionChange);
    },

    onCollectionChange: function () {
        this.setState({
            collectionTweets: CollectionStore.getCollectionTweets();
        });
    },

    createHtmlMarkupStringOfTweetList: function () {
        var htmlString = ReactDOMServer.renderToStaticMarkup(
            <TweetList tweets={this.state.collectionTweets} />
        );

        var htmlMarkup = {
            html: htmlString
        };

        return (JSON.stringify(htmlMarkup));
    },

    <<Collection.flux.render>>
})

module.exports = Collection;
#+END_SRC

*** Changes Made to Collection for Flux

What did we change here?  A few things.  First, we imported two new modules:

#+NAME:Collection utils imports
#+BEGIN_SRC js :eval no
var CollectionUtils = require('../utils/CollectionUtils');
var CollectionStore = require('../stores/CollectionStore');
#+END_SRC

We created the [[CollectionUtils module][~CollectionUtils~ module in Chapter 8]] and in this chapter, we're
using it.  ~CollectionStore~ is where we get our data from.

Next, you should be able to spot the familiar pattern of the four methods:

- In the ~getInitialState()~ method, we set the collection of tweets to what is
  stored in ~CollectionStore~ at that moment.  As you may recall that
  ~CollectionStore~ provides the ~getCollecionTweets()~ method to get the data
  from it.

- In the ~componentDidMount()~ method, we add the =change= event listener,
  ~this.onCollectionChange~, to ~CollectionStore~.  Whenever the collection of
  tweets is updated, ~CollectionStore~ will call our ~this.onCollectionChange~
  callback function to notify the ~Collection~ component of that change.

- In the ~componentWillUnmount()~ method, we remove the =change= event listener
  that we added to the ~componentDidMoun()~ method.

- In the ~onCollectionChange()~ method, we set the component's state to
  whatever is stored in ~CollectionStore~ at that moment in time.  Updating the
  component's state trigger's re-rendering.


The ~Collection~ component's ~render()~ method is now simpler and cleaner:

#+NAME:Collection.flux.render
#+BEGIN_SRC js :eval no
render: function () {
    var collectionTweets = this.state.collectionTweets;
    var numberOfTweetsInCollection = CollectionUtils.getNumberOfTweetsInCollection(collectionTweets);
    var htmlMarkup;

    if (numberOfTweetsInCollection > 0) {
        htmlMarkup = this.createHtmlMarkupStringOfTweetList();

        return (
            <div>
                <CollectionControls
            		numberOfTweetsInCollection={numberOfTweetsInCollection}
            		htmlMarkup={htmlMarkup}
                />

            	<TweetList tweets={collectionTweets} />

            </div>
        );
    }

    return (<Header text="Your collection is empty" />);
}
#+END_SRC

#+CINDEX:@file{CollectionUtils} module
We use the ~CollectionUtils~ module to get a number of tweets in the
collection, and we pass fewer properties to the child components:
- ~CollectionControls~
- ~TweetList~

** Refactoring the ~CollectionControls~ Component

#+CINDEX:refactor @file{CollectionControls} component
#+CINDEX:@file{CollectionControls} component, refactor for Flux
The ~CollectionControls~ component gets some major improvements as well.  Let's
take a look at the refactored version first ([[CollectionControls component][~CollectionControls~ component]]),
and then discuss what was updated and why:

#+CAPTION[<CollectionControls Flux Component>]:The Refactored ~CollectionControls~ Component
#+NAME:CollectionControls Flux component
#+HEADER: :mkdirp yes :noweb yes :eval no
#+BEGIN_SRC js :tangle snapterest/source/components/CollectionControls.react.flux.js
<<CollectionControls imports>>
<<CollectionControls additional imports>>

var CollectionControls = React.createClass({

    getInitialState: function () {
        return ({
            isEditingName: false
        });
    },

    getHeaderText: function () {
        var numberOfTweetsInCollection = this.props.numberOfTweetsInCollection;
        var text = numberOfTweetsInCollection;
        var name = CollectionStore.getCollectionName();

        if (numberOfTweetsInCollection == 1) {
            text = text + ' tweet in your';
        } else {
            text = text + ' tweets in your';
        }

        return (
            <span>
                {text} <strong>{name}</strong> collection
            </span>
        );
    },

    <<CollectionControls toggleEditCollectionName method>>

    <<CollectionControls.removeAllTweetsFromCollection>>

    render: function () {
        if (this.state.isEditingName) {
            return (
                <CollectionRenameForm
                  onCancelCollectionNameChange={this.toggleEditCollectionName}
                />
            );
        }

        return (
            <div>
                <Header text={this.getHeaderText()} />

                <Button
                  label="Rename collection"
                  handleClick={this.toggleEditCollectionName}
                />

                <Button
                  label="Empty collection"
                  handleClick={this.removeAllTweetsFromCollection}
                />
            </div>
        );
    }
});

module.exports = CollectionControls;
#+END_SRC

*** Import Additional Modules

First, we import the two additional modules:

#+NAME:CollectionControls additional imports
#+BEGIN_SRC js :eval no
var CollectionActionCreators = require('../actions/CollectionActionCreators');
var CollectionStore = require('../stores/CollectionStore');
#+END_SRC

Notice that we don't manage the collection name in this component any more.
Instead, we get it from our ~CollectionStore~.

*** Replace ~handleChangeCollectionName()~

#+CINDEX:@code{removeAllTweetsFromCollection} method
Then, we make one of the key changes.  We replace the
~handleChangeCollectionName()~ method with a new one,
~removeAllTweetsFromCollection()~:

#+NAME:CollectionControls.removeAllTweetsFromCollection
#+BEGIN_SRC js :eval no
removeAllTweetsFromCollection: function () {
    CollectionActionCreators.removeAllTweetsFromCollection();
},
#+END_SRC

The ~removeAllTweetsFromCollection()~ method is called when a user clicks on
the =Empty Collection= button.  This user action triggers the
~removeAllTweetsFromCollection()~ action creator function that creates and
dispatches the action to stores.  In turn, =CollectionStore= removes all the
tweets from the collection and emits the =change= event.

** Refactoring the ~CollectionRenameForm~ Component

#+CINDEX:refactor @file{CollectionRenameForm} component
#+CINDEX:@file{CollectionRenameForm} component, refactor for Flux
~CollectionRenameForm~ ([[CollectionRenameForm-component][CollectionRenameForm component]]) is a controlled form
component.  This means that its input value is stored in the component's state,
and the only way to update that value is to update the component's state.  It
has the initial value that it should get from =CollectionStore=, so let's make
that happen.

#+CAPTION[<CollectionRenameForm Flux Component>]:The ~CollectionRenameForm~ Component Refactored for Flux
#+NAME:CollectionRenameForm Flux component
#+HEADER: :mkdirp yes :noweb yes :eval no
#+BEGIN_SRC js :tangle snapterest/source/components/CollectionRenameForm.flux.react.js
<<CollectionRenameForm imports>>
<<CollectionRenameForm additional imports>>

var inputStyle = {
    marginRight: '5px'
};

var CollectionRenameForm = React.createClass({

     <<CollectionRenameForm.getInitialState-flux-method>>
     <<CollectionRenameForm setInputValue method>>
     <<CollectionRenameForm handleInputValueChange method>>
     <<CollectionRenameForm.handleFormSubmit flux>>
     <<CollectionRenameForm.handleFormCancel flux>>
     <<CollectionRenameForm componentDidMount method>>
     <<CollectionRenameForm render method>>
});

module.exports = CollectionRenameForm;

#+END_SRC

{{{heading(Import New Modules)}}}

First, we need to import the ~CollectionActionCreators~ and ~CollectionStore~
modules:

#+NAME:CollectionRenameForm additional imports
#+BEGIN_SRC js :eval no
var CollectionActionCreators = require('../actions/CollectionActionCreators');
var CollectionStore = require('../stores/CollectionStore');
#+END_SRC

{{{heading(Update ~getInitialState()~)}}}

Now, we need to update the ~getInitialState()~ method as follows:

#+NAME:CollectionRenameForm.getInitialState-flux-method
#+BEGIN_SRC js :eval no
getInitialState: function () {
    return ({
        inputValue: CollectionStore.getCollectionName()
    });
},
#+END_SRC

The only difference is that now we get the initial =inputValue= from
=CollectionStore=.

{{{heading(Update ~handleFormSubmit()~)}}}

Now let's update the [[CollectionRenameForm.handleFormSubmit method][~handleFormSubmit()~ method]] by using the following code:

#+NAME:CollectionRenameForm.handleFormSubmit flux
#+BEGIN_SRC js :eval no
handleFormSubmit: function (event) {
    event.preventDefault();
    var collectionName = this.state.inputValue;
    CollectionActionCreators.setCollectionName(collectionName);
    this.props.onCancelCollectionNameChange();
},
#+END_SRC

The important difference here is that when a user submits a form, we create a
new action that sets a new name in our collection store.

{{{heading(Update ~handleFormCancel()~)}}}

Finally, we need to change the source of the collection name in the
[[CollectionRenameForm handleFormCancel method][~handleFormCancel()~ method]].

#+NAME:CollectionRenameForm.handleFormCancel flux
#+BEGIN_SRC js :eval no
handleFormCancel: function (event) {
    event.preventDefault();
    var collectionName = CollectionStore.getCollectionName();
    this.setInputValue(collectionName);
    this.props.onCancelCollectionNameChange();
},
#+END_SRC

Once again, we get the collection name from a collection store.

That's all we need to change in the ~CollectionRenameForm~ component.  Let's
refactor the ~TweetList~ component next.

** Refactoring the ~TweetList~ Component

#+CINDEX:refactor @file{TweetList} component
#+CINDEX:@file{TweetList} component, refactor for Flux
The [[TweetList component][~TweetList~ component]] renders a list of tweets.  Each tweet is a ~Tweet~
component that a user can click on to remove it from a collection.  Does it
sound like it could make use of ~CollectionActionCreators~ to you?

#+CAPTION[<TweetList Flux Component>]:The ~TweetList~ Component Refactored for Flux
#+NAME:TweetList Flux component
#+HEADER: :mkdirp yes :noweb yes :eval no
#+BEGIN_SRC js :tangle snapterest/source/components/TweetList.flux.react.js
<<TweetList imports>>
<<TweetList additional import>>

<<TweetList styles>>

var TweetList = React.createClass({
    <<TweetList getListOfTweetIds method>>
    <<TweetList.getTweetElement Flux>>
    <<TweetList.removeTweetFromCollection Flux>>
    <<TweetList render method>>
});

module.exports = TweetList;
#+END_SRC

{{{heading(Adding an Import)}}}

That's right, let's add the ~CollectionActionCreators~ module to it:

#+NAME:TweetList additional import
#+BEGIN_SRC js :eval no
var CollectionActionCreators = require('../actions/CollectionActionCreators');
#+END_SRC

{{{heading(Create ~removeTweetFromCollection()~ Method)}}}

Then we create the ~removeTweetFromCollection()~ callback function that will be
called when a user clicks on a tweet image:

#+NAME:TweetList.removeTweetFromCollection Flux
#+BEGIN_SRC js :eval no
removeTweetFromCollection: function (tweet) {
    CollectionActionCreators.removeTweetFromCollection(tweet.id);
},
#+END_SRC

As you can see, it creates a new action through the
~removeTweetFromCollection()~ function by passing the tweet ID to it as an
argument.

{{{heading(Update Variable ~handleRemoveTweetFromCollection)}}}

Finally, we need to make sure that ~removeTweetFromCollection()~ is actually
called.  In the ~getTweetElement()~ method, we change the variable
~handleRemoveTweetFromCollection~ to:

#+NAME:TweetList.getTweetElement Flux
#+BEGIN_SRC js :noweb yes :exports never :eval no
<<TweetList getTweetElement method A>>
    <<variable handleRemoveTweetFromCollection Flux>>
<<TweetList getTweetElement method B>>
#+END_SRC

#+NAME:variable handleRemoveTweetFromCollection Flux
#+BEGIN_SRC js :eval no
var handleRemoveTweetFromCollection = this.removeTweetFromCollection;
#+END_SRC

We're all done for this component.  ~StreamTweet~ is next in our refactoring
journey.

** Refactoring the ~StreamTweet~ Component

#+CINDEX:refactor @file{StreamTweet} component
#+CINDEX:@file{StreamTweet} component, refactor for Flux
~StreamTweet~ ([[StreamTweet component][~StreamTweet~ component]]) renders a tweet image that a user can
click on to add it to a collection of tweets.  You might have already guessed
that we're going to create and dispatch a new action when a user clicks on that
tweet image.

#+CAPTION[<StreamTweet Flux Component>]:The ~StreamTweet~ Component Refactored for Flux
#+NAME:StreamTweet Flux component
#+HEADER: :noweb no-export :eval no
#+HEADER: :comments both
#+BEGIN_SRC js :tangl esnapterest/source/components/StreamTweet.flux.react.js :mkdirp yes
<<StreamTweet imports>>
<<StreamTweet additional import>>

var StreamTweet = React.createClass({
    // define other component lifecycle methods here

    <<getInitialState>>
    <<componentWillMount>>
    <<componentDidMount>>
    <<componentWillReceiveProps>>
    <<shouldComponentUpdate>>
    <<componentWillUpdate>>
    <<componentDidUpdate>>
    <<componentWillUnmount>>
    <<StreamTweet.addTweetToCollection flux>>

    render: function () {
        console.log('[Snapterest] StreamTweet: Running render()');

        return (
            <section>
                <Header text={this.state.headerText} />
                <<StreamTweet.render Tweet for Flux>>
            </section>
        );
    }
});

module.exports = StreamTweet;
#+END_SRC

{{{heading(Import ~CollectionActionCreators)}}}

First, we import the ~CollectionActionCreators~ module to the ~StreamTweet~
component.

#+NAME:StreamTweet additional import
#+BEGIN_SRC js :eval no
var CollectionActionCreators = require('../actions/CollectionActionCreators');
#+END_SRC

{{{heading(Add ~addTweetToCollection()~ Method)}}}

Then, we add a new ~addTweetToCollection()~ method to it:

#+NAME:StreamTweet.addTweetToCollection flux
#+BEGIN_SRC js :eval no
addTweetToCollection: function (tweet) {
    CollectionActionCreators.addTweetToCollection(tweet);
},

#+END_SRC

The ~addTweetToCollection()~ is a callback function that should be invoked when
a user clicks on a tweet image.

{{{heading(Update the ~render()~ Method)}}}

Let's take a look at this line in the ~render()~ method:

We replace it with this line of code:

<<StreamTweet.render Tweet for Flux>>
#+NAME:StreamTweet.render Tweet for Flux
#+BEGIN_SRC js :eval no
<Tweet
  tweet={this.props.tweet}
  onImageClick={this.addTweetToCollection}
/>
#+END_SRC

The ~StreamTweet~ component is done.

*** TODO Fix Tweet commands

#+CINDEX:errata, @file{StreamTweet} component
- See [[https://github.com/fedosejev/react-essentials/blob/master/updates.md#chapter-10-page-29][Errata]]
  Use these:
  : <Tweet tweet={this.props.tweet} onImageClick={this.props.onAddTweetToCollection} />
  : <Tweet tweet={this.props.tweet} onImageClick={this.addTweetToCollection} />

** Build and Go Beyond

#+CINDEX:Flux architecture
That's all the effort that is needed to integrate the Flux architecture into a
React application.  If you compare your React application without Flux and with
Flux, you'll quickly see how much easier it is to understand how your
application works when Flux is part of it.  I highly encourage you to visit the
Flux official website and learn more about it at
https://facebook.github.io/flux/.

#+CINDEX:Snapterest, build and run
#+CINDEX:build and run Snapterest
I think it's a good time to check that everything is in perfect working order.
Let's build and run Snapterest!

#+CINDEX:@command{gulp} command, run
#+CINDEX:run @command{gulp} command
Navigate to {{{file(<dir>/snapterest/)}}} and run the following command in
your terminal:
: gulp

You should see an output similar to this:
: Finished 'default' after 2.42 s

#+CINDEX:@file{Snapkite Engine}
Make sure that you're running the {{{file(Snapkite Engine)}}} application that
we installed and configured in Chapter 1.  Now, open the
{{{file(<dir>/snapterest/build/index.html)}}} in your browser.  You should see
the new tweets appearing in the left-hand side.  Click on a tweet to add it to
the collection that appears on the right-hand side.

Does it work?  Check your web browser's console for any errors.  No errors?
Congratulations!

This is the end of our journey in learning the essentials of React.js.

Wait, let's not stop here; let's continue our conversation.  If you have any
questions left unanswered; any doubts, suggestions, ideas, or comments, or if
you want to showcase your Snapterest application, then go to
https://github.com/fedosejev/react-essentials/issues and create an issue.  I'll
do my best to get back to you as soon as I can.

* React.js
:PROPERTIES:
:APPENDIX: t
:END:

A JavaScript library for building user interfaces.

- [[https://reactjs.org/][React.js Home]]

* Flux
:PROPERTIES:
:APPENDIX: t
:END:

{{{heading(APPLICATION ARCHITECTURE FOR BUILDING USER INTERFACES)}}}

{{{subheading(An application architecture for React utilizing a unidirectional data flow.)}}}

Flux is the application architecture that Facebook uses for building
client-side web applications. It complements React's composable view components
by utilizing a unidirectional data flow. It's more of a pattern rather than a
formal framework, and you can start using Flux immediately without a lot of new
code.

- [[https://facebook.github.io/flux/][Flux Home]]
- [[https://github.com/facebook/flux][Flux Github Home]]
- [[https://facebook.github.io/flux/docs/overview.html][Flux Docs]]
- [[https://facebook.github.io/flux/docs/videos.html#content][Flux Videos]]

** Getting Started

Start by looking through the guides and examples on Github. For more resources
and API docs check out [[https://facebook.github.io/flux][facebook.github.io/flux]].

#+NAME:flux-diagram.png
#+CAPTION:Flux Diagram
[[file:img/flux-diagram-white-background-25.png]]

** How Flux works

For more information on how Flux works check out the [[https://github.com/facebook/flux/blob/master/examples/flux-concepts][Flux Concepts]] guide, or
the [[https://facebook.github.io/flux/docs/in-depth-overview.html#content][In Depth Overview]].

** Flux Concepts

#+CINDEX:Flux concepts
#+CINDEX:concepts of Flux
These are the important high-level concepts and principles you should know
about when writing applications that use Flux.

{{{heading(Overview)}}}

#+CINDEX:Flux overview
#+CINDEX:overview of Flux
Flux is a pattern for managing data flow in your application. The most
important concept is that /data flows in one direction/.  As we go through this
guide we'll talk about the different pieces of a Flux application and show how
they form /unidirectional cycles/ that data can flow through.

{{{subheading(Flux Parts)}}}

- Dispatcher

- Store

- Action

- View

*** Dispatcher

#+CINDEX:Dispatcher
#+CINDEX:actions
#+CINDEX:stores
#+CINDEX:register store with dispatcher
#+CINDEX:singleton dispatcher
The {{{dfn(dispatcher)}}} receives actions and dispatches them to stores that
have registered with the dispatcher.  Every store will receive every action.
There should be only one singleton dispatcher in each application.

Example:

1. User types in title for a todo and hits enter.
2. The view captures this event and dispatches an "add-todo" action containing
   the title of the todo.
3. *Every store* will then receive this action.

*** Store

#+CINDEX:store
#+CINDEX:store, register with dispatcher
#+CINDEX:register, store with dispatcher
#+CINDEX:action
#+CINDEX:mutate data
#+CINDEX:setters
#+CINDEX:getters
#+CINDEX:@samp{change} event
A store is what holds the data of an application. Stores will register with the
application's dispatcher so that they can receive actions.  The data in a store
must only be mutated by responding to an action. There should not be any public
setters on a store, only getters.  Stores decide what actions they want to
respond to.  Every time a store's data changes it must emit a
{{{samp(change)}}} event.  There should be many stores in each application.

Examples:

1. Store receives an "add-todo" action.
2. It decides it is relevant and adds the todo to the list of things that need
   to be done today.
3. The store updates its data and then emits a "change" event.

*** Actions

#+CINDEX:actions
#+CINDEX:@samp{type} field
Actions define the internal API of your application.  They capture the ways in
which anything might interact with your application.  They are simple objects
that have a {{{samp(type)}}} field and some data.

Actions should be semantic and descriptive of the action taking place.  They
should not describe implementation details of that action. Use
{{{samp(delete-user)}}} rather than breaking it up into
{{{samp(delete-user-id)}}}, {{{samp(clear-user-data)}}},
{{{samp(refresh-credentials)}}} (or however the process works).  Remember that
all stores will receive the action and can know they need to clear the data or
refresh credentials by handling the same {{{samp(delete-user)}}} action.

Examples:

1. When a user clicks "delete" on a completed todo a single "delete-todo"
   action is dispatched:

   #+BEGIN_SRC js :eval no
  {
    type: 'delete-todo',
    todoID: '1234',
  }
   #+END_SRC

*** Views

#+CINDEX:views
#+CINDEX:subscribe to change events, view
#+CINDEX:actions, dispatched from views
Data from stores is displayed in views.  Views can use whatever framework you
want (In most examples here we will use React).  When a view uses data from a
store it must also subscribe to change events from that store.  Then when the
store emits a change the view can get the new data and re-render.  If a
component ever uses a store and does not subscribe to it then there is likely a
subtle bug waiting to be found.  Actions are typically dispatched from views as
the user interacts with parts of the application's interface.

Example:

1. The main view subscribes to the TodoStore.
2. It accesses a list of the Todos and renders them in a readable format for
   the user to interact with.
3. When a user types in the title of a new Todo and hits enter the view tells
   the Dispatcher to dispatch an action.
4. All stores receive the dispatched action.
5. The TodoStore handles the action and adds another Todo to its internal data
   structure, then emits a "change" event.
6. The main view is listening for the "change" event. It gets the event, gets
   new data from the TodoStore, and then re-renders the list of Todos in the
   user interface.

*** Flow of data

We can piece the parts of Flux above into a diagram describing how data flows
through the system.

1. Views send actions to the dispatcher.
2. The dispatcher sends actions to every store.
3. Stores send data to the views.

#+NAME:flow.png
#+CAPTION:Views get data from the stores.
[[file:img/flux-simple-f8-diagram-with-client-action-1300w-50.png]]

*** Next steps

You can start coding with the [[todo-example][flux-todomvc]] example, or head back to check out
the full list of [[*Examples][example topics]].
** Requirements

{{{subheading{EventEmitter}

#+CINDEX:EventEmitter, Flux
Flux is more of a pattern than a framework, and does not have any hard
dependencies.  However, we often use [[https://nodejs.org/api/events.html#events_class_events_eventemitter][EventEmitter]] as a basis for Stores and
[[https://github.com/facebook/react][React]] for our Views.

{{{subheading(Dispatcher)}}}

#+CINDEX:Dispatcher, Flux
The one piece of Flux not readily available elsewhere is the =Dispatcher=.
This module, along with some other utilities, is available here to complete
your Flux toolbox.

** Installing Flux

#+CINDEX:Flux, install
#+CINDEX:install Flux
#+CINDEX:@code{Flux.Dispatcher}
Flux is available as an [[https://www.npmjs.org/package/flux][npm module]], so you can add it to your ~package.json~
file or run {{{command(npm install flux)}}}. The dispatcher will be available
as ~Flux.Dispatcher~ and can be required like this:

  #+CINDEX:dispatcher API
- Take a look at the [[https://facebook.github.io/flux/docs/dispatcher.html#content][dispatcher API and some examples]].

** Building Flux from a Cloned Repo

Clone the repo and navigate into the resulting flux directory. Then run
{{{command(npm install)}}}.

#+CINDEX:Gulp, Flux
#+CINDEX:build process, Flux
This will run Gulp-based build tasks automatically and produce the file
~Flux.js~, which you can then require as a module.

#+CINDEX:Dispatcher
You could then require the Dispatcher like so:

The build process also produces de-sugared versions of the =Dispatcher= and
=invariant= modules in a ~lib~ directory, and you can require those modules
directly, copying them into whatever directory is most convenient for you. The
flux-todomvc and flux-chat example applications both do this.

** Examples

https://github.com/facebook/flux/tree/master/examples

This directory contains examples that should help get you started with
Flux. They are listed in the order you should complete them.

- [[https://github.com/facebook/flux/blob/master/examples/flux-concepts][Basic concepts (no code)]]

  These are the important high-level concepts and principles you should know
  about when writing applications that use Flux.

- [[https://github.com/facebook/flux/blob/master/examples/flux-todomvc][Start coding here]]

  <<todo-example>>This example is where you should start. It walks you through
  creating the classic TodoMVC application using a simple Flux implementation.

- [[https://github.com/facebook/flux/blob/master/examples/flux-jest][Unit Testing Stores]]

  Being able to unit test stores is critical. This example shows you how to
  write tests for the TodoMVC stores we created in an earlier example.

- [[https://github.com/facebook/flux/blob/master/examples/flux-flow][Static typing]]

  This is a very simple example that highlights how to set up Flux and Flow in
  the same project. Flow is a static-type checking tool that will help catch
  errors in your code statically. It complements Flux well since it supports
  refining the action based on a type string.

- [[https://github.com/facebook/flux/blob/master/examples/flux-logging][Add logging to Flux apps]]

  Taking advantage of the fact that a store gets every action makes it easy to
  add logging to a Flux application. Check out this quick example where we add
  a logger store to the TodoMVC app we created in an earlier example.

- [[https://github.com/facebook/flux/blob/master/examples/flux-jest-container][Unit Testing Containers]]

  Testing the container logic that connects stores to views can be tricky. This
  example shows you how to create some utilities to help mock out store data in
  order to write these kinds of tests effectively.

- [[https://github.com/facebook/flux/blob/master/examples/flux-async][Flux with async requests]]

  This is an advanced example. It pulls a lot of the concepts from previous
  examples into a single application. This implements TodoMVC where the data is
  persisted and requested through a simple server. The server simulates delays
  and errors. In the example we will handle things like optimistic updates,
  loading states, and failing API requests.

** In-Depth Overview

- [[https://facebook.github.io/flux/docs/in-depth-overview.html#content][Link]]
- [[https://youtu.be/nYkdrAPrdcw?list=PLb0IAmt7-GS188xDYE-u1ShQmFFGbrk0v][Video]]

** Reference

*** Disptacher Docs

#+CINDEX:Dispatcher
Dispatcher is used to broadcast payloads to registered callbacks. This is
different from generic pub-sub systems in two ways:

- Callbacks are not subscribed to particular events. Every payload is
  dispatched to every registered callback.
- Callbacks can be deferred in whole or part until other callbacks have been
  executed.


Check out [[https://github.com/facebook/flux/blob/master/src/Dispatcher.js][Dispatcher.js]] for the source code.

  #+CINDEX:Dispatcher API
**** Dispatcher API

  #+CINDEX:@code{register()}
- ~register(function callback)~: string ::

     Registers a callback to be invoked with every dispatched payload. Returns
     a token that can be used with ~waitFor()~.

  #+CINDEX:@code{unregister()}
- ~unregister(string id)~: void ::

     Removes a callback based on its token.

  #+CINDEX:@code{waitFor()}
- ~waitFor(array<string> ids)~: void ::

     Waits for the callbacks specified to be invoked before continuing
     execution of the current callback. This method should only be used by a
     callback in response to a dispatched payload.

  #+CINDEX:@code{dispatch()}
- ~dispatch(object payload)~: void ::

     Dispatches a payload to all registered callbacks.

  #+CINDEX:@code{isDispatching()}
- ~isDispatching()~: boolean ::

      Is this Dispatcher currently dispatching.

**** Example

#+CINDEX:flight destination form
For example, consider this hypothetical flight destination form, which selects
a default city when a country is selected:

#+BEGIN_SRC js -n :eval no
var flightDispatcher = new Dispatcher();

// Keeps track of which country is selected
var CountryStore = {country: null};

// Keeps track of which city is selected
var CityStore = {city: null};

// Keeps track of the base flight price of the selected city
var FlightPriceStore = {price: null};
#+END_SRC

When a user changes the selected city, we dispatch the payload:

#+BEGIN_SRC js +n :eval no
flightDispatcher.dispatch({
  actionType: 'city-update',
  selectedCity: 'paris'
});
#+END_SRC

This payload is digested by CityStore:

#+BEGIN_SRC js +n :eval no
flightDispatcher.register(function(payload) {
  if (payload.actionType === 'city-update') {
    CityStore.city = payload.selectedCity;
  }
});
#+END_SRC

When the user selects a country, we dispatch the payload:

#+BEGIN_SRC js +n :eval no
flightDispatcher.dispatch({
  actionType: 'country-update',
  selectedCountry: 'australia'
});
#+END_SRC

This payload is digested by both stores:

#+BEGIN_SRC js +n :eval no
CountryStore.dispatchToken = flightDispatcher.register(function(payload) {
  if (payload.actionType === 'country-update') {
    CountryStore.country = payload.selectedCountry;
  }
});
#+END_SRC

When the callback to update ~CountryStore~ is registered, we save a reference
to the returned token. Using this token with ~waitFor()~, we can guarantee that
~CountryStore~ is updated before the callback that updates ~CityStore~ needs to
query its data.

#+BEGIN_SRC js +n :eval no
CityStore.dispatchToken = flightDispatcher.register(function(payload) {
  if (payload.actionType === 'country-update') {
    // `CountryStore.country` may not be updated.
    flightDispatcher.waitFor([CountryStore.dispatchToken]);
    // `CountryStore.country` is now guaranteed to be updated.

    // Select the default city for the new country
    CityStore.city = getDefaultCityForCountry(CountryStore.country);
  }
});
#+END_SRC

The usage of ~waitFor()~ can be chained, for example:

#+BEGIN_SRC js +n :eval no
FlightPriceStore.dispatchToken =
  flightDispatcher.register(function(payload) {
    switch (payload.actionType) {
      case 'country-update':
      case 'city-update':
        flightDispatcher.waitFor([CityStore.dispatchToken]);
        FlightPriceStore.price =
          getFlightPriceStore(CountryStore.country, CityStore.city);
        break;
  }
});
#+END_SRC

The ~country-update~ payload will be guaranteed to invoke the stores' registered
callbacks in order: ~CountryStore~, ~CityStore~, then ~FlightPriceStore~.

*** Flux Utils

#+CINDEX:Flux utils
#+CINDEX:utility classes, Flux
#+CINDEX:class, Flux utility
We have also provided some basic utility classes to help get you started with
Flux.  These base classes are a solid foundation for a simple Flux application,
but they are *not* a feature-complete framework that will handle all use cases.
There are many other great Flux frameworks out there if these utilities do not
fulfill your needs.

{{{heading(Usage)}}}

There are four[sic] main classes exposed in Flux Utils:

1. Store
2. ReduceStore
3. Container

These base classes can be imported from ~flux/utils~ like this:

#+CAPTION:Importing base classes from ~flux/utils~
#+NAME:flux-utils.js
#+BEGIN_SRC js :eval no
import {ReduceStore} from 'flux/utils';

class CounterStore extends ReduceStore<number> {
  getInitialState(): number {
    return 0;
  }

  reduce(state: number, action: Object): number {
    switch (action.type) {
      case 'increment':
        return state + 1;

      case 'square':
        return state * state;

      default:
        return state;
    }
  }
}
#+END_SRC

* Twitter Information

** Twitter User Docs

Everything you need to know so you can use Twitter like a pro

{{{heading(How to post photos or GIFs on Twitter)}}}

- [[https://help.twitter.com/en/using-twitter/tweeting-gifs-and-pictures]

To post a photo or GIF in a Tweet:

    1. Type your Tweet into the "What's happening" box at the top of your
       timeline, or click the =Tweet= button.
    2. Click the =gallery= button to upload a photo or GIF from your computer.
    3. To search for and select a GIF from the GIF library, click the =GIF=
       icon.  *Note*: Animated GIFs can't be included in Tweets with multiple
       images. You can send only one GIF in a Tweet.
    4. Once you choose a photo or GIF, the image will attach to your Tweet in
       full size. You can select up to 4 photos to Tweet at once.
    5. Click =Tweet= to post.  *Tip*: You can also send photos and GIFs in
       Direct Messages.

    What are the size and file type requirements?
    - Photos can be up to 5MB; animated GIFs can be up to 5MB on mobile, and up
      to 15MB on web.
    - We accept GIF, JPEG, and PNG files.
    - We DO NOT accept BMP, TIFF or other file formats.
    - Your photo will be automatically scaled for display in your expanded
      Tweet and in your gallery.

** [[https://developer.twitter.com][Twitter Developer]]

  - [[https://developer.twitter.com/en/use-cases/analyze][Analyze]] Use Case

    Evaluate Twitter data to inform business decisions.  Twitter data is the
    most comprehensive source of live, public conversation worldwide. Our REST,
    streaming, and Enterprise APIs enable programmatic analysis of data in
    real-time or back to the first Tweet in 2006. Get insight into audiences,
    market movements, emerging trends, key topics, breaking news, and much
    more.

    We offer several tools and endpoints to help you analyze conversations and
    respond to trends as they unfold.

- [[https://developer.twitter.com/en/docs.html][Twitter Developer Docs]]

  - [[https://developer.twitter.com/en/docs/basics/getting-started][Getting Started]] with the Twitter Developer Platform ::
       Twitters developer platform offers many APIs, tools, and resources that
       enable you to harness the power of Twitter's open, global and real-time
       communication network.

       What do you want to build?
    - Integrate Tweets into your app or website?
    - Add the ability to post Tweets or send Direct Messages from your app or
      website?
    - Target an audience and advertise on the Twitter network?
    - *Listen in real-time for Tweets of interest?*
    - Conduct historical research and search from Twitter's massive archive of
      publicly-available Tweets posted since March 2006?
    - Measure how your Tweets or account are engaged with?

      All of these use cases can be implemented with a Twitter API, or in many
      cases a combination of APIs.

  - Twitter's Developer Tools and APIs ::
       Twitters developer platform includes numerous API endpoints and tools
       to help you build an app and solution on Twitter.  Please review our full
       set of developer APIs and tools on our [[https://developer.twitter.com/en/products/products-overview][Products Overview]] page.  These
       tools include the following:
    - Standard APIs
    - Premium APIs
    - Enterprise APIs
    - Ads APIs
    - Twitter for websites

      #+CINDEX:Twitter App
      #+CINDEX:App, Twitter
      #+CINDEX:consumer keys
      #+CINDEX:access tokens
  - Creating a Twitter App ::
       Integrating with nearly all of the Twitter APIs requires the creation of
       a [[https://developer.twitter.com/en/docs/basics/developer-portal/guides/apps][Twitter app]] and the generation of consumer keys and access tokens.
       The only exception to this are the *enterprise search*, *batched
       historical*, and *streaming APIs*.

       #+CINDEX:app authentication
       #+CINDEX:user authentication
       #+CINDEX:account authentication
       #+CINDEX:authentication, app, user, account
       Visit the [[https://developer.twitter.com/en/docs/basics/developer-portal/overview][developer portal]] with an approved developer account to create
       a Twitter app and generate your authentication tokens.  These include:
    - =consumer= tokens and secrets for app authentication, and
    - =access= tokens and secrets for user/account authentication.

** Twitter Authentication
https://developer.twitter.com/en/docs/basics/authentication/overview/authentication-and-authorization

*** Overview

**** Authentication and Authorization

#+CINDEX:authentication
#+CINDEX:authorization
Using the Twitter API requires

 - an authorized Twitter App and
 - authenticated requests.

{{{subheading(Authentication Methods)}}}

The Twitter API supports a few authentication methods depending on the
endpoint.  Each endpoint's API reference document will describe the required
authentication method.

When considering an API endpoint, it's important to note which authentication
is needed on the request and create a plan for authorization when developing
your application.  In general,

 - endpoints related to specific user information will require OAuth
   (Application-user) authentication, and

 - endpoints related to retrieving publicly available information will require
   OAuth2 (bearer token) or Basic Auth (for Enterprise data APIs).

   #+CINDEX:OAuth2
   #+CINDEX:bearer token
   #+CINDEX:OAuth 1a
   #+CINDEX:application-user, OAuth 1a
For Standard REST and Streaming API, the required authentication method is
 - OAuth2 (bearer token)
 - OAuth 1a (application-user)

**** Authentication---OAuth with the Twitter API
Twitter uses OAuth 1.0a and OAuth2 to provide authorized access to the API.

***** Twitter API Authentication Model

#+CINDEX:application-only authentication
#+CINDEX:authentication, application-only
#+CINDEX:OAuth2 bearer token
#+CINDEX:bearer token OAuth2
{{{subheading(Application-only authentication: OAuth2 (bearer token))}}}

Application-only authentication is a form of authentication where an
application makes API requests on its own behalf, without the user context.
This method is for developers that just need read-only to access public
information.

Example: If a developer is trying to view Tweets or lists that are publically
available, then they just have to use application-only authentication.

#+CINDEX:bearer token, generate
To use this method, you need to use a *bearer token*.  You can generate a
*bearer token* by passing your /consumer key/ and /secret/ through the [[https://developer.twitter.com/en/docs/basics/authentication/api-reference/token][POST
oauth2 / token]] endpoint.

#+CINDEX:rate limited
API calls using app-only authentication are rate limited per API method at the
app level.

{{{subheading(Application-user authentication: OAuth 1a (access token for user context))}}}

#+CINDEX:user authentication
#+CINDEX:authentication, user
#+CINDEX:OAuth1a
The user authentication method of authentication allows an authorized app to
act on behalf of the user, as the user.

Example: if a developer wanted to build a feature that would allow a user to
post Tweets through their platform using the statuses/update endpoint, the
developer would have to use *user authentication* to get permission from the
user to post a Tweet on their behalf.

#+CINDEX:signed request
#+CINDEX:access token, user's
#+CINDEX:app identity
#+CINDEX:identity, app
#+CINDEX:permissions, granted
#+CINDEX:user identity
In other words, a *signed request* identifies an applications identity in
addition to the identity accompanying granted permissions of the end-user the
application is making API calls on behalf of, represented by the *users access
token*.

#+CINDEX:consumer key and secret
#+CINDEX:access token and secret
User authentication requires the consumer key and secret from your Twitter app
and the access token and access token secret retrieved through the
[[https://developer.twitter.com/en/docs/basics/authentication/overview/3-legged-oauth][3-legged-OAuth]] process with the user that the developer is acting on the behalf
of.

***** Application-only Authentication

#+CINDEX:authenticated requests
#+CINDEX:requests, authenticated
Twitter offers applications the ability to issue *authenticated requests* on
behalf of the application itself (as opposed to on behalf of a specific user).

{{{heading(OAuth2 Client Credentials Grant Flow)}}}

#+CINDEX:OAuth2
#+CINDEX:Client Credentials Grant flow
#+CINDEX:application only authentication
Twitters implementation is based on the [[http://tools.ietf.org/html/rfc6749#section-4.4][Client Credentials Grant]] flow of the
[[http://tools.ietf.org/html/rfc6749][OAuth 2 specification]]. [fn::OAuth 1.0a is still required to issue requests on
behalf of users.]]

With application-only authentication, you can perform the following:

- Pull user timelines;
- Access friends and followers of any account;
- Access lists resources;
- Search in Tweets;
- Retrieve any user information, excluding the user's email address;


#+CINDEX:user context
#+CINDEX:user authentication
#+CINDEX:access token
You will need user context, or user authentication with an access token to
perform the following:

- Post Tweets or other resources;
- Connect to Streaming endpoints;
- Search for users;
- Use any geo endpoint;
- Access Direct Messages or account credentials;
- Retrieve user's email addresses;

***** Auth Flow
The application-only auth flow follows these steps:

- An application encodes its consumer key and secret into a specially encoded
  set of credentials.

- An application makes a request to the [[https://developer.twitter.com/oauth/reference/post/oauth2/token][POST oauth2 / token]] endpoint to
  exchange these credentials for a bearer token.

- When accessing the REST API, the application uses the bearer token to
  authenticate.


Because there is no need to sign a request, this approach is dramatically
simpler than the standard OAuth 1.0a model.

#+begin_comment
The following conditional statements are necessary because the HTML looks for
the figure from a different source than the INFO.  However, when this source
file is compiled, it is compiled from the root directory, and therefore does
not find the 'figures/' directory and throws a warning.  This warning should be
ignored.
#+end_comment

#+caption:Application-only auth flow
#+name:appauth0.png
#+texinfo:@ifnothtml
[[file:figures/appauth0.png]]
#+texinfo:@end ifnothtml
#+texinfo:@ifhtml
[[file:../figures/appauth0.png]]
#+texinfo:@end ifhtml

***** Application-Only Auth
{{{heading(Tokens are Passwords)}}}

#+CINDEX:passwords
#+CINDEX:consumer key, secret, password
#+CINDEX:bearer token credentials, password
Keep in mind that the consumer key and secret, bearer token credentials, and
the bearer token itself grant access to make requests on behalf of an
application.  These values should be considered as sensitive as passwords, and
must not be shared or distributed to untrusted parties.

{{{heading(SSL Required)}}}

#+CINDEX:SSL
#+CINDEX:HTTPS endpoints
All requests (both to obtain and use the tokens) must use HTTPS endpoints.

#+CINDEX:connecting to Twitter
#+CINDEX:peers, verify
Follow the best practices detailed in [[https://developer.twitter.com/overview/api/tls][Connecting to Twitter API using TLS]] ---
peers should always be verified.

{{{heading(Rate Limiting)}}}

Applications have two kinds of rate limiting pools.

Requests made on behalf of users with access tokens depletes from a different
rate limiting context than that used in application-only authentication.

[[https://developer.twitter.com/rest/reference/get/application/rate_limit_status][GET application / rate_limit_status]] supports application-only authentication.
By issuing requests to this method with your application bearer token, youll
receive a response indicating the current windows per-resource rate limiting
context.  You will receive an ``application'' field instead, with the value
being your application's consumer key.

#+begin_src js :eval no
{
  "rate_limit_context": {
      "application": "nXtEH7H0mi0qT8kSyo7DQ"
  },
  "resources": {
    "search": {
      "/search/tweets": {
        "limit": 450,
        "remaining": 420,
        "reset": 1362436375 }
    }
  }
}
#+end_src

**** Issuing Application-Only Requests

***** Encode Consumer Key and Secret
The steps to encode an applications consumer key and secret into a set of
credentials to obtain a bearer token are:

1. URL encode the consumer key and the consumer secret according to [[https://www.rfc-editor.org/info/rfc1738][RFC 1738]].
   [fn::Note that at the time of writing, this will not actually change the consumer
   key and secret, but this step should still be performed in case the format
   of those values changes in the future.]

2. Concatenate the encoded consumer key, a colon character =:=, and the encoded
   consumer secret into a single string.

3. [[http://en.wikipedia.org/wiki/Base64][Base64 encode]] [fn::Base64 is a group of binary-to-text encoding schemes that
   represent binary data in an ASCII string format by translating it into a
   radix-64 representation.  Each Base64 digit represents exactly 6 bits of
   data (2^6 = 64).] the string from the previous step.

***** Obtain a Bearer Token
The value calculated in step 1 must be exchanged for a bearer token by issuing
a request to [[https://developer.twitter.com/oauth/reference/post/oauth2/token][POST oauth2 / token]]:

- The request must be a =HTTP POST= request.
- The request must include an =Authorization= header with the value of =Basic
  <base64 encoded value from step 1>=.
- The request must include a =Content-Type= header with the value of
  =application/x-www-form-urlencoded;charset=UTF-8=.
- The body of the request must be =grant_type=client_credentials=.

#+caption:Example request (Authorization header has been wrapped):
#+name:bearer-token-request
#+begin_example
POST /oauth2/token HTTP/1.1
Host: api.twitter.com
User-Agent: My Twitter App v1.0.23
Authorization: Basic eHZ6MWV2RlM0d0VFUFRHRUZQSEJvZzpMOHFxOVBaeVJn
                     NmllS0dFS2hab2xHQzB2SldMdzhpRUo4OERSZHlPZw==
Content-Type: application/x-www-form-urlencoded;charset=UTF-8
Content-Length: 29
Accept-Encoding: gzip

grant_type=client_credentials
#+end_example

If the request was formatted correctly, the server will respond with a
JSON-encoded payload:

#+caption:Example Response
#+name:example-response
#+begin_example
HTTP/1.1 200 OK
Status: 200 OK
Content-Type: application/json; charset=utf-8
...
Content-Encoding: gzip
Content-Length: 140

{"token_type":"bearer","access_token":"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%2F
AAAAAAAAAAAAAAAAAAAA%3DAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"}
#+end_example

Applications should verify that the value associated with the =token_type= key
of the returned object is =bearer=.  The value associated with the =access_token=
key is the bearer token.

Note that one bearer token is valid for an application at a time. Issuing
another request with the same credentials to /oauth2/token will return the same
token until it is invalidated.

***** Authenticate API requests with the bearer token
The bearer token may be used to issue requests to API endpoints which support
application-only auth.

To use the bearer token, construct a normal HTTPS request and include an
=Authorization= header with the value of
: Bearer <base64 bearer token value from step 2>
Signing is not required.

#+caption: Example Request
#+name:example-request
#+begin_example
GET /1.1/statuses/user_timeline.json?count=100&screen_name=twitterapi HTTP/1.1
Host: api.twitter.com
User-Agent: My Twitter App v1.0.23
Authorization: Bearer AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%2FAAAAAAAAAAAA
                      AAAAAAAA%3DAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Accept-Encoding: gzip
#+end_example

*** Guides

*** FAQs

*** API Reference

** Twitter Tutorial on Consuming Streaming Data

- [[https://developer.twitter.com/en/docs/tutorials/consuming-streaming-data][Consuming streaming data]]

* Snapkite Engine

Snapkite Engine gives you filtered stream of photos posted publicly on Twitter.

- [[https://github.com/Snapkite][Snapkite on Github]]
- [[https://github.com/snapkite/snapkite-engine][Snapkite Engine on Github]]

It can do 2 (either or both) things with those photos:

1. Send them to a socket connection and allow all your clients to receive them
   in real-time.
2. Store them in MongoDB and retrieve later with [[https://github.com/snapkite/snapkite-api-server.git][Snapkite API Server]] or your
   own application.

{{{heading(Examples)}}}

- [[http://snapterest.com/][Snapterest.com]]
- [[http://map.snapkite.com/][Map.Snapkite.com]]

** Installation Instructions

- https://github.com/snapkite/snapkite-engine#install


1. git clone https://github.com/Snapkite/snapkite-engine.git
2. cd snapkite-engine
3. npm install
4. cp example.config.json config.json
5. Add your Twitter API keys to config.json
6. Change default MongoDB config in config.json

** Configure Instructions

- https://github.com/snapkite/snapkite-engine#configure


You can configure Snapkite Engine by editing config.json.

- ~application.pushTweets~ :: Send tweets to client?  Expects true or false.

- ~application.storeTweets~ :: Store tweets in a MongoDB collection?  Expects
     true or false.

- ~application.pushKeywords~ :: Send keyword stats to client?  Expects true or
     false.

- ~application.trackKeywords~ ::
     Which keywords should we ask Twitter to track for us?  Expects a string of
     keywords separated by a single whitespace or comma, e.g.: =selfie london= or
     =selfie,london=

     Read this for more details:
     https://dev.twitter.com/streaming/overview/request-parameters#track

- ~application.excludeKeywords~ ::
     Which keywords should be ignored?  Expects a string of keywords separated
     by a comma, e.g.: =exclude,these,keywords=

- ~application.filters~ ::
     List of Snapkite filters that this application should use. You can find
     the list of all available filters [[https://github.com/snapkite/snapkite-engine/tree/master/filters/README.md][here]].

- ~application.twitter.api~ ::
     Twitter API keys that Twitter provides you with. You can find them [[https://apps.twitter.com/][here]].

- ~application.database~ :: MongoDB connection configuration.

- ~application.socket~ :: Socket configuration.

** Snapkite Filters

[[https://github.com/snapkite/snapkite-filters/blob/master/README.md][Everything you need to know]] about Snapkite filters.

** MongoDB

https://github.com/snapkite/snapkite-engine#mongodb

* Browserify
:PROPERTIES:
:appendix: t
:END:

- Description :: "browser-side require() the node way"

{{{file(browserify)}}} is a tool for compiling a system of node-flavored
commonjs modules and dependencies into a single bundled source file for
consumption by the browser via the inclusion of a =<script>= tag that sources
the bundled file.  In other words, Browserify lets you ~require('modules')~ in
the browser by bundling up all dependencies.

- [[http://browserify.org][Browserify Home]]
- [[https://github.com/browserify/browserify][Browserify GitHub]]
- [[https://github.com/browserify/browserify#usage][Browserify Documentation on GitHub]]
- [[https://github.com/browserify/browserify-handbook][Browserify Handbook]] :: This document written by @substack covers how to use
     browserify to build modular applications. Recommended as a starting point.
- [[http://lincolnloop.com/blog/untangle-your-javascript-browserify/][Untangle Your JavaScript with Browserify]] :: A straightforward introduction to
     browserify, including integration with Grunt and Gulp.


You can use {{{file(browserify)}}} to organize your code and use third-party
libraries even if you don't use Node itself in any other capacity except for
bundling and installing packages with {{{command(npm)}}}.

Browsers don't have the ~require~ method defined, but Node.js does.  With
Browserify you can write code that uses ~require~ in the same way that you
would use it in Node.

** Installing and Using Browserify

The {{{command(browserify)}}} command can be installed globally, allowing one
to use Browserify from the command line.  The command {{{command(browserify)}}}
depends upon Node being installed.  After that, to install
{{{command(browserify)}}} globally:

: npm install -g browserify

To use {{{command(browserify)}}} globally:

: browserify main.js -o bundle.js
: <script src="bundle.js"></script>

The {{{command(browserify)}}} command parses the AST for ~require()~ calls in
order to traverse the entire dependency graph of your project and produce a
single bundled, compiled file.  That is, Browserify recursively bundles up all
the required modules starting at ~main.js~ into a single file called
~bundle.js~.  The =<script>= tag sources the bundled file in a browser,
allowing the code to run.

* Babelify
:PROPERTIES:
:appendix: t
:END:

``Babel browserify transform''

- [[https://www.npmjs.com/package/babelify][Babelify Home]]
- [[https://github.com/browserify/browserify][Babelify GitHub]]

For {{{command(babelify)}}} to be useful, you must also include some presets
and/or plugins.

- ~@babel/preset-env~ ::
  + https://www.npmjs.com/package/@@babel/preset-env
  + https://babeljs.io/docs/en/next/babel-preset-env
  + ``A Babel preset for each environment.''
  + ~@babel/preset-env~ is a smart preset that allows you to use the latest
    JavaScript without needing to micromanage which syntax transforms (and
    optionally, browser polyfills) are needed by your target environment(s).
    This both makes your life easier and JavaScript bundles smaller!
  + Installation
    : npm install --save-dev @babel/preset-env

- ~@babel/preset-react~ ::
  + https://www.npmjs.com/package/@@babel/preset-react
  + https://babeljs.io/docs/en/next/babel-preset-react.html
  + ``Babel preset for all React plugins.''
  + This preset always includes the following plugins:
    - ~@babel/plugin-syntax-jsx~
    - ~@babel/plugin-transform-react-jsx~
    - ~@babel/plugin-transform-react-display-name~
  + Installation
    : npm install --save-dev @babel/preset-react

{{{heading(Install Babelify for Babel v7)}}}

: # Babel 7
: $ npm install --save-dev babelify @babel/core

{{{heading(Usage in Node)}}}

 Presets and plugins need to be installed as separate modules.  For the example
 below to work, you need to install ~@babel/preset-env~ and
 ~@babel/preset-react~:

: $ npm install --save-dev @babel/preset-env @babel/preset-react

#+BEGIN_SRC js :eval no
var fs = require("fs");
var browserify = require("browserify");
browserify("./script.js")
  .transform("babelify", {presets: ["@babel/preset-env", "@babel/preset-react"]})
  .bundle()
  .pipe(fs.createWriteStream("bundle.js"));
#+END_SRC

Options may be passed in via standard {{{command(browserify)}}} ways.  By
default, all files with the extensions =.js=, =.es=, =.es6= and =.jsx= are
compiled.

* Babel
:PROPERTIES:
:APPENDIX: t
:END:

- [[https://babeljs.io/][Babel]]
- [[https://github.com/babel/babel][Babel on Github]]
- [[https://babeljs.io/docs/en/v7-migration][Upgrade to Babel 7]]

Babel is a toolchain that is mainly used to convert ECMAScript 2015+ code into
a backwards compatible version of JavaScript in current and older browsers or
environments.  Babel is a compiler (source code => output code) for writing
next generation JavaScript.  It runs in 3 stages: parsing, transforming, and
printing.

Babel 7 is out, with breaking changes.  See [[*Upgrading to Babel 7][Upgrading to Babel 7]] for
information.  For ~babelify~ to be useful, you must also include some presets
and/or plugins.

- Transform syntax
- Polyfill features that are missing in your target environment (through
  =@babel/polyfill=)
- Source code transformations (codemods)

** JSX and React

Babel can convert JSX syntax!  Check out our [[https://babeljs.io/docs/en/babel-preset-react][React preset]] to get started. Use
it together with the =babel-sublime=p package to bring syntax highlighting to a
whole new level.

** Installation

{{{heading(Babel 7)}}}

Install the React preset with:

: npm install --save-dev @babel/preset-react

and add =@babel/preset-react= to your Babel configuration.

{{{subheading(Babelify Installation)}}}

: # Babel 7 ; babelify 10.0.0
: npm install --save-dev babelify @babel/core

{{{heading(Babel 6)}}}

** Usage

Now, out of the box Babel doesn't do anything.  It basically acts like =const
babel = code => code=; by parsing the code and then generating the same code
back out again.  You will need to add plugins for Babel to do anything.

#+CINDEX:plugins, Babel
#+CINDEX:presets, Babel
{{{heading(Presets and Plugins)}}}

Babel is built out of {{{dfn(plugins)}}}.  Compose your own transformation
pipeline using existing plugins or write your own.  Easily use a set of plugins
by using or creating a preset.

Instead of individual plugins, you can also enable a set of plugins in a
{{{dfn(preset)}}}.

NOTE: Presets and plugins need to be installed as separate modules. For the
examples to work, you'd need to also install ~@babel/preset-env~ and
~@babel/preset-react~:

{{{subheading(Transform Plugins)}}}

These plugins apply transformations to your code.  React has a group of
transforms, including:

- ~react-jsx~

{{{subheading(Syntax Plugins)}}}

These plugins only allow Babel to parse specific types of syntax (not
transform).

*NOTE:* transform plugins automatically enable the syntax plugins. So you don't
need to specify the syntax plugin if the corresponding transform plugin is used
already.

{{{subheading(CLI)}}}

All the Babel modules you'll need are published as separate npm packages scoped
under =@babel= (since version 7).  This modular design allows for various tools
each designed for a specific use case.

~@babel/cli~ is a tool that allows you to use babel from the terminal. Here's
the installation command and a basic usage example:
: npm install --save-dev @babel/core @babel/cli
: ./node_modules/.bin/babel src --out-dir lib

This will parse all the JavaScript files in the src directory, apply any
transformations we have told it to, and output each file to the lib
directory. Since we haven't told it to apply any transformations yet, the
output code will be identical to the input (exact code styling is not
preserved). We can specify what transformations we want by passing them as
options.

We used the {{{option(--out-dir)}}} option above.  You can view the rest of the
options accepted by the {{{command(cli)}}} tool by running it with
{{{option(--help)}}}.  But the most important to us right now are
{{{option(--plugins)}}} and {{{option(--presets)}}}.

Transformations come in the form of plugins, which are small JavaScript
programs that instruct Babel on how to carry out transformations to the
code. You can even write your own plugins to apply any transformations you want
to your code. To transform ES2015+ syntax into ES5 we can rely on official
plugins like =@babel/plugin-transform-arrow-functions=:
: npm install --save-dev @babel/plugin-transform-arrow-functions
: ./node_modules/.bin/babel src --out-dir lib --plugins=@babel/plugin-transform-arrow-functions
Now any arrow functions in our code will be transformed into ES5 compatible
function expressions.

That's a good start! But we also have other ES2015+ features in our code that
we want transformed. Instead of adding all the plugins we want one by one, we
can use a "preset" which is just a pre-determined set of plugins.  Just like
with plugins, you can create your own presets too to share any combination of
plugins you need. For our use case here, there's an excellent preset named
~env~.
: npm install --save-dev @babel/preset-env
: ./node_modules/.bin/babel src --out-dir lib --presets=@babel/env
Without any configuration, this preset will include all plugins to support
modern JavaScript (ES2015, ES2016, etc.).  But presets can take options
too.  Rather than passing both cli and preset options from the terminal, let's
look at another way of passing options: configuration files.

{{{subheading(Configuration)}}}

There are a few different ways to use configuration files depending on your
needs.  Be sure to read our in-depth guide on how to [[https://babeljs.io/docs/en/configuration][configure Babel]] for more
information.

For now, let's create a file called babel.config.js with the following content:

#+BEGIN_SRC js :eval no
const presets = [
  [
    "@babel/env",
    {
      targets: {
        edge: "17",
        firefox: "60",
        chrome: "67",
        safari: "11.1",
      },
    },
  ],
];

module.exports = { presets };
#+END_SRC

Now the =env= preset will only load transformation plugins for features that
are not available in our target browsers.  We're all set for syntax. Let's look
at polyfills next.

{{{subheading(Browserify CLI)}}}

: $ browserify script.js -o bundle.js -t [ \
:    babelify \
:    --presets [ @babel/preset-env @babel/preset-react ] \
:    --plugins [ @babel/plugin-transform-class-properties ] \
: ]

{{{subheading(Node)}}}

#+BEGIN_SRC js :eval no
var fs = require("fs");
var browserify = require("browserify");
browserify("./script.js")
  .transform("babelify", {presets: ["@babel/preset-env", "@babel/preset-react"]})
  .bundle()
  .pipe(fs.createWriteStream("bundle.js"));
#+END_SRC

*NOTE:* Presets and plugins need to be installed as separate modules. For the
above examples to work, you'd need to also install @babel/preset-env and
@babel/preset-react:
: npm install --save-dev @babel/preset-env @babel/preset-react

{{{subheading(Options)}}}

See the babel docs for the complete list of [[http://babeljs.io/docs/usage/options/][options]].

** Upgrading to Babel 7

{{{subheading(Scoped Packages)}}}

The most important change is finally switching all packages to scoped packages
(the folder names in the monorepo are not changed but the name in its
~package.json~ is).

Your dependencies will need to be modified like so:
: babel-cli -> @babel/cli.
For us, we basically started by replacing =babel- =with @babel/=.

* Gulp
:PROPERTIES:
:appendix: t
:END:

- [[https://gulpjs.com][Gulp Home]]
- [[https://github.com/gulpjs/gulp][Gulp GitHub]]

* Listings
:PROPERTIES:
:APPENDIX: t
:END:
#+TEXINFO:@listoffloats Listing

* Figures
:PROPERTIES:
:APPENDIX: t
:END:
#+TEXINFO:@listoffloats Figure
* Index
  :PROPERTIES:
  :INDEX:    cp
  :END:
* COPYING
  :PROPERTIES:
  :COPYING:  t
  :END:
  {{{TITLE}}} by {{{AUTHOR}}}
  \copy 2015 Packt Publishing

#+BEGIN_QUOTE
A fast-paced guide to designing and building scalable and maintainable web apps
with React.js
#+END_QUOTE

{{{noindent}}} Outline Version {{{VERSION}}}

{{{noindent}}} Prepared by WLHarvey \copy {{{date(%Y)}}}

* MACROS                                                           :noexport:
#+MACRO:VERSION 0.0.9 {{{date(%F %R)}}}
#+MACRO:heading @@texinfo:@heading @@$1
#+MACRO:subheading @@texinfo:@subheading @@$1
#+MACRO:tiauthor @@texinfo:@author @@$1
#+MACRO:key @@texinfo:@key{@@$1@@texinfo:}@@
#+MACRO:file @@texinfo:@file{@@$1@@texinfo:}@@
#+MACRO:command @@texinfo:@command{@@$1@@texinfo:}@@
#+MACRO:samp @@texinfo:@samp{@@$1@@texinfo:}@@
#+MACRO:cite @@texinfo:@cite{@@$1@@texinfo:}@@
#+MACRO:noindent @@texinfo:@noindent @@
#+MACRO:dfn @@texinfo:@dfn{@@$1@@texinfo:}@@
#+MACRO:option @@texinfo:@option{@@$1@@texinfo:}@@
* EXPORT SETTINGS                                                  :noexport:
#+STARTUP:showall indent
#+OPTIONS: h:4
#+TEXINFO_CLASS: info
#+TEXINFO_HEADER:
#+TEXINFO_POST_HEADER:
#+TEXINFO_DIR_CATEGORY: React
#+TEXINFO_DIR_TITLE: React.js Essentials
#+TEXINFO_DIR_DESC:Fast-paced guide to designing web apps with React.js
